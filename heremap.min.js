(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.heremap = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    if (points.length <= 2) return points;

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (typeof define === 'function' && define.amd) define(function() { return simplify; });
else if (typeof module !== 'undefined') {
    module.exports = simplify;
    module.exports.default = simplify;
} else if (typeof self !== 'undefined') self.simplify = simplify;
else window.simplify = simplify;

})();

},{}],3:[function(require,module,exports){
function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects",
 "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(fn => {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function(...args) {
    this._defaults.push({fn, args});
    return this;
  }
});

Agent.prototype._setDefaults = function(req) {
    this._defaults.forEach(def => {
      req[def.fn].apply(req, def.args);
    });
};

module.exports = Agent;

},{}],4:[function(require,module,exports){
/**
 * Root reference for iframes.
 */

let root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

const Emitter = require('component-emitter');
const RequestBase = require('./request-base');
const isObject = require('./is-object');
const ResponseBase = require('./response-base');
const Agent = require('./agent-base');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

const request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = () => {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

const trim = ''.trim
  ? s => s.trim()
  : s => s.replace(/(^\s*|\s*$)/g, '');

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  const pairs = [];
  for (const key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(v => {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(const subkey in val) {
        pushEncodedKeyValuePair(pairs, `${key}[${subkey}]`, val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  const obj = {};
  const pairs = str.split('&');
  let pair;
  let pos;

  for (let i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  const lines = str.split(/\r?\n/);
  const fields = {};
  let index;
  let line;
  let field;
  let val;

  for (let i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) { // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  let status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str) {
  let parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  const req = this.req;
  const method = req.method;
  const url = req.url;

  const msg = `cannot ${method} ${url} (${this.status})`;
  const err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  const self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', () => {
    let err = null;
    let res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    let new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch(custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (1 === arguments.length) pass = '';
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    };
  }

  const encoder = string => {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  const fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  const err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = () => {
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  this._end();
};

Request.prototype._end = function() {
  if (this._aborted) return this.callback(Error("The request has been aborted even before .end() was called"));

  const self = this;
  const xhr = (this.xhr = request.getXHR());
  let data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = () => {
    const readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    let status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  const handleProgress = (direction, e) => {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    const contentType = this._header['content-type'];
    let serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (const field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
};

request.agent = () => new Agent();

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(method => {
  Agent.prototype[method.toLowerCase()] = function(url, fn) {
    const req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = (url, data, fn) => {
  const req = request('GET', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = (url, data, fn) => {
  const req = request('HEAD', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = (url, data, fn) => {
  const req = request('OPTIONS', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  const req = request('DELETE', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = (url, data, fn) => {
  const req = request('PATCH', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = (url, data, fn) => {
  const req = request('POST', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = (url, data, fn) => {
  const req = request('PUT', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./agent-base":3,"./is-object":5,"./request-base":6,"./response-base":7,"component-emitter":9}],5:[function(require,module,exports){
'use strict';

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],6:[function(require,module,exports){
'use strict';

/**
 * Module of mixed-in functions shared between node and client code
 */
const isObject = require('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (const key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(const option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

const ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function(err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      const override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch(e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    const self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise((innerResolve, innerReject) => {
      self.on('error', innerReject);
      self.end((err, res) => {
        if (err) innerReject(err);
        else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (const key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (const key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (const i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', `Basic ${base64Encoder(`${user}:${pass}`)}`);
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', `Bearer ${user}`);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function(n){
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header,
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  const isObj = isObject(data);
  let type = this._header['content-type'];

  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (const key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? `${this._data}&${data}`
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function(){
  const query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    const index = this.url.indexOf('?');
    if (index >= 0) {
      const queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = () => {console.trace("Unsupported");}

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  const err = new Error(`${reason + timeout}ms exceeded`);
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  const self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(() => {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(() => {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

},{"./is-object":5}],7:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

const utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (const key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    const ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    const params = utils.params(ct);
    for (const key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    const type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.created = 201 == status;
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
    this.unprocessableEntity = 422 == status;
};

},{"./utils":8}],8:[function(require,module,exports){
'use strict';

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = str => str.split(/ *; */).shift();

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = str => str.split(/ *; */).reduce((obj, str) => {
  const parts = str.split(/ *= */);
  const key = parts.shift();
  const val = parts.shift();

  if (key && val) obj[key] = val;
  return obj;
}, {});

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = str => str.split(/ *, */).reduce((obj, str) => {
  const parts = str.split(/ *; */);
  const url = parts[0].slice(1, -1);
  const rel = parts[1].split(/ *= */)[1].slice(1, -1);
  obj[rel] = url;
  return obj;
}, {});

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = (header, changesOrigin) => {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};

},{}],9:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],10:[function(require,module,exports){
/* global H, document, Image */
"use strict";
const cm = require("common");
const m = require("map");

// map on which to add the cluster layer
let map = null;

//the cluster layer
let clusterLayer = null;
let _visible = false;

let iconNoise = null;
let clusterStyle = []; // array of {weight,pos imagedata}

let clusteredDataProvider = null;


/**
 * creates a cluster of points
 * @alias hm:cluster
 * @param coords {Array}  array of \[lat,lng,payload\]
 * @param opt {object} options for cluster
 * @param [opt.minZoom] {number} min zoom for cluster to be visible
 * @param [opt.maxZoom] {number} max zoom for cluster to be visible
 * @param [opt.noise] {object} graphic to represent stand-alone point. {icon,size}
 * @param [opt.noise.icon] {string} png/jpg/scg file. @ as first character indicates a file from this package. Anchor will be bottom-center
 * @param [opt.noise.size] {number} optional size of icon
 * @param [opt.cluster] {object} { weight:{icon,size}, weight:{icon,size},... }
 * @param [opt.cluster.icon] {string} graphic for group of pois. @ as first character indicates a file from this package. Anchor will be middle of icon
 * @param [opt.cluster.size] {number} size of icon
 * @param {function} cb callback to be called if click on item. Format cb(event, coord, payload, weigth). 
 * `coord` is coord of icon
 * `payload` is payload associated to point. 
 * `weight` is number of points aggregated, when clicking on a cluster icon, 1 if single point
 * 
 * @return {H.map.layer.ObjectLayer}  layer created
 * 
 * @example
 * ```js
 * let pois = [[48.8,2.3,"Hello world"],[48.5,2.4,"How are you"],[45.2,2.93,"Very well"]];
 * 
 * hm.cluster(pois);
 * 
 * // with more graphic options and callback defined
 *   let opt = {
 *    noise: {
 *          icon: "mcdo.png",
 *          size: 12
 *      },
 *    cluster: {
 *       200: {
 *           icon: "@svg/cluster_red.svg",
 *           color: "#B50015",
 *           size: 64
 *       },
 *       75: {
 *           icon: "@svg/cluster_orange.svg",
 *           color: "#FF6900",
 *           size: 52
 *       },
 *       2: {
 *           icon: "@svg/cluster_green.svg",
 *           color: "#7BD30A",
 *           size: 40
 *        }
 *    }
 *   };
 *  hm.cluster(pois, opt,
 *           (event, coordinate, data, weight) => {
 *               if (data)
 *                   console.log("click on point ", data);
 *               else
 *                   console.log("click on cluster with weight", weight);
 *           });
 * ```
 */
async function cluster(coords, opt, cb = null) {

    let dataPoints = [];
    map = m.getMap();
    let _home = cm.getHome();

    let settings = {
        eps: 64,
        minZoom: 1, // min zoom
        maxZoom: 24, // max zoom
        noise: {
            icon: _home + "svg/bluedot.svg",
            size: 16
        },
        cluster: {
            200: {
                icon: _home + "svg/cluster_red.svg",
                color: "#B50015",
                size: 64
            },
            75: {
                icon: _home + "svg/cluster_orange.svg",
                color: "#FF6900",
                size: 48
            },
            2: {
                icon: _home + "svg/cluster_green.svg",
                color: "#7BD30A",
                size: 40

            }
        }
    };
    if (opt)
        Object.assign(settings, opt);

    let useTheme = true; // do we use our own theme ?
    if (!opt || (opt && !opt.noise && !opt.cluster))
        useTheme = false;

    coords.forEach(coord => {
        // use op_weight of 1 for each coord
        // provides all coord as data
        let dp = new H.clustering.DataPoint(coord[0], coord[1], 1, coord);
        dataPoints.push(dp);

    });

    let minWeight = 2; // minimum weight by default

    if (useTheme) {

        // creating icon for noise (individual point)
        let icon = settings.noise.icon;
        if (icon[0] == "@") // to indicate local
            icon = cm.getHome() + icon.substr(1);

        let iconOpt = null;
        if (settings.noise.size)
            iconOpt = {
                size: {
                    w: settings.noise.size,
                    h: settings.noise.size
                }
            };
        iconNoise = new H.map.Icon(icon, iconOpt);

        // get list of weight
        let weightOrder = Object.keys(settings.cluster).sort(function (a, b) {
            return b - a;
        });
        // minweight is the smallest weight
        minWeight = weightOrder[weightOrder.length - 1];

        let promises = [];
        clusterStyle = weightOrder.map((weight) => {
            let size = settings.cluster[weight].size;
            let icon = settings.cluster[weight].icon;
            if (icon[0] == "@") // to indicate local
                icon = cm.getHome() + icon.substr(1);

            let p = loadIconFile(icon, size, size);
            promises.push(p);
            let entry = {
                weight: parseInt(weight),
                icon: icon
            };
            return entry;
        });

        // wait for all promises to be resolved
        const result = await Promise.all(promises);
        // associated to each entry of clusterstyle
        result.forEach((imageData, i) => {
            clusterStyle[i].imageData = imageData;
        });

    }


    let optProvider = {
        clusteringOptions: {
            // Maximum radius of the neighborhood
            eps: settings.eps,
            // minimum weight of points required to form a cluster
            minWeight: minWeight
        },
        min: settings.minZoom, // min zoom
        max: settings.maxZoom // max zoom
    };

    // if we use our own theme
    if (useTheme)
        optProvider.theme = {
            getClusterPresentation: getClusterPresentation,
            getNoisePresentation: getNoisePresentation
        };

    // create cluster provider
    clusteredDataProvider = new H.clustering.Provider(dataPoints, optProvider);

    // Create a layer that includes the data provider and its data points:
    clusterLayer = new H.map.layer.ObjectLayer(clusteredDataProvider);
    // Add the layer to the map:
    map.addLayer(clusterLayer);

    // layer is visible by default
    _visible = true;

    // if a callback is defined, add event listener
    if (cb) {
        clusteredDataProvider.addEventListener("tap", function (ev) {
            // Log data bound to the marker that has been tapped:
            let data = ev.target.getData();
            let coord = map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            let isCluster = data.isCluster();

            if (isCluster) {
                let weigth = data.getWeight();
                cb(ev, m.coordO2A(coord), null, weigth);
            } else {
                let userData = data.getData(); // lat,lng, payload
                cb(ev, m.coordO2A(coord), userData[2], 1);
            }
        });
    }

    return clusterLayer;
}



// this function  creates the icon for a cluster
function getClusterPresentation(cluster) {

    // building data object which will be returned when clicking on the icon
    let data = {};
    data.isCluster = () => {
        return true;
    }; // so we know it is a cluster
    let weight = cluster.getWeight();

    data.getWeight = () => {
        return weight;
    }; // number of individual item clustered together

    // let's find the relevant color and size
    let entry = clusterStyle.find(elt => (weight >= elt.weight));
    let imageData = entry.imageData;

    let icon = buildClusterIcon(imageData, "" + weight);
    // create a marker for the Cluster
    let min = cluster.getMinZoom();
    let max = cluster.getMaxZoom();
    let clusterMarker = new H.map.Marker(cluster.getPosition(), {
        // to show it correctly at certain zoom levels:
        min: min,
        max: max,
        icon: icon,
    });

    // Link data from the from the cluster to the marker,
    // to make it accessible on callback
    clusterMarker.setData(data);

    return clusterMarker;
}

// function to represent a single item
function getNoisePresentation(noisePoint) {

    // data to be sent on callback
    const data = {
        getData: () => {
            return noisePoint.getData();
        },
        isCluster: () => {
            return false;
        },
        getWeight: () => {
            return 1;
        }
    };

    // Create a marker for the noisePoint
    var noiseMarker = new H.map.Marker(noisePoint.getPosition(), {
        // Use min zoom from a noise point
        // to show it correctly at certain zoom levels:
        min: noisePoint.getMinZoom(),
        icon: iconNoise
    });

    // Link a data from the point to the marker
    // to make it accessible on callback
    noiseMarker.setData(data);

    return noiseMarker;
}



/**
 * load a file into a canvas
 * @ignore
 * @param {String} url of png,jpg,svg file 
 * @param {Number} width for svg, define width
 * @param {number} height for svg, define height
 */
function loadIconFile(file, width = null, height = null) {
    return new Promise(
        (resolve) => {
            var newImg = new Image;
            newImg.onload = function () {
                let width = newImg.width;
                let height = newImg.height;
                // copy icon into a canvas
                let src = document.createElement("canvas");
                src.width = width;
                src.height = height;
                let ctx = src.getContext("2d");

                // copy image into canvas cluster
                ctx.drawImage(newImg, 0, 0, width, height);
                let imageData = ctx.getImageData(0, 0, width, height);

                resolve(imageData);
            };

            newImg.crossOrigin = "Anonymous"; // useful.. ?
            if (width) newImg.width = width;
            if (height) newImg.height = height;

            newImg.src = file;

        }
    );
}

/**
 * Build an icon by copying imageData and adding text
 * @ignore
 * @param {*} imgData  from canvas.getImageData
 * @param {String} text  text to write
 * @param {*Object} textPos  position of text as {x,y}
 */
function buildClusterIcon(imgData, text) {
    const canvas = document.createElement("canvas");
    canvas.width = imgData.width;
    canvas.height = imgData.height;
    let ctx = canvas.getContext("2d");
    const fontSize = 12;

    ctx.font = "bold " + fontSize + "px Arial";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";

    ctx.putImageData(imgData, 0, 0);
    ctx.fillText(text, canvas.width / 2, (canvas.height + fontSize) / 2 - 2);

    return new H.map.Icon(canvas, {
        anchor: {
            x: canvas.width / 2,
            y: canvas.height / 2
        }
    });
}



/**
 * Hide cluster layer
 *  @alias hm:clusterHide
 */
function clusterHide() {
    if (!_visible || !clusterLayer)
        return;

    map.removeLayer(clusterLayer);
    _visible = false;
}

/**
 * show Cluster layer
 * @alias hm:clusterShow
 */
function clusterShow() {
    if (_visible || !clusterLayer)
        return;

    map.addLayer(clusterLayer);
    _visible = true;

}



module.exports = {
    cluster: cluster,
    clusterShow: clusterShow,
    clusterHide: clusterHide
};
},{"common":11,"map":14}],11:[function(require,module,exports){
(function (process){
"use strict";
/* global document */

/**
 * @file generic function of heremap
 * @author devbab
 */

const request = require("superagent");

// by default, unless specified fby calling config
// environment usable with node
let APP_ID = process.env.APP_ID;
let APP_CODE = process.env.APP_CODE;
let CIT = ""; // production by default
let PROTOCOL = "https:"; // by default
let _useHTTPS = true; // by default
let _home = ".";


// find out where we are and relative position for png/svg files
// pay attention if library is build in ./dist
if (process.browser) {
    let _script = document.getElementsByTagName("script");
    let _file = _script[_script.length - 1].src;
    let _path = _file.substring(0, _file.lastIndexOf("/"));
    let pos = _path.indexOf("heremap");
    _home = _path.substring(0, pos + "heremap".length) + "/";

}

/**
 * To configure app_id, app_code and optionally use CIT and http
 * @alias hm:config
 *
 * @param opt {Object}  - `opt` with parameters.
 * @param [opt.app_id] {string} - the app_id from developer.here.com
 * @param [opt.app_code] {string} - the app_code from developer.here.com
 * @param [opt.useCIT=false] {boolean} - true to use CIT environment. 
 * @param [opt.useHTTP=false] {string} - true to use HTTP. 
 * @param [opt.useHTTPS=true] {string} - true to use HTTPS. 
 *
 * @example
 * ```js
 *  hm.config({
 *      app_id: "YOUR APP_ID",
 *      app_code: "YOUR APP_CODE",
*   });
*  ```
 */
function config(opt) {
    if (opt.app_id) APP_ID = opt.app_id;
    if (opt.app_code) APP_CODE = opt.app_code;
    if (opt.useCIT) CIT = ".cit";
    if (opt.useHTTP) {
        PROTOCOL = "http:";
        _useHTTPS = false;
    }
    if (opt.useHTTPS) {
        PROTOCOL = "https:";
        _useHTTPS = true;
    }
}

/**
 * return URL of module home directory. 
 * svg icons are under getHome()+"/svg/"
 * images are under getHome()+"/img/"
 * @ignore
 *  @alias hm:getHome
 * @return {string} url of home directory including http or https. 
 */
function getHome() {
    return _home;
}

/**
 * returns app_id
 * @ignore
 *  @alias hm:getAppId
 * @return {string} app_id
*/
function getAppId() {
    return APP_ID;
}

/**
 * return app_code
 *  @ignore
 *  @alias hm:getHome
 *  @alias hm:getAppCode
  * @return {string} app_code
*/
function getAppCode() {
    return APP_CODE;
}

/**
 * return true if using CIT
 * @ignore
 * @alias hm:getCIT
 * @return {booolean} true if using CIT
*/
function getCIT() {
    return CIT;
}

/**
 * return protocol used, http:// or https://
 * @ignore
 * @alias hm:getProtocol
 * @return {string} - protocol
*/
function getProtocol() {
    return PROTOCOL;
}

/**
 * return true is https is used
 * @ignore
 *  @alias hm:useHTTPS
 * @return {boolean} - true if https is used
*/
function useHTTPS() {
    return _useHTTPS;
}

/**
 * add credentials to object provided
  * @ignore
 *  @alias hm:addCredentials
 * @param  {...objects} list of `objects` 
 * @return {object} object with all input objectconcatenated, and app_id/app_code inserted
 */
function addCredentials(...obj) {
    return Object.assign({
        app_id: APP_ID,
        app_code: APP_CODE
    }, ...obj);
}

/**
 * build HERE REST full url, taking in account protocol and cit. for instance  cm.buildUrl("geocoder", "api.here.com/6.2/geocode.json"
 * @ignore
 * @alias hm:buildUrl
 * @param {string} base - base name
 * @param {string} endpoint - end point
 * @return {string} full url
 */
function buildUrl(base, endpoint) {
    return PROTOCOL + "//" + base + CIT + "." + endpoint;
}

/**
 * does get/post request to HERE RESDT backend and manage main errors
 * @ignore
 * @alias hm:hereRest
 * @param {string} url  - url to call , for instance from buildUrl
 * @param {object} settings - settings to add in request
 * @param  {string} mode=get - mode "get" or "post"
 * @return {promise} - promise to resolve/reject
 */
async function hereRest(url, settings, mode = "get", needresp = "true") {

    let p = request.get(url);
    if (mode == "post")
        p = request.post(url);

    return p
        .query(settings)
        .then(res => {
            // res.body, res.headers, res.status
            if (res.status != "200") {
                let e = new Error("Error " + res.status + ":" + res.body); // e.message
                throw (e);
            }

            if (needresp && !res.body.Response && !res.body.response) { // one of the two should be in the answer
                console.error(res.body);
                let e = new Error("Query error:" + res.body); // e.message
                throw (e);
            }

            if (res.body.response && res.body.response.type == "ApplicationError") {
                console.error(res.body);
                let e = new Error("Error" + res.body.response.details); // e.message
                throw (e);
            }

            return res;
        });
}

module.exports = {
    config: config,
    buildUrl: buildUrl,
    getAppId: getAppId,
    getAppCode: getAppCode,
    getCIT: getCIT,
    getProtocol: getProtocol,
    getHome: getHome,
    useHTTPS: useHTTPS,
    addCredentials: addCredentials,
    hereRest: hereRest
};
}).call(this,require('_process'))

},{"_process":1,"superagent":4}],12:[function(require,module,exports){
/**
 * @file Geocoding functions : addresses <--> [lat,lng]
 * @author Devbab 
 */

"use strict";
const cm = require("./common.js");

/**
 * geocode an address
 * @alias hm:geocode
 * @param address {string}  address as string
 * @returns  {Promise}   {coord,body}. coord is geocode as \[lat,lng\]. body is full json answer
 * 
 * @example
 * ```js
 * const res = await hm.geocode("avenue des chaps elysees, paris");
 * console.log (res.coord);
 * ```
 */
function geocode(address) {

    const settings = cm.addCredentials({
        searchText: address
    });

    const url = cm.buildUrl("geocoder", "api.here.com/6.2/geocode.json");
    return cm.hereRest(url, settings)
        .then(res => {

            if (res.body.Response.View.length == 0) {
                let e = new Error("Geocode Address not found: " + address); // e.message
                throw (e);
            }

            var location = res.body.Response.View[0].Result[0].Location;
            var coord = [location.NavigationPosition[0].Latitude, location.NavigationPosition[0].Longitude];
            return { coord: coord, body: res.body };
        });
}


/**
 * reverse geocode a coordinate
 * @alias hm:reverseGeocode
 * @param coord {Coord}  - coord \[lat,lng\] to reverse-geocode
 * @returns  {Promise} returns { location:object, address:object, body:object}. 
 */
function reverseGeocode(coord) {

    const settings = cm.addCredentials({
        mode: "retrieveAddresses",
        prox: coord[0] + "," + coord[1]
    });

    const url = cm.buildUrl("reverse.geocoder", "api.here.com/6.2/reversegeocode.json");

    return cm.hereRest(url, settings)
        .then(res => {
            // res.body, res.headers, res.status
            var location = res.body.Response.View[0].Result[0].Location;
            return ({ location: location, address: location.Address, body: res.body });
        });
}


module.exports = {
    geocode: geocode,
    reverseGeocode: reverseGeocode
};


},{"./common.js":11}],13:[function(require,module,exports){
const simplifyJs = require("simplify-js");

/**
 * Convert array of [lat,lng] to array of {x,y}
 * @alias hm:coords2XY
 * @param {array} coords array of [lat,lng]
 * @return {array}array of {x,y}
 */
function coords2XY(coords) {
    return coords.map(coord => { return { x: coord[1], y: coord[0] }; });
}
/**
 * Convert array of {x,y} to array of [lat,lng]
 * @alias hm:xy2Coords
 * @param {array} coords array of {x,y} 
 * @return {array}array of [lat,lng]
 */
function xy2Coords(xys) {
    return xys.map(xy => [xy.y, xy.x]);

}

/**
 * Simplify a polyline by using the Ramer-Douglas-Peucker algorithm
 * @alias hm:simplify
 * @param {array} coords array of [lat,lng]
 * @param {number} tolerance 
 * @return {array} simplified polyline
 */
function simplify(coords, tolerance, highacc = false) {

    // convert to xy
    let xy = coords2XY(coords);
    let simplified = simplifyJs(xy, tolerance, highacc);

    if (simplified.length < 1) // not enough points
        return coords;

    // convert back to [lat,lng]
    return xy2Coords(simplified);
}



module.exports = {
    coords2XY: coords2XY,
    xy2Coords: xy2Coords,
    simplify: simplify
};
},{"simplify-js":2}],14:[function(require,module,exports){
/* global H, fetch, document, navigator, mapsjs, window APP_ID_JAPAN,APP_CODE_JAPAN,APP_ID_KOREA,APP_CODE_KOREA*/

/**
 * @file manages map display on a web canvas
 * @author devbab
 */

"use strict";
const cm = require("./common.js");

let _platform = null;
let _provider = null;
let _defaultLayers = null;
let _ui = null;
let _map = null;
let _behavior = null;
let group = null;
let _layers = []; // list all layers
let _key = {}; // keys  
let _bubbleMarker = null; // bubble de mamrker
let _scheme = "normal.day.grey";
let _locateMe = null; // id when locate is active
let _htmlItem = null; //the html item on which to put the map


function coordO2A(obj) {
    return [obj.lat, obj.lng];
}

function coordA2O(arr) {
    return {
        lat: arr[0],
        lng: arr[1]
    };
}


/**
 * create a map area within the specified item
  * @alias hm:map

 * @param htmlItem {string}  - identifier of html div item on which to insert map
 * @param opt {object}  - options
 * @param [opt.zoom=10] {number}  - zoom factor
 * @param [opt.center=[48.86, 2.3]] {Coord}  - Coord of the center
 * @param [opt.scheme=normal.day.grey] {string}  - any scheme defined by HERE, plus "japan", "korea", "black", "white", "transparent". For japan/korea, one needs special credentials as APP_[ID|CODE]_JAPAN APP_[ID|CODE]_KOREA
 * @param [opt.click=null] {function()}  - callback on mouse click: callback(coord,button,key)
 * @param [opt.dbClick=null] {function()}  - callback on mouse double click: callback(coord,button,key)
 * @param [opt.clickLeft=null] {function}  - callback on mouse click left: callback(coord,button,key)
 * @param [opt.clickRight=null] {function()}  - callback on mouse click right.: callback(coord,button,key)
 * @param [opt.keyDown=null] {function}  - callback on key down : callback(key)
 * @param [opt.viewChange=null] {function}  - callback if map is panned or zoomed : callback(zoom,coordCenter)
 * @param [opt.loadTile=null] {function}  - callback when a tile is loaded : callback(z,x,y,url)
 *
 * @example
 * ```js
 * const hm = window.heremap;
 * 
 * hm.config({
 *    app_id: "YOUR APP_ID",
 *    app_code: "YOUR APP_CODE",
 * });
 *
 * hm.map("map", {
 *    zoom:5,
 *    center: [48.8,2.3],
 *    click: function(coord,button,key) {console.log("clicked on",coord,"with button",button);}
 * });
*  ```
*/
function map(htmlItem, opt) {

    _htmlItem = htmlItem;

    let settings = {
        zoom: 10,
        center: [48.86, 2.3],
        clickLeft: null,
        clickRight: null,
        keyDown: null, // keyboard event
        click: null,
        dbClick: null,
        viewChange: null, // (zoom,coord)
        loadTile: null // quand une tile est affiche
    };

    let mps = 1;

    let app_id = cm.getAppId();
    let app_code = cm.getAppCode();

    if (!app_id || !app_code) {
        // console.log("app_id/app_code not initialised");
        document.getElementById(htmlItem).innerHTML = "app_id/app_code not initialised";
        return;
    }

    _platform = new H.service.Platform({
        app_id: app_id,
        app_code: app_code,
        useCIT: cm.getCIT(),
        useHTTPS: cm.useHTTPS()
    });

    Object.assign(settings, opt);
    if (settings.scheme) _scheme = settings.scheme; // store scheme if defined

    _defaultLayers = _platform.createDefaultLayers();

    // http://heremaps.github.io/examples/explorer.html#map-tiles__base-map-styles-and-modes
    _provider = new H.map.provider.ImageTileProvider({
        label: "Base Provider",
        descr: "",
        min: 0,
        max: 20,
        crossOrigin: "anonymous",
        getURL: function (col, row, level) {
            mps++;
            if (mps > 4) mps = 1;
            let url = [cm.getProtocol(), "//", mps, ".base.maps" + cm.getCIT() + ".api.here.com/maptile/", "2.1",
                "/", "maptile", "/", "newest", "/",
                _scheme, "/", level, "/", col, "/", row, "/", "256",
                "/", "png", "?lg=", "FRE",
                "&app_code=", app_code, "&app_id=",
                app_id
            ].join("");

            if (_scheme == "japan")
                url = [cm.getProtocol(), "//", "m.lbs" + cm.getCIT() + ".api.heremaps.jp/v1/map?app_id=",
                    APP_ID_JAPAN,
                    "&app_code=",
                    APP_CODE_JAPAN,
                    "&tilematrix=EPSG:900913:",
                    level,
                    "&tilecol=",
                    col,
                    "&tilerow=",
                    row
                ].join("");

            else if (_scheme == "korea")
                url = [cm.getProtocol(), "//", "3.base.maps" + cm.getCIT() + ".api.heremaps.kr/maptile/2.1/maptile/34439348c3/normal.day/",
                    "/", level, "/", col, "/", row, "/", "256",
                    "/", "png", "?lg=", "FRE",
                    "&app_code=", APP_CODE_KOREA, "&app_id=",
                    APP_ID_KOREA
                ].join("");

            else if (_scheme == "black")
                url = cm.getHome() + "png/black.png";
            else if (_scheme == "white")
                url = cm.getHome() + "png/white.png";
            else if (_scheme == "transparent")
                url = cm.getHome() + "png/transparent.png";


            if (settings.loadTile)
                settings.loadTile(level, col, row, url);

            return url;
        }


    });

    let __layer = new H.map.layer.TileLayer(_provider);

    //console.log("normal map");
    //Step 2: initialize a HEREMap 
    _map = new H.Map(document.getElementById(htmlItem),
        __layer, {
            center: coordA2O(settings.center),
            zoom: settings.zoom
        });

    _behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(_map));

    // Create the default UI components
    _ui = H.ui.UI.createDefault(_map, _defaultLayers);

    // create default layer
    layerCreate("default");

    // if callback on zoom Change
    if (settings.viewChange) {
        _map.addEventListener("mapviewchangeend", function () {
            let bound = _map.getViewBounds();
            let lat = (bound.ka + bound.ja) / 2;
            let lng = (bound.ga + bound.ha) / 2;

            //console.log("viewChange center " + lat + " " + lng);
            settings.viewChange(_map.getZoom(), [lat, lng]);
        });
    }

    /***********************           to handle keyboard while mouse in map        ***********************/
    let kup = function () {
        _key.ctrl = false;
        _key.shift = false;
        _key.alt = false;
        _key.key = "";
    };

    let kdown = function (e) {
        _key.ctrl = ((e.key == "Control") || (e.keyIdentifier == "Control") || (e.ctrlKey == true));
        _key.shift = ((e.key == "Shift") || (e.keyIdentifier == "Shift") || (e.shiftKey == true));
        _key.alt = ((e.key == "Alt") || (e.keyIdentifier == "Alt") || (e.shiftKey == true));
        _key.key = e.key;
        if (settings.keyDown) settings.keyDown(_key);
    };

    _map.addEventListener("mouseenter", function () {
        // console.log("map mouse enter");
        document.addEventListener("keydown", kdown);
        document.addEventListener("keyup", kup);
    });

    _map.addEventListener("pointerenter", function () {
        //console.log("map pointer enter");
        document.addEventListener("keydown", kdown);
        document.addEventListener("keyup", kup);
    });
    _map.addEventListener("mouseleave", function () {
        // console.log("map mouse leave");
        document.removeEventListener("keydown", kdown);
        document.removeEventListener("keyup", kup);
    });

    /***********************           to handle double click         ***********************/
    _map.addEventListener("dbltap", function (ev) {
        let target = ev.target;
        if (target instanceof H.map.Marker) return; // don't do anything if click on marker

        let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
        let button = ev.currentPointer.button;
        if (settings.dbClick != "") {
            switch (button) {
                case 0:
                    settings.dbClick(coordO2A(coord), "left", _key);
                    break;
                case 2:
                    settings.dbClick(coordO2A(coord), "right", _key);
                    break;
            }
        }
    });

    /***********************           to handle simple click         ***********************/
    _map.addEventListener("tap", function (ev) {
        let target = ev.target;

        if (target instanceof H.map.Marker) return;

        let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
        let button = ev.currentPointer.button;

        if ((button == 0) && (settings.clickLeft))
            settings.clickLeft(coordO2A(coord), "left", _key);
        if ((button == 2) && (settings.clickRight))
            settings.clickRight(coordO2A(coord), "right", _key);
        if (settings.click) {
            switch (button) {
                case 0:
                    settings.click(coordO2A(coord), "left", _key);
                    break;
                case 2:
                    settings.click(coordO2A(coord), "right", _key);
                    break;
            }
        }
    });

    /*********  disable the default draggability of the underlying map when starting to drag a marker object *****************/
    _map.addEventListener("dragstart", function (ev) {
        let target = ev.target;
        if (target instanceof H.map.Marker) {
            _behavior.disable();
        }
    }, false);

    /************   re - enable the default draggability of the underlying map when dragging has completed ***********************/
    _map.addEventListener("dragend", function (ev) {
        let target = ev.target;
        if (target instanceof mapsjs.map.Marker) {
            _behavior.enable();
            if (typeof target.dragged !== "undefined") {
                let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
                (target.dragged)(target, coordO2A(coord));
            }
        }
    }, false);

    /***********************  Listen to the drag event and move the position of the marker as necessary *******************/
    _map.addEventListener("drag", function (ev) {
        let target = ev.target,
            pointer = ev.currentPointer;
        if (target instanceof mapsjs.map.Marker) {
            target.setPosition(_map.screenToGeo(pointer.viewportX, pointer.viewportY));
        }
    }, false);


    /****************  detect map resize and adjust accoridngly ******************************/
    window.addEventListener("resize", function () {
        _map.getViewPort().resize();

    });

    return _map;
}

/**
 * list of all available map styles normal.day, night.... 
 * @alias hm:getAvailableMapStyle
 * @return {json} list of map styles as json
 */
function getAvailableMapStyle() {
    // https://1.base.maps.api.here.com/maptile/2.1/info?xnlp=CL_JSMv3.0.17.0&app_id=nOSh21214JFMSEPQkqno&app_code=rX_l7YvALtNkqU2bx5FWEA&output=json

    const settings = cm.addCredentials({
        output: "json"
    });

    const url = cm.buildUrl("1.base.maps", "api.here.com/maptile/2.1/info");
    return cm.hereRest(url, settings)
        .then(res => {
            return res.body.response;
        });
}

/**
 * define the scheme. List of scheme can be obtained from {hm.getAvailableMapStyle()}
 * @alias hm:setScheme
 * @param {string} scheme scheme name
 */
function setScheme(scheme) {
    _scheme = scheme;
}

/**
 * create a layer
 * @alias hm:layerCreate
 * @param {string} name  - name of layer
 * @param {boolean} visible  - initial status
 * @example
 * ```js
 * hm.layerCreate("layer1");
 *  ```
 */
function layerCreate(name, visible) {
    group = new H.map.Group();
    group.name = name;
    _map.addObject(group);

    // push into list of layers
    _layers.push(group);

    // can be visible or hidden
    if (typeof visible != "undefined")
        group.setVisibility(visible);

    return group;
}

/**
 * delete a layer
 * @alias hm:layerDelete
 * @param {String} name name of layer
 */
function layerDelete(name) {
    let layer = layerFind(name);
    if (!layer)
        return;

    // remove group from map
    _map.removeObject(layer);
    //remove form list of layers
    _layers = _layers.filter(item => {
        return item.name !== name;
    });
}

/**
 * Empty a layer,
 * @alias hm:layerEmpty
 * @param {string} layer 
 */
function layerEmpty(name) {
    let layer = layerFind(name);
    if (!layer)
        return;
    layer.removeAll();
}

/**
 * create a layer
 * @alias hm:layerSetVisibility
 * @param {string} name  - name of layer
 * @param {boolean} visible  - visible or not
 * @example
 * ```js
 * hm.layerVisible("layer1",true);
 *  ```
 */
function layerSetVisibility(name, visible) {
    let layer = layerFind(name);
    if (!layer)
        return;

    layer.setVisibility(visible);

}

/**
 * find layer by its name or return null 
 * @alias hm:layerFind
 * @param {string} name 
 */
function layerFind(name) {
    let l = _layers.find(layer => {
        return layer.name == name;
    });
    if (typeof l == "undefined") return null;
    return l;
}


/**
 * set center of the map
 * @alias hm:setCenter
 * @param {Array} - coord as [lat,lng]
 * * @example
 * ```js
 * hm.setCenter([48.8,2.3]);
 *  ```
 */
function setCenter(coord) {
    _map.setCenter(coordA2O(coord));
}

/**
 * return coordinate of the center of the map
 * @alias hm:getCenter
 * @returns {coord} coord of the center as \[lat,lng\]
 */
function getCenter() {
    let bound = _map.getViewBounds();
    //_HM.log("viewbound",bound);

    let lng = (bound.ga + bound.ha) / 2;
    let lat = (bound.ka + bound.ja) / 2;
    return [lat, lng];

}

/**
 * return bounding box of visible part of map
 * @alias hm:getViewBB
 * @returns {Object} bouding box of visible part of the map, as \[latm,latM,longm,lngM\]
 */
function getViewBB() {
    let bb = _map.getViewBounds();

    let bb2 = {
        latm: bb.ja,
        latM: bb.ka,
        lngm: bb.ga,
        lngM: bb.ha
    };
    return bb2;
}

/**
 * sets bouding box to be displayed
 * @alias hm:setViewBB
 * @param opt {Object| string}  either an object specifying how to set bounding box, or  a String being the name of a layer
 * @param [opt.layer] {string} bouding box aroud all objects of the layer
 * @param [opt.pois] {array} bouding box aroud all coords defined as \[coord,coord...\]
 * @example
 * ```js
 * hm.setViewBB("layer1");
 *
 * hm.setViewBB({
 *    pois: coords
 * });
 *  ```
 */
function setViewBB(opt) {

    if (typeof opt == "string")
        opt = {
            layer: opt
        };

    let settings = {
        layer: null,
        pois: null // array of [lat,lng]
    };
    Object.assign(settings, opt);

    let bbox;

    //set BB based on layer
    if (settings.layer) {
        let layer = layerFind(settings.layer);
        if (!layer) return;

        // get view bound and add a bit around, like 1/5
        let bb = layer.getBounds();
        if (!bb) // as if nothing in layer
            return;
        bb.latm = bb.ja;
        bb.latM = bb.ka;
        bb.lngm = bb.ga;
        bb.lngM = bb.ha;
        let dx = bb.lngM - bb.lngm;
        let dy = bb.latM - bb.latm;
        dx = dx / 5;
        dy = dy / 5;
        bb.latM += dy;
        bb.lngm -= dx;
        bb.latm -= dy;
        bb.lngM += dx;
        bbox = new H.geo.Rect(bb.latM, bb.lngm, bb.latm, bb.lngM);
        _map.setViewBounds(bbox, true);

    } else if (settings.pois) {
        let bb = {
            latM: 0,
            lngm: 180,
            latm: 90,
            lngM: -180,
        };
        let arr = settings.pois;
        arr.forEach((poi) => {
            if (poi[0] > bb.latM) bb.latM = poi[0];
            if (poi[1] > bb.lngM) bb.lngM = poi[1];
            if (poi[0] < bb.latm) bb.latm = poi[0];
            if (poi[1] < bb.lngm) bb.lngm = poi[1];
        });
        bbox = new H.geo.Rect(bb.latM, bb.lngm, bb.latm, bb.lngM);
        _map.setViewBounds(bbox, true);
    }
}


/**
 * return zoom value
 * @alias hm:getZoom
 * @returns {number} zoom level
 */
function getZoom() {
    return _map.getZoom();
}

/**
 * set zoom level
 * @alias hm:setZoom
 * @param {number} zoom 
 */
function setZoom(zoom) {
    _map.setZoom(zoom);
}



/**
 * create an icon, to be used for a marker
 * @async
 * @alias hm:buildIcon
 * @param opt {object} options to specify the icon
 * @param [opt.img] {string}  use a png/jpg image. Specify the url 
 * @param [opt.svg] {string}  url a svg. This can be an inline svg, a url, or a svg from heremap
 * @param [opt.opt] {object}   style object
 * @param [opt.opt.size] {number|string}   size of icon, as 24 or 24x32
 * @param [opt.opt.ratio] {number}   for svg files, ratio of size. 0.5 = half
 * @param [opt.opt.anchor] {number|string}   anchor of icon, as 24 or "24x32" or "center". By default, bottom-center
 * @param [opt.opt.tag] {string}   for svg, any tag like{tag}. will be replaced by associated value
 * @return {H.map.Icon} the created icon
 * @example 
 * ```js
 * hm.buildIcon({
 *    img: "http://whatever.com/image.png",
 *    opt: {size:24}
 * });
 * 
 * hm.buildIcon({
 *    svg: "http://whatever.com/image.svg",
 *    opt: {
 *       ratio:0.5,
 *       anchor:24x32
 *    }
 * });
 *  
 * hm.buildIcon({
 *    svg: "svg/cluster.svg",
 *    opt: {
 *       size:24,
 *       color:"red"
 *    }
 * });
 * 
 * const svg = `<svg width="16" height="16" xmlns="http://www.w3.org/2000/svg"> <ellipse stroke="null" ry="8" rx="7.618896" id="svg_1" cy="8" cx="7.837427" fill="{color}" fill-opacity="0.9"/></svg>`;
 * hm.buildIcon({
 *    svg: svg,
 *    opt: {
 *       size:24,
 *       color:"red"
 *    } 
 * });
 *  ```
 */
async function buildIcon(opt) {
    let settings = {
        img: null, //   png, jpg. if not http in the beginning, look locally
        svg: null, // svg file:  is a url or a string
        opt: null, // size, color, anchor, text...s
    };

    Object.assign(settings, opt);

    if (!settings.img && !settings.svg) {
        return null;
    }

    let icon, iconSrc;

    if (settings.img) {
        // console.log("settings.img", settings.img);

        if (settings.img[0] == "@") // to indicate local
            iconSrc = cm.getHome() + settings.img.substr(1);
        else
            iconSrc = settings.img; // local file

    } else if (settings.svg) {

        let url = null;
        iconSrc = settings.svg;
        if (settings.svg[0] == "@") // local 
            url = cm.getHome() + settings.svg.substr(1);
        else if (settings.svg.substr(0, 4) == "<svg") // url
            url = null;
        else
            url = settings.svg; // not embedded string, should be a url

        if (url) // an url to download
            iconSrc = await fetch(url)
                .then(res => {
                    if (res.status != 200)
                        return null;
                    return res.text();
                });
    }

    let iconOpt = {
        crossOrigin: true
    }; // to avoid issued with capture
    if (settings.opt && settings.opt.size) {
        let w, h;
        if (typeof settings.opt.size == "number")
            w = h = settings.opt.size;
        else
            [w, h] = settings.opt.size.split("x");

        iconOpt.size = {
            w: w,
            h: h
        };
    }

    function _getsizeSvg(iconSrc) {
        let w = null,
            h = null,
            match;
        let r = /width="(\d+)"/;
        match = iconSrc.match(r);
        if (match) w = match[1];

        r = /height="(\d+)"/;
        match = iconSrc.match(r);
        if (match) h = match[1];
        return [w, h];
    }

    if (settings.svg && settings.opt && settings.opt.ratio) {
        let w = null,
            h = null;
        [w, h] = _getsizeSvg(iconSrc);

        iconOpt.size = {
            w: Math.floor(w * settings.opt.ratio),
            h: Math.floor(h * settings.opt.ratio)
        };
    }

    if (settings.opt && settings.opt.anchor) {
        let x = null,
            y = null;
        if (typeof settings.opt.anchor == "number")
            x = y = settings.opt.anchor;
        else if (settings.opt.anchor == "center" && settings.svg) { // for svg file only center: get size of split in 2
            [x, y] = _getsizeSvg(iconSrc);
            x /= 2;
            y /= 2;
        } else
            [x, y] = settings.opt.anchor.split("x");

        if (!x || !y) {
            let e = new Error("BuildIcon: incorrect anchor"); // e.message
            throw (e);
        }
        iconOpt.anchor = {
            x: x,
            y: y
        };
    }

    // all other fields are treated as graphic enhanceent
    if (settings.opt) {
        for (let name in settings.opt) {
            if (name == "file" || name == "size" || name == "anchor") continue;
            let re = new RegExp("{" + name + "}", "g");
            iconSrc = iconSrc.replace(re, settings.opt[name]);
        }
    }

    // console.log("iconSrc", iconSrc);
    // console.log("iconOpt", iconOpt);
    icon = new H.map.Icon(iconSrc, iconOpt);

    return icon;

} //end of icon





/**
 * add a marker in a layer
 * svg files can be created with https://editor.method.ac/ 
 * @async
 * @alias hm:marker
 * @param opt {object} options to create the marker, can be a coord directly
 * @param [opt.layer] {string}   layer name
 * @param [opt.coord] {coord}   coord of the marker as \[lat,lng\]
 * @param [opt.icon] {string}   created from hm.buildIcon
 * @param [opt.svg] {string}   see hm.buildIcon
 * @param [opt.opt] {Object}   see hm.buildIcon
 * @param {function} opt.pointerenter  if enter, callback(target,coord,ev)
 * @param {function} opt.pointerClick  if click, callback(target,coord,ev)
 * @param {string} opt.data  optional data
 * @param {boolean} opt.bubble  if true, show buble on click with data
 * @param {boolean} opt.draggable  draggable marker
 * @param {function} opt.dragged  if dragged, callback(target,coord)
 * @example 
 * ```js
 * hm.marker([48.8,2.3]);
 *
 * hm.marker({
 *    coord: [48.8,2.3],
 * });
 * 
 * hm.marker({
 *   svg: "svg/marker.svg",
 *   color:"red",
 *   ratio:0.5
 * });
 * 
 * hm.marker({
 *    img: "http://whatever.com/image.png",
 *    coord: [48.8,2.3]
 * });
 * 
 * hm.marker({
 *    coord: [48.8,2.3],
 *    data:"Hello world",
 *    bubble: true
 * });
 * 
 * hm.marker({
 *    coord: [48.8,2.3],
 *    draggable:true,
 *    dragged: function(target,coord) {console.log("dragged to",coord);}
 * });
 *  ```
 */
async function marker(opt) {
    let settings = {
        layer: "default", //  layer in which to add marker
        coord: null, //  coord of the marker
        img: null, //  image can be url, png, jpg..
        svg: null, // svg file
        icon: null, // icon previously created
        opt: {}, // opt for icon
        pointerEnter: null, //  callback(target,coord,ev)
        pointerClick: null, //  callback(target,coord,ev)
        data: null, //  user data
        bubble: false, //  show a bubble with user data
        draggable: false, //  icon is draggalbe
        dragged: null //  callback(target,coord)
    };

    // can pass directly only the coord
    if (Array.isArray(opt))
        opt.coord = opt;

    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    settings.coord = {
        lat: settings.coord[0],
        lng: settings.coord[1]
    };

    // these parameters can be in opt.opt or directly in opt
    if (settings.color) settings.opt.color = settings.color;
    if (settings.size) settings.opt.size = settings.size;
    if (settings.ratio) settings.opt.ratio = settings.ratio;
    if (settings.anchor) settings.opt.anchor = settings.anchor;

    let markerOpt = null;
    if (settings.img || settings.svg) {
        let icon = await buildIcon(settings);
        markerOpt = {
            icon: icon
        };
    } else if (settings.icon) {
        markerOpt = {
            icon: settings.icon
        };
    }

    //console.log("marker settings.coord", settings.coord);
    let marker = new H.map.Marker(settings.coord, markerOpt);

    marker.draggable = settings.draggable;

    if (settings.dragged) marker.dragged = settings.dragged;

    if (settings.data) {
        let data = settings.data;
        if (settings.data == "__OPT__") {
            data = settings;
            delete data.coord;
            for (let p in data)
                if (!data[p]) delete data[p];
            data = JSON.stringify(data, null, 2).replace(/\n/g, "<br/>");
        }
        marker.setData(data);
    }

    // get click from mouse
    if (settings.pointerEnter) {
        marker.addEventListener("pointerenter", function (ev) {

            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, coordO2A(coord), ev);

        });
    }

    /************  callback when click on marker *****************************/
    if (settings.pointerClick) {
        marker.addEventListener("tap", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, coordO2A(coord), ev);

        });
    }

    /************  show a bubble when clicking on marker *****************************/
    if (settings.bubble) {
        marker.addEventListener("tap", function (ev) {

            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);

            bubbleUnique(coordO2A(coord), data);
        });
    }

    layer.addObject(marker);
    return marker;

} //end of marker

/**
 * display a unique bubble. Associated CSS style is .H_ib_body
 * @alias hm:bubbleUnique
 * @param {Array} coord of the bubble
 * @param {String} txt html text to display
 */
function bubbleUnique(coord, txt) {

    if (!_bubbleMarker) {
        _bubbleMarker = new H.ui.InfoBubble(
            coordA2O(coord), {
                content: txt
            });

        _ui.addBubble(_bubbleMarker);
        _bubbleMarker.addClass("bubbleUnique");

    } else {
        _bubbleMarker.setPosition(coordA2O(coord));
        _bubbleMarker.setContent(txt);
        _bubbleMarker.open();
    }

}


/**
 * hide a unique bubble
 * @alias hm:bubbleUniqueHide
 */
function bubbleUniqueHide() {
    if (!_bubbleMarker)
        return;
    _bubbleMarker.close();
}




/**
 * Draw a polyline. 
 * @alias hm:polyline
 * @param opt {object}   options to draw polyline
 * @param [opt.layer] {String} optional layer to use 
 * @param [opt.coords] {array} array of coords, as \[\[48.8,2.3\],\[48.85,2.4\],... \]
 * @param [opt.style] {object} optional graphic style
 * @param [opt.lineWidth=4] {number} line width
 * @param [opt.style.strokeColor=rgba(0, 128, 255, 0.7)] {string} line color
 * @param [opt.arrows] {object} optional arrow
 * @param [opt.data] {String} optional user data
 * @param [opt.pointerClick] {function} optional callback if click on line. format callback(target,coord,event)
 * @param [opt.pointerenter] {function} optional callback if mouse enters on line. format callback(target,coord,event)
 * @param [opt.pointerLeave] {function} optional callback if mouse leaves the line. format callback(target,coord,event)
 * @param [opt.z] {number} optional z level
 * ```js
 * hm.polyline({
 *    coords: [[48.8,2.3],[48.85,2.4],[48.9,2.6]],
 *    layer:"layer1"
 * });
 * 
 * hm.polyline({
 *    coords: coords,
 *    style: {
 *        lineWidth: 4,
 *        strokeColor: "red"
 *    },
 * });
 * 
 * hm.polyline({
 *    coords: coords,
 *    data:"Hello World",
 * });
 *  ```
 */
function polyline(opt) {
    let settings = {
        layer: "default",
        coords: null, // coords is list of array of [lat,lng] or array of object with {lat:,lng:}
        style: {
            lineWidth: 4,
            strokeColor: "rgba(0, 128, 255, 0.7)"
        },
        arrows: null,
        data: null, // optional user data 
        z: null,
        pointerClick: null, // click
        pointerEnter: null, // call back
        pointerLeave: null // call back
    };

    if (Array.isArray(opt)) // directement les coord
        opt = {
            coords: opt
        };

    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    if (!settings.coords) {
        let e = new Error("Polyline: coords not found:"); // e.message
        throw (e);
    }

    let strip = new H.geo.Strip();

    settings.coords.forEach(function (point) {
        strip.pushLatLngAlt(point[0], point[1]);
    });

    let polyline = new H.map.Polyline(strip, {
        style: settings.style,
        data: settings.data,
        arrows: settings.arrows
    });

    // Z index
    if (settings.z) polyline.setZIndex(settings.z);
    // user data
    if (settings.data) polyline.setData(settings.data);

    if (settings.pointerEnter)
        polyline.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, coordO2A(coord), ev);
        });
    if (settings.pointerLeave)
        polyline.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerLeave(target, coordO2A(coord), ev);
        });
    if (settings.pointerClick)
        polyline.addEventListener("tap", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, coordO2A(coord), ev);
        });

    layer.addObject(polyline);

    return polyline;
}


/**
 * Draw a polygon
 * @alias hm:polygon
 * @param {Object} opt  options to draw a polygon. Same options as hm.polyline
 */
function polygon(opt) {
    let settings = {
        layer: "default",
        coords: "", // coords is array of [lat,lng] or array of {lat:,lng:}
        style: {
            lineWidth: 4,
            strokeColor: "rgba(0, 128, 255, 0.7)",
            fillColor: "rgba(0, 128, 255, 0.7)"
        },
        styleHover: null, // style si mouse over
        arrows: null,
        data: null, // additional data to carry
        z: null,
        pointerClick: null, // click
        pointerEnter: null, // call back
        pointerLeave: null // call back
    };
    if (Array.isArray(opt)) // directement les coord
        opt = {
            coords: opt
        };
    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    if (!settings.coords) {
        let e = new Error("Polyline: coords not found:"); // e.message
        throw (e);
    }

    let strip = new H.geo.Strip();
    settings.coords.forEach(function (point) {
        strip.pushLatLngAlt(point[0], point[1]);
    });

    let polygon = new H.map.Polygon(strip, {
        style: settings.style,
        data: settings.data,
        arrows: settings.arrows
    });

    if (settings.data) polygon.setData(settings.data);
    // Z index
    if (settings.z) polyline.setZIndex(settings.z);

    // si un style de hover
    if (settings.styleHover) {
        polygon.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            target.setStyle(settings.styleHover);
        });
        polygon.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            target.setStyle(settings.style);
        });
    }

    if (settings.pointerEnter)
        polygon.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, coordO2A(coord), ev, data);
        });
    if (settings.pointerLeave)
        polygon.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerLeave(target, coordO2A(coord), ev, data);
        });
    if (settings.pointerClick)
        polygon.addEventListener("tap", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, coordO2A(coord), ev, data);
        });

    layer.addObject(polygon);

    return polygon;
} // end of polygon

/**
 * draw a circle
 * @alias hm:circle
 * @param opt {*}   option for circle
 * @param [opt.layer] {String} optional layer to use 
 * @param [opt.coord] {array} center of the circle, as \[48.8,2.3\]
 * @param [opt.radius] {number} radius in meter
 * @param [opt.style] {object} optional graphic style
 * @param [opt.style.strokeColor] {string} color of perimeter
 * @param [opt.style.lineWidth] {number} line width
 * @param [opt.style.fillColor] {string} fill color
 */
function circle(opt) {
    let settings = {
        layer: "default",
        coord: null,
        radius: 100, // meters
        style: {
            strokeColor: "rgba(55, 85, 170, 0.2)", // Color of the perimeter
            lineWidth: 2,
            fillColor: "rgba(0, 128, 0, 0.1)" // Color of the circle
        }

    };
    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }
    let circle = new H.map.Circle(
        // The central point of the circle
        coordA2O(settings.coord),
        // The radius of the circle in meters
        settings.radius, {
            style: settings.style
        }
    );

    layer.addObject(circle);
    return circle;
}




/**
 * watch position on HTML5 position. requires HTTPS
 * @async
 * @alias hm:locateMe
 * @param callback {function}  callback when coord changes. Format: callback(coord,accuracy) 
 * @param opt {Object} optional graphic options
 * @param [opt.position] {object}  graphic options for center. See buildIcon
 * @param [opt.position.svg] {string}  svg file
 * @param [opt.position.color] {string}  color for  {color} tag
 * @param [opt.position.size] {number}  size of icon
 * @param [opt.position.anchor] {number}  anchor of icon
 * @param [opt.accuracy] {object}  graphic options for accuracy representation
 * @param [opt.accuracy.strokeColor] {String}  color of circle line representing accuracy area
 * @param [opt.accuracy.lineWidth] {number}  width of line of circle
 * @param [opt.accuracy.fillColor] {String}  fill color of circle representing accuracy area
 */
async function locateMe(callback, opt) {

    // if no callback, remove the watch
    if (navigator.geolocation) {
        if (!callback && _locateMe) {
            navigator.geolocation.clearWatch(_locateMe);
            _locateMe = null;
            return;
        }

        let settings = {
            position: {
                svg: "svg/target.svg",
                color: "black",
                anchor: "center"
            },
            accuracy: {
                strokeColor: "rgba(0, 128, 0, 0.8)", // Color of the perimeter
                lineWidth: 2,
                fillColor: "rgba(0, 128, 0, 0.4)" // Color of the circle
            }
        };
        Object.assign(settings, opt);

        let iconCrossHair = await buildIcon({
            svg: settings.position.svg,
            img: settings.position.img,
            opt: settings.position
        });


        //navigator.geolocation.getCurrentPosition(function pos(position) {
        _locateMe = navigator.geolocation.watchPosition((position) => {
            let gps = [position.coords.latitude, position.coords.longitude];

            layerEmpty("_gps");

            /* circle showing the accuracy radius*/
            circle({
                layer: "_gps",
                coord: gps,
                radius: position.coords.accuracy,
                style: settings.accuracy
            });

            marker({
                layer: "_gps",
                coord: gps,
                icon: iconCrossHair
            });

            callback(gps, position.coords.accuracy);
        }, (error) => {
            let msg = "";
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    msg += "User denied the request for Geolocation.";
                    break;
                case error.POSITION_UNAVAILABLE:
                    msg += "Location information is unavailable.";
                    break;
                case error.TIMEOUT:
                    msg += "timed out.";
                    break;
                case error.UNKNOWN_ERROR:
                    msg += "An unknown error occurred.";
                    break;
            }
            let e = new Error("HTML5 location error:" + msg); // e.message
            throw (e);
        }, {
            enableHighAccuracy: true
        });
    } else {
        let e = new Error("no HTML5 geolocation capabilities"); // e.message
        throw (e);
    }
}


/**
 * perform a screenshot of the map and returns a promise with the data
 * @async
 * @alias hm:screenshot
 * @param opt {object} options for screenshot
 * @param [opt.name] {string} filename for download
 * @param [opt.ui] {boolean} true to ui (scale, etc..) in screenshot
 * @param opt {object} options for screenshot
 * 
 * @returns {data} binary data of image
 * 
 */
function screenshot(opt) {
    let para = null;
    if (opt && opt.ui)
        para = [_ui];
    return new Promise(
        (resolve, reject) => {
            _map.capture(function (canvas) {
                if (!canvas)
                    return reject("Map screenshot not supported");

                let dataURL = canvas.toDataURL();
                if (opt && opt.name) {
                    let a = document.createElement("a");
                    a.href = dataURL;
                    a.target = "_blank";
                    a.download = opt.name;
                    document.body.appendChild(a);
                    a.click();
                }
                resolve(dataURL);
            }, para);
        });
}


function getMapHtmlItem() {
    return _htmlItem;
}

function getMap() {
    return _map;
}

function getBehavior() {
    return _behavior;
}


function getUI() {
    return _ui;
}

module.exports = {
    coordO2A: coordO2A,
    coordA2O: coordA2O,
    getMap: getMap,
    getUI: getUI,
    getBehavior: getBehavior,
    getMapHtmlItem: getMapHtmlItem,
    map: map,
    getAvailableMapStyle: getAvailableMapStyle,
    setScheme: setScheme,
    layerCreate: layerCreate,
    layerFind: layerFind,
    layerDelete: layerDelete,
    layerSetVisibility: layerSetVisibility,
    layerEmpty: layerEmpty,
    buildIcon: buildIcon,
    bubbleUnique: bubbleUnique,
    bubbleUniqueHide: bubbleUniqueHide,
    marker: marker,
    circle: circle,
    polyline: polyline,
    polygon: polygon,
    getCenter: getCenter,
    setCenter: setCenter,
    getZoom: getZoom,
    setZoom: setZoom,
    getViewBB: getViewBB,
    setViewBB: setViewBB,
    locateMe: locateMe,
    screenshot: screenshot

};
},{"./common.js":11}],15:[function(require,module,exports){
"use strict";
const cm = require("common");


/**
 * Place AutoSuggest
 * @ async
 * @alias hm:placeAutoSuggest
 * @param opt {Object} options of autosuggest
 * @param opt.search {String} search string
 * @param opt.center {Coord} center search around this coord
 * @return  {Promise} Array of {res,title,value,coord}
 */
function placeAutoSuggest(opt) {

    const params = cm.addCredentials({
        at: opt.center[0] + "," + opt.center[1],
        q: opt.search
    });

    const url = cm.buildUrl("places", "api.here.com/places/v1/autosuggest");
    return cm.hereRest(url, params, "get", false)
        .then(res => {
            let places = res.body.results.filter(place => place.vicinity); // keep only if vicinity field is present

            return places.map(place => {
                return {
                    title: place.title,
                    //value: place.title + ', ' + place.vicinity.replace(/<br\/>/g, ", ") + ' (' + place.category + ')',
                    value: place.title + ", " + place.vicinity.replace(/<br\/>/g, ", "),
                    coord: place.position,
                    res: place,
                };
            });
        });
}


module.exports = {
    placeAutoSuggest: placeAutoSuggest
};

},{"common":11}],16:[function(require,module,exports){
"use strict";
const cm = require("./common.js");

/**
 * compute a route with optional waypooints. [See more info on optional parameters](http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
 * @alias hm:route
 * @param {object} source - source as \[lat,lng\]. Can be array of \[lat,lng\] to define waypoints
 * @param {object} dest - dest as \[lat,lng\]. Can be array of \[lat,lng\] to define waypoints
 * @param opt {object} route options 
 * @param [opt.mode=fastest;car;traffic:disabled] {string}  routing mode
 * @param [opt.routeattributes=waypoints,summary,shape] {string}  route attributes
 * @param [opt.maneuverattributes=direction,action] {string}  manoeuver attributes
 * @returns {Promise} returns { summary: object, coords:array,route: object, body:object}. coords is array of coord, to be used with hm.polyline. 
 *
 * @example
  * ```js
  * const res = await hm.route([48.8,2.3],[48.7,2.5]);
  * console.log (res.summary);
  * 
  * const res = await hm.route([[48.8,2.3],[48.9,2.7]], [49.3,2.5]);
  * console.log (res.route); 
  * 
  * const res = await hm.route([48.8,2.3], [[48.9,2.7], [49.3,2.5]]);
  * console.log (res.summary); 
  * ```
 */
function route(source, dest, opt) {

    const settings = {
        mode: "fastest;car;traffic:disabled",
        representation: "linkPaging",
        routeattributes: "waypoints,summary,shape",
        maneuverattributes: "direction,action"
    };

    const params = cm.addCredentials(settings, opt);

    // 1 seul source ou array de source ?
    let id = 0;
    if (Array.isArray(source[0]))
        for (var i = 0; i < source.length; i++) {
            let coord = source[i];
            params["waypoint" + id++] = coord[0] + "," + coord[1];
        }
    else
        params["waypoint" + id++] = source[0] + "," + source[1];

    if (Array.isArray(dest[0]))

        for (let i = 0; i < dest.length; i++) {
            let coord = dest[i];
            params["waypoint" + id++] = coord[0] + "," + coord[1];
        }
    else
        params["waypoint" + id++] = dest[0] + "," + dest[1];

    const url = cm.buildUrl("route", "api.here.com/routing/7.2/calculateroute.json");
    return cm.hereRest(url, params, "post")
        .then(res => {

            const route = res.body.response.route[0];
            const summary = route.summary;
            const coords = route.shape.map((latlng => latlng.split(",")));

            return { summary: summary, coords: coords, route: route, body: res.body };

        });

}


/**
 * compute an isoline. [See more info on optional parameters](http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
  * @alias hm:isoline
 * @param opt {object} option for isoline
 * @param [opt.start] {coord} coord for starting point of isoline
 * @param [opt.destination] {coord} coord for destination point of isoline
 * @param [opt.rangeType="time"] {string} time or distance
 * @param [opt.range] {number} range in seconds or in meters
 * @param [opt.mode="fastest;car;traffic:disabled"] {String} routing mode
 * @param [opt.linkattributes=sh] {String} attributes to be returned
 * 
 * @returns {Promise}  returns { poly:array, body:object }. Poly is array of coords, body is full answer
 */
function isoline(opt) {

    const settings = {
        start: null,                            // for direct isoline
        destination: null,                      // for reverse isoline
        rangeType: "time",                      // time or distance
        range: null,                            // in seconds or meters
        linkattributes: "sh",                   // to get the shape
        mode: "fastest;car;traffic:disabled",   //shortest;car;traffic:disabled 
    };
    const params = cm.addCredentials(settings, opt);

    if (params.start)
        params.start = "geo!" + params.start[0] + "," + params.start[1];
    if (params.destination)
        params.destination = "geo!" + params.destination[0] + "," + params.destination[1];

    if (!params.start && !params.destination) {
        let e = new Error("Isoline routing : missing start or destination"); // e.message
        throw (e);
    }
    if (!params.range) {
        let e = new Error("Isoline routing : missing range"); // e.message
        throw (e);
    }

    const url = cm.buildUrl("isoline.route", "api.here.com/routing/7.2/calculateisoline.json");
    return cm.hereRest(url, params, "post")
        .then(res => {

            // array of lat,lng, to be transformed into array of [lat,lng]
            const shape = res.body.response.isoline[0].component[0].shape;
            const poly = shape.map(point => point.split(","));

            return { poly: poly, body: res.body };
        });

}


/**
 * compute a matrix. [See more info on optional parameters](http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
 * 
 * Matrix size is limited to 1x100, 100x1 or 15xN
  * @alias hm:matrix
 * @param source {object} source as \[lat,lng\]. Can be array of \[lat,lng\]
 * @param dest {object} dest as \[lat,lng\]. Can be array of \[lat,lng\]
 * @param opt {object} additional optional parameters like  mode, summaryAttributes
 * @param [opt.mode="fastest;car;traffic:enabled"] {string} routing mode to compute matrix
 * @param [opt.summaryAttributes="tt,di"] {string} attributes in the answer
 * 
 * @returns {Promise} { entries: object, body:object }. entries is the array of {start,stop} information. body is full json answer
 * @example
 * ```js
 * const res = await hm.matrix({
 *      source:[48.8,2.3]
 *      dest:[[48.7,2.5],[48.1,2.0],[44.2,2.3]]
 * });
 * console.log (res.entries); 
 * ```
 */

function matrix(source, dest, opt) {

    var settings = {
        mode: "fastest;car;traffic:enabled",
        summaryAttributes: "tt,di"
    };
    const params = cm.addCredentials(settings, opt);

    if (!Array.isArray(source[0])) // if only one coord
        source = [source];
    source.forEach((coord, i) => {
        params["start" + i] = coord[0] + "," + coord[1];
    });

    if (!Array.isArray(dest[0])) // if only one coord
        dest = [dest];
    dest.forEach((coord, i) => {
        params["destination" + i] = coord[0] + "," + coord[1];
    });

    const url = cm.buildUrl("matrix.route", "api.here.com/routing/7.2/calculatematrix.json");
    return cm.hereRest(url, params, "post")
        .then(res => {
            return { entries: res.body.response.matrixEntry, body: res.body };
        });


}



/**
 * Compute the detour for each waypoint provided, compared to normal route from A to B
 * 
 * @async
 * @alias hm:detour
 * @param start {coord}  starting point for route
 * @param stop {coord}   destination point of route
 * @param waypoints {array}  list of watypoints to test 
 * @returns {Promise} returns {reference: {start, stop, distance, distance2, time, time2} ,waypoints:[ {coord, distA, timeA, distB, timeB}]}
 */
async function detour(start, stop, waypoints) {
    // eslint-disable-next-line   no-undef
    return new Promise(
        async (resolve, reject) => {
            //let tStart = new Date();

            if (!start) return reject("missing start point");
            if (!stop) return reject("missing stop point");
            if (!waypoints) return reject("missing waypoints");
            if (!Array.isArray) return reject("waypoints should be an array");


            // initialise le resultat 
            let res = {
                reference: {},
                waypoints: []
            };

            // calcul les coords nonPostGres, creer l'array de coord des waypoints.
            let dest = [stop]; // so we have a distance/time reference, not same as from routing 1:1
            waypoints.forEach(waypoint => {
                dest.push(waypoint);
                res.waypoints.push(
                    { coord: waypoint }
                );
            });
            // inspect(dest, "dest from detour")

            // compute start to all waypoint, 1st waypoint is stop to get a reference
            let p1 = matrix(start, dest, { mode: "fastest;car;traffic:disabled" });

            // compute from all waypoint to stop, 1st waypoint is start to get another reference
            dest[0] = start;
            let p2 = matrix(dest, stop, { mode: "fastest;car;traffic:disabled" });
            // wait for both matrix to complete

            // eslint-disable-next-line   no-undef
            const result = await Promise.all([p1, p2]);

            // process first part: start => N waypoints
            let entries = result[0].entries;
            // first entry is start stop
            let dist = entries[0].summary.distance;
            let time = entries[0].summary.travelTime;
            res.reference.start = start;
            res.reference.stop = stop;
            res.reference.distance = dist;
            res.reference.time = time; // the reference sans waypoint

            entries.forEach((entry, i) => {
                if (i == 0) return; // skip the first which is start stop

                if (entry.status == "failed") {
                    //console.log(entry, "error on matrixA" + i);
                    //console.log(start, "associated start");
                    //console.log(dest[i], "associated dest" + i);
                    return;
                }

                let id = entry.destinationIndex;
                let dist = entry.summary.distance;
                let time = entry.summary.travelTime;
                res.waypoints[id - 1].distA = dist;
                res.waypoints[id - 1].timeA = time;
            });


            // process second part: N waypoints => stop
            entries = result[1].entries;
            //inspect(entries[0], "matrixB0");

            res.reference.distance2 = entries[0].summary.distance;
            res.reference.time2 = entries[0].summary.travelTime;

            entries.forEach((entry, i) => {
                if (i == 0) return; // skip the first which is start stop

                if (entry.status == "failed") {
                    //console.log(entry, "error on matrixB" + i);
                    //console.log(entry, "associated start" + i);
                    //console.log(stop, "associated stop");
                    return;
                }
                let id = entry.startIndex;
                let dist = entry.summary.distance;
                let time = entry.summary.travelTime;
                res.waypoints[id - 1].distB = dist;
                res.waypoints[id - 1].timeB = time;
            });
            return resolve(res);
        });

}


module.exports = {
    matrix: matrix,
    route: route,
    isoline: isoline,
    detour: detour
};


},{"./common.js":11}],17:[function(require,module,exports){
/* global document,H */
"use strict";
const hm = require("./map.js");
const simplify = require("simplify-js");


let _touchOffset = null;
let _touchCoords = null;
let _touchPolyline = null;
let _touchLayer = null;
let _touchCallback = null;
let _map = null;
let _behavior = null;

let _behaviorEnable = true;
function behaviorEnable(onoff) {
    if (_behaviorEnable && !onoff) {
        _behavior.disable();
        //console.log("behavior disabled");
        _behaviorEnable = false;
    }
    if (!_behaviorEnable && onoff) {
        _behavior.enable();
        //console.log("behavior enabled");
        _behaviorEnable = true;
    }
}
/**
 * activate touch, allowing hand drawing, with embedded simplification of the line
 * @alias hm:touch
 * @param onoff {boolean}  activate or deactivate
 * @param options {object} options  to control the touch behaviour
 * @param [options.callback] {function} calling callback(coords) when touch ends
 * @param [options.layer] {string} layer where to put the drawing
 * @param [options.style] {object} drawing style for the line
 * @param [options.arrow] {object} arrow style for the line
 * @param [options.tolerance=4] {number} tolerance for simplification
 * @param [options.keep=false] {boolean} keep graphic or not when calling callback
 */
function touch(onoff, options) {

    _map = hm.getMap();
    _behavior = hm.getBehavior();
    let elmt = document.getElementById(hm.getMapHtmlItem());

    let bb = elmt.getBoundingClientRect();
    _touchOffset = { left: bb.x, top: bb.y }; // offset of window to browser

    const settings = {
        callback: null,
        layer: "_touch",
        keep: false,
        style: { lineWidth: 5, strokeColor: "rgba(255, 0, 0, 0.7)" },
        arrows: { fillColor: "white", frequency: 5, width: 1, length: 2 },
        tolerance: 4, // level of simplification
    };

    Object.assign(settings, options);

    _touchLayer = hm.layerFind(settings.layer);
    if (!_touchLayer) {
        _touchLayer = hm.layerCreate(settings.layer);
        //_touchLayer = hm.layerFind(settings.layer);
    }

    // callback des event Listener
    // defini seulement sur onoff, pour ne pas creer une autre fois la fonction
    if (onoff)
        _touchCallback = function (e) {

            let touchobj = e.changedTouches[0]; // reference first touch point (ie: first finger)

            // if ((e.touches.length >= 2 && e.targetTouches.length >= 2)) {
            if ((e.touches.length >= 2)) {
                //    console.log("touch.length", e.touches.length);
                behaviorEnable(true);
                return;
            }

            if (e.type == "touchmove")
                behaviorEnable(false);

            // e.preventDefault();
            //console.log("e.type", e.type);
            let simplified;

            switch (e.type) {
                case "touchstart":
                    _touchCoords = []; // coords
                    break;

                case "touchmove":
                    //  e.preventDefault();

                    _touchCoords.push({
                        x: touchobj.clientX - _touchOffset.left,
                        y: touchobj.clientY - _touchOffset.top
                    });

                    if (_touchCoords.length < 2)
                        return;

                    var lineString = new H.geo.LineString;

                    _touchCoords.forEach(c => {
                        let coord = _map.screenToGeo(c.x, c.y);
                        lineString.pushLatLngAlt(coord.lat, coord.lng, 0);
                    });

                    // create polyline if not exists
                    if (!_touchPolyline) {
                        _touchPolyline = new H.map.Polyline(lineString, {
                            style: settings.style,
                            arrows: settings.arrows
                        });
                        _touchLayer.addObject(_touchPolyline);
                    } else  // modif geometry
                        _touchPolyline.setGeometry(lineString);
                    break;

                case "touchend": // c'est la fin, on simplifie et appelle le callback
                    if (_touchCoords.length < 2) // not enough points
                        return;

                    simplified = _touchCoords; //as array of {x,y}
                    if (settings.callback) {

                        // simplify the result
                        if (settings.tolerance > 0)
                            simplified = simplify(_touchCoords, settings.tolerance, false);

                        // not enough points, go back to initial
                        if (simplified.length < 1)
                            simplified = _touchCoords;

                        // convert from{x,y} screen to [lat,lng]
                        let coords = simplified.map(coord => {
                            let latlng = _map.screenToGeo(coord.x, coord.y);
                            return [latlng.lat, latlng.lng];
                        });

                        //let coords = geom.simplify(_touchCoords, settings.tolerance)

                        //up to callback to redraw
                        if (_touchPolyline && !settings.keep)
                            _touchLayer.removeObject(_touchPolyline);
                        _touchPolyline = null;

                        behaviorEnable(true);
                        // run callback
                        settings.callback(coords);
                    }
                    break;
            }

        }; // of _touch



    if (onoff) {
        elmt.addEventListener("touchstart", _touchCallback);
        elmt.addEventListener("touchmove", _touchCallback);
        elmt.addEventListener("touchend", _touchCallback);
        //        behaviorEnable(false);

    } else {
        elmt.removeEventListener("touchstart", _touchCallback);
        elmt.removeEventListener("touchmove", _touchCallback);
        elmt.removeEventListener("touchend", _touchCallback);

        if (_touchPolyline)
            _touchLayer.removeObject(_touchPolyline);

        _touchLayer = null;
        _touchPolyline = null;
        _touchCoords = null;
        behaviorEnable(true);
    }


} // of touch


module.exports = {
    touch: touch
};
},{"./map.js":14,"simplify-js":2}],"heremap.js":[function(require,module,exports){
(function (process){
"use strict";

/*
 * @module HEREMAP
 * @typicalname hm
 */

let modules = {};
Object.assign(modules, require("./common.js"));
Object.assign(modules, require("./geometry.js"));
Object.assign(modules, require("./routing.js"));
Object.assign(modules, require("./geocoding.js"));
Object.assign(modules, require("./place.js"));

if (process.browser) {
    Object.assign(modules, require("./map.js"));
    Object.assign(modules, require("./cluster.js"));
    Object.assign(modules, require("./touch.js"));
}
// export all the above
module.exports = modules;

}).call(this,require('_process'))

},{"./cluster.js":10,"./common.js":11,"./geocoding.js":12,"./geometry.js":13,"./map.js":14,"./place.js":15,"./routing.js":16,"./touch.js":17,"_process":1}]},{},[11,13,14,16,12,10,17,15])("heremap.js")
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3NpbXBsaWZ5LWpzL3NpbXBsaWZ5LmpzIiwiLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvYWdlbnQtYmFzZS5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2lzLW9iamVjdC5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3JlcXVlc3QtYmFzZS5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3Jlc3BvbnNlLWJhc2UuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi91dGlscy5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwiY2x1c3Rlci5qcyIsImNvbW1vbi5qcyIsImdlb2NvZGluZy5qcyIsImdlb21ldHJ5LmpzIiwibWFwLmpzIiwicGxhY2UuanMiLCJyb3V0aW5nLmpzIiwidG91Y2guanMiLCJoZXJlbWFwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2NUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2MUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLypcbiAoYykgMjAxNywgVmxhZGltaXIgQWdhZm9ua2luXG4gU2ltcGxpZnkuanMsIGEgaGlnaC1wZXJmb3JtYW5jZSBKUyBwb2x5bGluZSBzaW1wbGlmaWNhdGlvbiBsaWJyYXJ5XG4gbW91cm5lci5naXRodWIuaW8vc2ltcGxpZnktanNcbiovXG5cbihmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gdG8gc3VpdCB5b3VyIHBvaW50IGZvcm1hdCwgcnVuIHNlYXJjaC9yZXBsYWNlIGZvciAnLngnIGFuZCAnLnknO1xuLy8gZm9yIDNEIHZlcnNpb24sIHNlZSAzZCBicmFuY2ggKGNvbmZpZ3VyYWJpbGl0eSB3b3VsZCBkcmF3IHNpZ25pZmljYW50IHBlcmZvcm1hbmNlIG92ZXJoZWFkKVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50c1xuZnVuY3Rpb24gZ2V0U3FEaXN0KHAxLCBwMikge1xuXG4gICAgdmFyIGR4ID0gcDEueCAtIHAyLngsXG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50XG5mdW5jdGlvbiBnZXRTcVNlZ0Rpc3QocCwgcDEsIHAyKSB7XG5cbiAgICB2YXIgeCA9IHAxLngsXG4gICAgICAgIHkgPSBwMS55LFxuICAgICAgICBkeCA9IHAyLnggLSB4LFxuICAgICAgICBkeSA9IHAyLnkgLSB5O1xuXG4gICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG5cbiAgICAgICAgdmFyIHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IHAyLng7XG4gICAgICAgICAgICB5ID0gcDIueTtcblxuICAgICAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICB4ICs9IGR4ICogdDtcbiAgICAgICAgICAgIHkgKz0gZHkgKiB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHggPSBwLnggLSB4O1xuICAgIGR5ID0gcC55IC0geTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbi8vIHJlc3Qgb2YgdGhlIGNvZGUgZG9lc24ndCBjYXJlIGFib3V0IHBvaW50IGZvcm1hdFxuXG4vLyBiYXNpYyBkaXN0YW5jZS1iYXNlZCBzaW1wbGlmaWNhdGlvblxuZnVuY3Rpb24gc2ltcGxpZnlSYWRpYWxEaXN0KHBvaW50cywgc3FUb2xlcmFuY2UpIHtcblxuICAgIHZhciBwcmV2UG9pbnQgPSBwb2ludHNbMF0sXG4gICAgICAgIG5ld1BvaW50cyA9IFtwcmV2UG9pbnRdLFxuICAgICAgICBwb2ludDtcblxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgaWYgKGdldFNxRGlzdChwb2ludCwgcHJldlBvaW50KSA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBuZXdQb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2UG9pbnQgIT09IHBvaW50KSBuZXdQb2ludHMucHVzaChwb2ludCk7XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeURQU3RlcChwb2ludHMsIGZpcnN0LCBsYXN0LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCkge1xuICAgIHZhciBtYXhTcURpc3QgPSBzcVRvbGVyYW5jZSxcbiAgICAgICAgaW5kZXg7XG5cbiAgICBmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgIHZhciBzcURpc3QgPSBnZXRTcVNlZ0Rpc3QocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0pO1xuXG4gICAgICAgIGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIG1heFNxRGlzdCA9IHNxRGlzdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICBpZiAoaW5kZXggLSBmaXJzdCA+IDEpIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgZmlyc3QsIGluZGV4LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gICAgICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbaW5kZXhdKTtcbiAgICAgICAgaWYgKGxhc3QgLSBpbmRleCA+IDEpIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgaW5kZXgsIGxhc3QsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICB9XG59XG5cbi8vIHNpbXBsaWZpY2F0aW9uIHVzaW5nIFJhbWVyLURvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1cbmZ1bmN0aW9uIHNpbXBsaWZ5RG91Z2xhc1BldWNrZXIocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xuICAgIHZhciBsYXN0ID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICB2YXIgc2ltcGxpZmllZCA9IFtwb2ludHNbMF1dO1xuICAgIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgMCwgbGFzdCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbbGFzdF0pO1xuXG4gICAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59XG5cbi8vIGJvdGggYWxnb3JpdGhtcyBjb21iaW5lZCBmb3IgYXdlc29tZSBwZXJmb3JtYW5jZVxuZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UsIGhpZ2hlc3RRdWFsaXR5KSB7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8PSAyKSByZXR1cm4gcG9pbnRzO1xuXG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICE9PSB1bmRlZmluZWQgPyB0b2xlcmFuY2UgKiB0b2xlcmFuY2UgOiAxO1xuXG4gICAgcG9pbnRzID0gaGlnaGVzdFF1YWxpdHkgPyBwb2ludHMgOiBzaW1wbGlmeVJhZGlhbERpc3QocG9pbnRzLCBzcVRvbGVyYW5jZSk7XG4gICAgcG9pbnRzID0gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcihwb2ludHMsIHNxVG9sZXJhbmNlKTtcblxuICAgIHJldHVybiBwb2ludHM7XG59XG5cbi8vIGV4cG9ydCBhcyBBTUQgbW9kdWxlIC8gTm9kZSBtb2R1bGUgLyBicm93c2VyIG9yIHdvcmtlciB2YXJpYWJsZVxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2ltcGxpZnk7IH0pO1xuZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNpbXBsaWZ5O1xuICAgIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBzaW1wbGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBzZWxmLnNpbXBsaWZ5ID0gc2ltcGxpZnk7XG5lbHNlIHdpbmRvdy5zaW1wbGlmeSA9IHNpbXBsaWZ5O1xuXG59KSgpO1xuIiwiZnVuY3Rpb24gQWdlbnQoKSB7XG4gIHRoaXMuX2RlZmF1bHRzID0gW107XG59XG5cbltcInVzZVwiLCBcIm9uXCIsIFwib25jZVwiLCBcInNldFwiLCBcInF1ZXJ5XCIsIFwidHlwZVwiLCBcImFjY2VwdFwiLCBcImF1dGhcIiwgXCJ3aXRoQ3JlZGVudGlhbHNcIiwgXCJzb3J0UXVlcnlcIiwgXCJyZXRyeVwiLCBcIm9rXCIsIFwicmVkaXJlY3RzXCIsXG4gXCJ0aW1lb3V0XCIsIFwiYnVmZmVyXCIsIFwic2VyaWFsaXplXCIsIFwicGFyc2VcIiwgXCJjYVwiLCBcImtleVwiLCBcInBmeFwiLCBcImNlcnRcIl0uZm9yRWFjaChmbiA9PiB7XG4gIC8qKiBEZWZhdWx0IHNldHRpbmcgZm9yIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgYWdlbnQgKi9cbiAgQWdlbnQucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9kZWZhdWx0cy5wdXNoKHtmbiwgYXJnc30pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuQWdlbnQucHJvdG90eXBlLl9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uKHJlcSkge1xuICAgIHRoaXMuX2RlZmF1bHRzLmZvckVhY2goZGVmID0+IHtcbiAgICAgIHJlcVtkZWYuZm5dLmFwcGx5KHJlcSwgZGVmLmFyZ3MpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudDtcbiIsIi8qKlxuICogUm9vdCByZWZlcmVuY2UgZm9yIGlmcmFtZXMuXG4gKi9cblxubGV0IHJvb3Q7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gQnJvd3NlciB3aW5kb3dcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IC8vIFdlYiBXb3JrZXJcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgeyAvLyBPdGhlciBlbnZpcm9ubWVudHNcbiAgY29uc29sZS53YXJuKFwiVXNpbmcgYnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcbiAgcm9vdCA9IHRoaXM7XG59XG5cbmNvbnN0IEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuY29uc3QgUmVxdWVzdEJhc2UgPSByZXF1aXJlKCcuL3JlcXVlc3QtYmFzZScpO1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuY29uc3QgUmVzcG9uc2VCYXNlID0gcmVxdWlyZSgnLi9yZXNwb25zZS1iYXNlJyk7XG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQtYmFzZScpO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe307XG5cbi8qKlxuICogRXhwb3NlIGByZXF1ZXN0YC5cbiAqL1xuXG5jb25zdCByZXF1ZXN0ID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0aG9kLCB1cmwpIHtcbiAgLy8gY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHVybCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpLmVuZCh1cmwpO1xuICB9XG5cbiAgLy8gdXJsIGZpcnN0XG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdCgnR0VUJywgbWV0aG9kKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbn07XG5cbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5yZXF1ZXN0LmdldFhIUiA9ICgpID0+IHtcbiAgaWYgKHJvb3QuWE1MSHR0cFJlcXVlc3RcbiAgICAgICYmICghcm9vdC5sb2NhdGlvbiB8fCAnZmlsZTonICE9IHJvb3QubG9jYXRpb24ucHJvdG9jb2xcbiAgICAgICAgICB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICB0aHJvdyBFcnJvcihcIkJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSXCIpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IHRyaW0gPSAnJy50cmltXG4gID8gcyA9PiBzLnRyaW0oKVxuICA6IHMgPT4gcy5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csICcnKTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShvYmopIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICBjb25zdCBwYWlycyA9IFtdO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCBvYmpba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBIZWxwcyAnc2VyaWFsaXplJyB3aXRoIHNlcmlhbGl6aW5nIGFycmF5cy5cbiAqIE11dGF0ZXMgdGhlIHBhaXJzIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2YWwpIHtcbiAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFsLmZvckVhY2godiA9PiB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBmb3IoY29uc3Qgc3Via2V5IGluIHZhbCkge1xuICAgICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywgYCR7a2V5fVske3N1YmtleX1dYCwgdmFsW3N1YmtleV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgICAgICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cbiAqL1xuXG5yZXF1ZXN0LnNlcmlhbGl6ZU9iamVjdCA9IHNlcmlhbGl6ZTtcblxuLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xuICBjb25zdCBvYmogPSB7fTtcbiAgY29uc3QgcGFpcnMgPSBzdHIuc3BsaXQoJyYnKTtcbiAgbGV0IHBhaXI7XG4gIGxldCBwb3M7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBvcyA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpcildID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZSgwLCBwb3MpKV0gPVxuICAgICAgICBkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZShwb3MgKyAxKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFeHBvc2UgcGFyc2VyLlxuICovXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcblxuLyoqXG4gKiBEZWZhdWx0IE1JTUUgdHlwZSBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICovXG5cbnJlcXVlc3QudHlwZXMgPSB7XG4gIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gIHhtbDogJ3RleHQveG1sJyxcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG59O1xuXG4vKipcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXG4gICpcbiAgKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAgKiAgICAgfTtcbiAgKlxuICAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIGBzdHJgIGludG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKHN0cikge1xuICBjb25zdCBsaW5lcyA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pO1xuICBjb25zdCBmaWVsZHMgPSB7fTtcbiAgbGV0IGluZGV4O1xuICBsZXQgbGluZTtcbiAgbGV0IGZpZWxkO1xuICBsZXQgdmFsO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHsgLy8gY291bGQgYmUgZW1wdHkgbGluZSwganVzdCBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGluZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHRyaW0obGluZS5zbGljZShpbmRleCArIDEpKTtcbiAgICBmaWVsZHNbZmllbGRdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNKU09OKG1pbWUpIHtcbiAgLy8gc2hvdWxkIG1hdGNoIC9qc29uIG9yICtqc29uXG4gIC8vIGJ1dCBub3QgL2pzb24tc2VxXG4gIHJldHVybiAvW1xcLytdanNvbigkfFteLVxcd10pLy50ZXN0KG1pbWUpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZShyZXEpIHtcbiAgdGhpcy5yZXEgPSByZXE7XG4gIHRoaXMueGhyID0gdGhpcy5yZXEueGhyO1xuICAvLyByZXNwb25zZVRleHQgaXMgYWNjZXNzaWJsZSBvbmx5IGlmIHJlc3BvbnNlVHlwZSBpcyAnJyBvciAndGV4dCcgYW5kIG9uIG9sZGVyIGJyb3dzZXJzXG4gIHRoaXMudGV4dCA9ICgodGhpcy5yZXEubWV0aG9kICE9J0hFQUQnICYmICh0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICcnIHx8IHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSkgfHwgdHlwZW9mIHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgID8gdGhpcy54aHIucmVzcG9uc2VUZXh0XG4gICAgIDogbnVsbDtcbiAgdGhpcy5zdGF0dXNUZXh0ID0gdGhpcy5yZXEueGhyLnN0YXR1c1RleHQ7XG4gIGxldCBzdGF0dXMgPSB0aGlzLnhoci5zdGF0dXM7XG4gIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgIHN0YXR1cyA9IDIwNDtcbiAgfVxuICB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5fc2V0SGVhZGVyUHJvcGVydGllcyh0aGlzLmhlYWRlcik7XG5cbiAgaWYgKG51bGwgPT09IHRoaXMudGV4dCAmJiByZXEuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHRoaXMuYm9keSA9IHRoaXMueGhyLnJlc3BvbnNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYm9keSA9IHRoaXMucmVxLm1ldGhvZCAhPSAnSEVBRCdcbiAgICAgID8gdGhpcy5fcGFyc2VCb2R5KHRoaXMudGV4dCA/IHRoaXMudGV4dCA6IHRoaXMueGhyLnJlc3BvbnNlKVxuICAgICAgOiBudWxsO1xuICB9XG59XG5cblJlc3BvbnNlQmFzZShSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLl9wYXJzZUJvZHkgPSBmdW5jdGlvbihzdHIpIHtcbiAgbGV0IHBhcnNlID0gcmVxdWVzdC5wYXJzZVt0aGlzLnR5cGVdO1xuICBpZiAodGhpcy5yZXEuX3BhcnNlcikge1xuICAgIHJldHVybiB0aGlzLnJlcS5fcGFyc2VyKHRoaXMsIHN0cik7XG4gIH1cbiAgaWYgKCFwYXJzZSAmJiBpc0pTT04odGhpcy50eXBlKSkge1xuICAgIHBhcnNlID0gcmVxdWVzdC5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICB9XG4gIHJldHVybiBwYXJzZSAmJiBzdHIgJiYgKHN0ci5sZW5ndGggfHwgc3RyIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgID8gcGFyc2Uoc3RyKVxuICAgIDogbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbigpe1xuICBjb25zdCByZXEgPSB0aGlzLnJlcTtcbiAgY29uc3QgbWV0aG9kID0gcmVxLm1ldGhvZDtcbiAgY29uc3QgdXJsID0gcmVxLnVybDtcblxuICBjb25zdCBtc2cgPSBgY2Fubm90ICR7bWV0aG9kfSAke3VybH0gKCR7dGhpcy5zdGF0dXN9KWA7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSBtZXRob2Q7XG4gIGVyci51cmwgPSB1cmw7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBSZXNwb25zZWAuXG4gKi9cblxucmVxdWVzdC5SZXNwb25zZSA9IFJlc3BvbnNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlcXVlc3RgIHdpdGggdGhlIGdpdmVuIGBtZXRob2RgIGFuZCBgdXJsYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5oZWFkZXIgPSB7fTsgLy8gcHJlc2VydmVzIGhlYWRlciBuYW1lIGNhc2VcbiAgdGhpcy5faGVhZGVyID0ge307IC8vIGNvZXJjZXMgaGVhZGVyIG5hbWVzIHRvIGxvd2VyY2FzZVxuICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgbGV0IGVyciA9IG51bGw7XG4gICAgbGV0IHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICAgIC8vIGllOSBkb2Vzbid0IGhhdmUgJ3Jlc3BvbnNlJyBwcm9wZXJ0eVxuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPSB0eXBlb2Ygc2VsZi54aHIucmVzcG9uc2VUeXBlID09ICd1bmRlZmluZWQnID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogc2VsZi54aHIucmVzcG9uc2U7XG4gICAgICAgIC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgICBlcnIuc3RhdHVzID0gc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1c0NvZGUgPSBlcnIuc3RhdHVzOyAvLyBiYWNrd2FyZHMtY29tcGF0IG9ubHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGVyci5zdGF0dXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5jYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuXG4gICAgbGV0IG5ld19lcnI7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2VsZi5faXNSZXNwb25zZU9LKHJlcykpIHtcbiAgICAgICAgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGN1c3RvbV9lcnIpIHtcbiAgICAgIG5ld19lcnIgPSBjdXN0b21fZXJyOyAvLyBvaygpIGNhbGxiYWNrIGNhbiB0aHJvd1xuICAgIH1cblxuICAgIC8vICMxMDAwIGRvbid0IGNhdGNoIGVycm9ycyBmcm9tIHRoZSBjYWxsYmFjayB0byBhdm9pZCBkb3VibGUgY2FsbGluZyBpdFxuICAgIGlmIChuZXdfZXJyKSB7XG4gICAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICAgIG5ld19lcnIuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3X2VyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWl4aW4gYEVtaXR0ZXJgIGFuZCBgUmVxdWVzdEJhc2VgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuUmVxdWVzdEJhc2UoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldCBDb250ZW50LVR5cGUgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGFzc10gb3B0aW9uYWwgaW4gY2FzZSBvZiB1c2luZyAnYmVhcmVyJyBhcyB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycsICdiYXNpYycgb3IgJ2JlYXJlcicgKGRlZmF1bHQgJ2Jhc2ljJylcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucyl7XG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSBwYXNzID0gJyc7XG4gIGlmICh0eXBlb2YgcGFzcyA9PT0gJ29iamVjdCcgJiYgcGFzcyAhPT0gbnVsbCkgeyAvLyBwYXNzIGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHBhc3M7XG4gICAgcGFzcyA9ICcnO1xuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiAnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSA/ICdiYXNpYycgOiAnYXV0bycsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGVuY29kZXIgPSBzdHJpbmcgPT4ge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSkge1xuICAgICAgcmV0dXJuIGJ0b2Eoc3RyaW5nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGJhc2ljIGF1dGgsIGJ0b2EgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfTtcblxuICByZXR1cm4gdGhpcy5fYXV0aCh1c2VyLCBwYXNzLCBvcHRpb25zLCBlbmNvZGVyKTtcbn07XG5cbi8qKlxuICogQWRkIHF1ZXJ5LXN0cmluZyBgdmFsYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuICogICAgIC5xdWVyeSgnc2l6ZT0xMCcpXG4gKiAgICAgLnF1ZXJ5KHsgY29sb3I6ICdibHVlJyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2YWwpe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHZhbCkgdmFsID0gc2VyaWFsaXplKHZhbCk7XG4gIGlmICh2YWwpIHRoaXMuX3F1ZXJ5LnB1c2godmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBvcHRpb25zYCAob3IgZmlsZW5hbWUpLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmF0dGFjaCgnY29udGVudCcsIG5ldyBCbG9iKFsnPGEgaWQ9XCJhXCI+PGIgaWQ9XCJiXCI+aGV5ITwvYj48L2E+J10sIHsgdHlwZTogXCJ0ZXh0L2h0bWxcIn0pKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKGZpZWxkLCBmaWxlLCBvcHRpb25zKXtcbiAgaWYgKGZpbGUpIHtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJzdXBlcmFnZW50IGNhbid0IG1peCAuc2VuZCgpIGFuZCAuYXR0YWNoKClcIik7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIG9wdGlvbnMgfHwgZmlsZS5uYW1lKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9nZXRGb3JtRGF0YSA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aGlzLl9mb3JtRGF0YSA9IG5ldyByb290LkZvcm1EYXRhKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Zvcm1EYXRhO1xufTtcblxuLyoqXG4gKiBJbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYGVycmAgYW5kIGByZXNgXG4gKiBhbmQgaGFuZGxlIGFyaXR5IGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgcmVzKXtcbiAgaWYgKHRoaXMuX3Nob3VsZFJldHJ5KGVyciwgcmVzKSkge1xuICAgIHJldHVybiB0aGlzLl9yZXRyeSgpO1xuICB9XG5cbiAgY29uc3QgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICBpZiAoZXJyKSB7XG4gICAgaWYgKHRoaXMuX21heFJldHJpZXMpIGVyci5yZXRyaWVzID0gdGhpcy5fcmV0cmllcyAtIDE7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBmbihlcnIsIHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbigpe1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgaGFzIGJlZW4gdGVybWluYXRlZFxcblBvc3NpYmxlIGNhdXNlczogdGhlIG5ldHdvcmsgaXMgb2ZmbGluZSwgT3JpZ2luIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiwgdGhlIHBhZ2UgaXMgYmVpbmcgdW5sb2FkZWQsIGV0Yy4nKTtcbiAgZXJyLmNyb3NzRG9tYWluID0gdHJ1ZTtcblxuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSB0aGlzLm1ldGhvZDtcbiAgZXJyLnVybCA9IHRoaXMudXJsO1xuXG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8vIFRoaXMgb25seSB3YXJucywgYmVjYXVzZSB0aGUgcmVxdWVzdCBpcyBzdGlsbCBsaWtlbHkgdG8gd29ya1xuUmVxdWVzdC5wcm90b3R5cGUuYnVmZmVyID0gUmVxdWVzdC5wcm90b3R5cGUuY2EgPSBSZXF1ZXN0LnByb3RvdHlwZS5hZ2VudCA9IGZ1bmN0aW9uKCl7XG4gIGNvbnNvbGUud2FybihcIlRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudFwiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBUaGlzIHRocm93cywgYmVjYXVzZSBpdCBjYW4ndCBzZW5kL3JlY2VpdmUgZGF0YSBhcyBleHBlY3RlZFxuUmVxdWVzdC5wcm90b3R5cGUucGlwZSA9IFJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gKCkgPT4ge1xuICB0aHJvdyBFcnJvcihcIlN0cmVhbWluZyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblJlcXVlc3QucHJvdG90eXBlLl9pc0hvc3QgPSBmdW5jdGlvbiBfaXNIb3N0KG9iaikge1xuICAvLyBOYXRpdmUgb2JqZWN0cyBzdHJpbmdpZnkgdG8gW29iamVjdCBGaWxlXSwgW29iamVjdCBCbG9iXSwgW29iamVjdCBGb3JtRGF0YV0sIGV0Yy5cbiAgcmV0dXJuIG9iaiAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9iaiAmJiAhQXJyYXkuaXNBcnJheShvYmopICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgY29uc29sZS53YXJuKFwiV2FybmluZzogLmVuZCgpIHdhcyBjYWxsZWQgdHdpY2UuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBzdXBlcmFnZW50XCIpO1xuICB9XG4gIHRoaXMuX2VuZENhbGxlZCA9IHRydWU7XG5cbiAgLy8gc3RvcmUgY2FsbGJhY2tcbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wO1xuXG4gIC8vIHF1ZXJ5c3RyaW5nXG4gIHRoaXMuX2ZpbmFsaXplUXVlcnlTdHJpbmcoKTtcblxuICB0aGlzLl9lbmQoKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHJldHVybiB0aGlzLmNhbGxiYWNrKEVycm9yKFwiVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCBldmVuIGJlZm9yZSAuZW5kKCkgd2FzIGNhbGxlZFwiKSk7XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGNvbnN0IHhociA9ICh0aGlzLnhociA9IHJlcXVlc3QuZ2V0WEhSKCkpO1xuICBsZXQgZGF0YSA9IHRoaXMuX2Zvcm1EYXRhIHx8IHRoaXMuX2RhdGE7XG5cbiAgdGhpcy5fc2V0VGltZW91dHMoKTtcblxuICAvLyBzdGF0ZSBjaGFuZ2VcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMiAmJiBzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgICB9XG4gICAgaWYgKDQgIT0gcmVhZHlTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluIElFOSwgcmVhZHMgdG8gYW55IHByb3BlcnR5IChlLmcuIHN0YXR1cykgb2ZmIG9mIGFuIGFib3J0ZWQgWEhSIHdpbGxcbiAgICAvLyByZXN1bHQgaW4gdGhlIGVycm9yIFwiQ291bGQgbm90IGNvbXBsZXRlIHRoZSBvcGVyYXRpb24gZHVlIHRvIGVycm9yIGMwMGMwMjNmXCJcbiAgICBsZXQgc3RhdHVzO1xuICAgIHRyeSB7IHN0YXR1cyA9IHhoci5zdGF0dXMgfSBjYXRjaChlKSB7IHN0YXR1cyA9IDA7IH1cblxuICAgIGlmICghc3RhdHVzKSB7XG4gICAgICBpZiAoc2VsZi50aW1lZG91dCB8fCBzZWxmLl9hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gIH07XG5cbiAgLy8gcHJvZ3Jlc3NcbiAgY29uc3QgaGFuZGxlUHJvZ3Jlc3MgPSAoZGlyZWN0aW9uLCBlKSA9PiB7XG4gICAgaWYgKGUudG90YWwgPiAwKSB7XG4gICAgICBlLnBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDA7XG4gICAgfVxuICAgIGUuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBlKTtcbiAgfTtcbiAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKCdwcm9ncmVzcycpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHhoci5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAnZG93bmxvYWQnKTtcbiAgICAgIGlmICh4aHIudXBsb2FkKSB7XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ3VwbG9hZCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgLy8gQWNjZXNzaW5nIHhoci51cGxvYWQgZmFpbHMgaW4gSUUgZnJvbSBhIHdlYiB3b3JrZXIsIHNvIGp1c3QgcHJldGVuZCBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgLy8gUmVwb3J0ZWQgaGVyZTpcbiAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvODM3MjQ1L3htbGh0dHByZXF1ZXN0LXVwbG9hZC10aHJvd3MtaW52YWxpZC1hcmd1bWVudC13aGVuLXVzZWQtZnJvbS13ZWItd29ya2VyLWNvbnRleHRcbiAgICB9XG4gIH1cblxuICAvLyBpbml0aWF0ZSByZXF1ZXN0XG4gIHRyeSB7XG4gICAgaWYgKHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHNlZSAjMTE0OVxuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKGVycik7XG4gIH1cblxuICAvLyBDT1JTXG4gIGlmICh0aGlzLl93aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXG4gIC8vIGJvZHlcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSAmJiAnR0VUJyAhPSB0aGlzLm1ldGhvZCAmJiAnSEVBRCcgIT0gdGhpcy5tZXRob2QgJiYgJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgJiYgIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIC8vIHNlcmlhbGl6ZSBzdHVmZlxuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBsZXQgc2VyaWFsaXplID0gdGhpcy5fc2VyaWFsaXplciB8fCByZXF1ZXN0LnNlcmlhbGl6ZVtjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0gOiAnJ107XG4gICAgaWYgKCFzZXJpYWxpemUgJiYgaXNKU09OKGNvbnRlbnRUeXBlKSkge1xuICAgICAgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6ZSkgZGF0YSA9IHNlcmlhbGl6ZShkYXRhKTtcbiAgfVxuXG4gIC8vIHNldCBoZWFkZXIgZmllbGRzXG4gIGZvciAoY29uc3QgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuXG4gICAgaWYgKHRoaXMuaGVhZGVyLmhhc093blByb3BlcnR5KGZpZWxkKSlcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHN0dWZmXG4gIHRoaXMuZW1pdCgncmVxdWVzdCcsIHRoaXMpO1xuXG4gIC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gIHhoci5zZW5kKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgOiBudWxsKTtcbn07XG5cbnJlcXVlc3QuYWdlbnQgPSAoKSA9PiBuZXcgQWdlbnQoKTtcblxuW1wiR0VUXCIsIFwiUE9TVFwiLCBcIk9QVElPTlNcIiwgXCJQQVRDSFwiLCBcIlBVVFwiLCBcIkRFTEVURVwiXS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gIEFnZW50LnByb3RvdHlwZVttZXRob2QudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbih1cmwsIGZuKSB7XG4gICAgY29uc3QgcmVxID0gbmV3IHJlcXVlc3QuUmVxdWVzdChtZXRob2QsIHVybCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdHMocmVxKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJlcS5lbmQoZm4pO1xuICAgIH1cbiAgICByZXR1cm4gcmVxO1xuICB9O1xufSk7XG5cbkFnZW50LnByb3RvdHlwZS5kZWwgPSBBZ2VudC5wcm90b3R5cGVbJ2RlbGV0ZSddO1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBIRUFEIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5oZWFkID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogT1BUSU9OUyBxdWVyeSB0byBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3Qub3B0aW9ucyA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ09QVElPTlMnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWwodXJsLCBkYXRhLCBmbikge1xuICBjb25zdCByZXEgPSByZXF1ZXN0KCdERUxFVEUnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn1cblxucmVxdWVzdFsnZGVsJ10gPSBkZWw7XG5yZXF1ZXN0WydkZWxldGUnXSA9IGRlbDtcblxuLyoqXG4gKiBQQVRDSCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wYXRjaCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBPU1QgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucG9zdCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUFVUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnB1dCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gbnVsbCAhPT0gb2JqICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBvZiBtaXhlZC1pbiBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gbm9kZSBhbmQgY2xpZW50IGNvZGVcbiAqL1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVxdWVzdEJhc2VgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdEJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdEJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdEJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gUmVxdWVzdEJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIENsZWFyIHByZXZpb3VzIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCl7XG4gIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIGNsZWFyVGltZW91dCh0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gIGRlbGV0ZSB0aGlzLl90aW1lcjtcbiAgZGVsZXRlIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXNwb25zZSBib2R5IHBhcnNlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBpbmNvbWluZyBkYXRhIGludG8gcmVxdWVzdC5ib2R5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZm4pe1xuICB0aGlzLl9wYXJzZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBmb3JtYXQgb2YgYmluYXJ5IHJlc3BvbnNlIGJvZHkuXG4gKiBJbiBicm93c2VyIHZhbGlkIGZvcm1hdHMgYXJlICdibG9iJyBhbmQgJ2FycmF5YnVmZmVyJyxcbiAqIHdoaWNoIHJldHVybiBCbG9iIGFuZCBBcnJheUJ1ZmZlciwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEluIE5vZGUgYWxsIHZhbHVlcyByZXN1bHQgaW4gQnVmZmVyLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWwpe1xuICB0aGlzLl9yZXNwb25zZVR5cGUgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlcXVlc3QgYm9keSBzZXJpYWxpemVyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGRhdGEgc2V0IHZpYSAuc2VuZCBvciAuYXR0YWNoIGludG8gcGF5bG9hZCB0byBzZW5kXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShmbil7XG4gIHRoaXMuX3NlcmlhbGl6ZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aW1lb3V0cy5cbiAqXG4gKiAtIHJlc3BvbnNlIHRpbWVvdXQgaXMgdGltZSBiZXR3ZWVuIHNlbmRpbmcgcmVxdWVzdCBhbmQgcmVjZWl2aW5nIHRoZSBmaXJzdCBieXRlIG9mIHRoZSByZXNwb25zZS4gSW5jbHVkZXMgRE5TIGFuZCBjb25uZWN0aW9uIHRpbWUuXG4gKiAtIGRlYWRsaW5lIGlzIHRoZSB0aW1lIGZyb20gc3RhcnQgb2YgdGhlIHJlcXVlc3QgdG8gcmVjZWl2aW5nIHJlc3BvbnNlIGJvZHkgaW4gZnVsbC4gSWYgdGhlIGRlYWRsaW5lIGlzIHRvbyBzaG9ydCBsYXJnZSBmaWxlcyBtYXkgbm90IGxvYWQgYXQgYWxsIG9uIHNsb3cgY29ubmVjdGlvbnMuXG4gKlxuICogVmFsdWUgb2YgMCBvciBmYWxzZSBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gbXMgb3Ige3Jlc3BvbnNlLCBkZWFkbGluZX1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIHRpbWVvdXQob3B0aW9ucyl7XG4gIGlmICghb3B0aW9ucyB8fCAnb2JqZWN0JyAhPT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucztcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZm9yKGNvbnN0IG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgc3dpdGNoKG9wdGlvbikge1xuICAgICAgY2FzZSAnZGVhZGxpbmUnOlxuICAgICAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucy5kZWFkbGluZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZXNwb25zZSc6XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biB0aW1lb3V0IG9wdGlvblwiLCBvcHRpb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBvbiBlcnJvci5cbiAqXG4gKiBGYWlsZWQgcmVxdWVzdHMgd2lsbCBiZSByZXRyaWVkICdjb3VudCcgdGltZXMgaWYgdGltZW91dCBvciBlcnIuY29kZSA+PSA1MDAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24gcmV0cnkoY291bnQsIGZuKXtcbiAgLy8gRGVmYXVsdCB0byAxIGlmIG5vIGNvdW50IHBhc3NlZCBvciB0cnVlXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IGNvdW50ID09PSB0cnVlKSBjb3VudCA9IDE7XG4gIGlmIChjb3VudCA8PSAwKSBjb3VudCA9IDA7XG4gIHRoaXMuX21heFJldHJpZXMgPSBjb3VudDtcbiAgdGhpcy5fcmV0cmllcyA9IDA7XG4gIHRoaXMuX3JldHJ5Q2FsbGJhY2sgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5jb25zdCBFUlJPUl9DT0RFUyA9IFtcbiAgJ0VDT05OUkVTRVQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VBRERSSU5GTycsXG4gICdFU09DS0VUVElNRURPVVQnXG5dO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWQuXG4gKiAoQm9ycm93ZWQgZnJvbSBzZWdtZW50aW8vc3VwZXJhZ2VudC1yZXRyeSlcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IFtyZXNdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9zaG91bGRSZXRyeSA9IGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gIGlmICghdGhpcy5fbWF4UmV0cmllcyB8fCB0aGlzLl9yZXRyaWVzKysgPj0gdGhpcy5fbWF4UmV0cmllcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5fcmV0cnlDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdmVycmlkZSA9IHRoaXMuX3JldHJ5Q2FsbGJhY2soZXJyLCByZXMpO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIHVuZGVmaW5lZCBmYWxscyBiYWNrIHRvIGRlZmF1bHRzXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBpZiAocmVzICYmIHJlcy5zdGF0dXMgJiYgcmVzLnN0YXR1cyA+PSA1MDAgJiYgcmVzLnN0YXR1cyAhPSA1MDEpIHJldHVybiB0cnVlO1xuICBpZiAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICYmIH5FUlJPUl9DT0RFUy5pbmRleE9mKGVyci5jb2RlKSkgcmV0dXJuIHRydWU7XG4gICAgLy8gU3VwZXJhZ2VudCB0aW1lb3V0XG4gICAgaWYgKGVyci50aW1lb3V0ICYmIGVyci5jb2RlID09ICdFQ09OTkFCT1JURUQnKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyLmNyb3NzRG9tYWluKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHJ5IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fcmV0cnkgPSBmdW5jdGlvbigpIHtcblxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIC8vIG5vZGVcbiAgaWYgKHRoaXMucmVxKSB7XG4gICAgdGhpcy5yZXEgPSBudWxsO1xuICAgIHRoaXMucmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIH1cblxuICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7XG4gIHRoaXMudGltZWRvdXQgPSBmYWxzZTtcblxuICByZXR1cm4gdGhpcy5fZW5kKCk7XG59O1xuXG4vKipcbiAqIFByb21pc2Ugc3VwcG9ydFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihyZXNvbHZlLCByZWplY3QpIHtcbiAgaWYgKCF0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IHN1cGVyYWdlbnQgcmVxdWVzdCB3YXMgc2VudCB0d2ljZSwgYmVjYXVzZSBib3RoIC5lbmQoKSBhbmQgLnRoZW4oKSB3ZXJlIGNhbGxlZC4gTmV2ZXIgY2FsbCAuZW5kKCkgaWYgeW91IHVzZSBwcm9taXNlc1wiKTtcbiAgICB9XG4gICAgdGhpcy5fZnVsbGZpbGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoaW5uZXJSZXNvbHZlLCBpbm5lclJlamVjdCkgPT4ge1xuICAgICAgc2VsZi5vbignZXJyb3InLCBpbm5lclJlamVjdCk7XG4gICAgICBzZWxmLmVuZCgoZXJyLCByZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikgaW5uZXJSZWplY3QoZXJyKTtcbiAgICAgICAgZWxzZSBpbm5lclJlc29sdmUocmVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbihjYikge1xuICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgY2IpO1xufTtcblxuLyoqXG4gKiBBbGxvdyBmb3IgZXh0ZW5zaW9uXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmbikge1xuICBmbih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUub2sgPSBmdW5jdGlvbihjYikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNiKSB0aHJvdyBFcnJvcihcIkNhbGxiYWNrIHJlcXVpcmVkXCIpO1xuICB0aGlzLl9va0NhbGxiYWNrID0gY2I7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9pc1Jlc3BvbnNlT0sgPSBmdW5jdGlvbihyZXMpIHtcbiAgaWYgKCFyZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fb2tDYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9va0NhbGxiYWNrKHJlcyk7XG4gIH1cblxuICByZXR1cm4gcmVzLnN0YXR1cyA+PSAyMDAgJiYgcmVzLnN0YXR1cyA8IDMwMDtcbn07XG5cbi8qKlxuICogR2V0IHJlcXVlc3QgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXRIZWFkZXIgPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgYGZpZWxkYCB0byBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLnNldCgnWC1BUEktS2V5JywgJ2Zvb2JhcicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsICdYLUFQSS1LZXknOiAnZm9vYmFyJyB9KVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oZmllbGQsIHZhbCl7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmaWVsZCkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAudW5zZXQoJ1VzZXItQWdlbnQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIGRlbGV0ZSB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG4gIGRlbGV0ZSB0aGlzLmhlYWRlcltmaWVsZF07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZSB0aGUgZmllbGQgYG5hbWVgIGFuZCBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdFxuICogZm9yIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIHJlcXVlc3QgYm9kaWVzLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKCdmb28nLCAnYmFyJylcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKHsgZm9vOiAnYmFyJywgYmF6OiAncXV4JyB9KVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd8QmxvYnxGaWxlfEJ1ZmZlcnxmcy5SZWFkU3RyZWFtfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmZpZWxkID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gIC8vIG5hbWUgc2hvdWxkIGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBvYmplY3QuXG4gIGlmIChudWxsID09PSBuYW1lIHx8IHVuZGVmaW5lZCA9PT0gbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgbmFtZSBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIi5maWVsZCgpIGNhbid0IGJlIHVzZWQgaWYgLnNlbmQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCIpO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZSkge1xuICAgICAgdGhpcy5maWVsZChrZXksIG5hbWVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGZvciAoY29uc3QgaSBpbiB2YWwpIHtcbiAgICAgIHRoaXMuZmllbGQobmFtZSwgdmFsW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB2YWwgc2hvdWxkIGJlIGRlZmluZWQgbm93XG4gIGlmIChudWxsID09PSB2YWwgfHwgdW5kZWZpbmVkID09PSB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIHZhbCBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cbiAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHZhbCkge1xuICAgIHZhbCA9ICcnICsgdmFsO1xuICB9XG4gIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKG5hbWUsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYm9ydCB0aGUgcmVxdWVzdCwgYW5kIGNsZWFyIHBvdGVudGlhbCB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xuICB0aGlzLnhociAmJiB0aGlzLnhoci5hYm9ydCgpOyAvLyBicm93c2VyXG4gIHRoaXMucmVxICYmIHRoaXMucmVxLmFib3J0KCk7IC8vIG5vZGVcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXV0aCA9IGZ1bmN0aW9uKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGJhc2U2NEVuY29kZXIpIHtcbiAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICBjYXNlICdiYXNpYyc6XG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCYXNpYyAke2Jhc2U2NEVuY29kZXIoYCR7dXNlcn06JHtwYXNzfWApfWApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdXRvJzpcbiAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VyO1xuICAgICAgdGhpcy5wYXNzd29yZCA9IHBhc3M7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JlYXJlcic6IC8vIHVzYWdlIHdvdWxkIGJlIC5hdXRoKGFjY2Vzc1Rva2VuLCB7IHR5cGU6ICdiZWFyZXInIH0pXG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHt1c2VyfWApO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHMgPSBmdW5jdGlvbihvbikge1xuICAvLyBUaGlzIGlzIGJyb3dzZXItb25seSBmdW5jdGlvbmFsaXR5LiBOb2RlIHNpZGUgaXMgbm8tb3AuXG4gIGlmIChvbiA9PSB1bmRlZmluZWQpIG9uID0gdHJ1ZTtcbiAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCByZWRpcmVjdHMgdG8gYG5gLiBEb2VzIG5vdGluZyBpbiBicm93c2VyIFhIUiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZWRpcmVjdHMgPSBmdW5jdGlvbihuKXtcbiAgdGhpcy5fbWF4UmVkaXJlY3RzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1heGltdW0gc2l6ZSBvZiBidWZmZXJlZCByZXNwb25zZSBib2R5LCBpbiBieXRlcy4gQ291bnRzIHVuY29tcHJlc3NlZCBzaXplLlxuICogRGVmYXVsdCAyMDBNQi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5tYXhSZXNwb25zZVNpemUgPSBmdW5jdGlvbihuKXtcbiAgaWYgKCdudW1iZXInICE9PSB0eXBlb2Ygbikge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG4gIH1cbiAgdGhpcy5fbWF4UmVzcG9uc2VTaXplID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdG8gYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCAobm90IEpTT04gc3RyaW5nKSBvZiBzY2FsYXIgcHJvcGVydGllcy5cbiAqIE5vdGUgYXMgdGhpcyBtZXRob2QgaXMgZGVzaWduZWQgdG8gcmV0dXJuIGEgdXNlZnVsIG5vbi10aGlzIHZhbHVlLFxuICogaXQgY2Fubm90IGJlIGNoYWluZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZXNjcmliaW5nIG1ldGhvZCwgdXJsLCBhbmQgZGF0YSBvZiB0aGlzIHJlcXVlc3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgdXJsOiB0aGlzLnVybCxcbiAgICBkYXRhOiB0aGlzLl9kYXRhLFxuICAgIGhlYWRlcnM6IHRoaXMuX2hlYWRlcixcbiAgfTtcbn07XG5cbi8qKlxuICogU2VuZCBgZGF0YWAgYXMgdGhlIHJlcXVlc3QgYm9keSwgZGVmYXVsdGluZyB0aGUgYC50eXBlKClgIHRvIFwianNvblwiIHdoZW5cbiAqIGFuIG9iamVjdCBpcyBnaXZlbi5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBtYW51YWwganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdqc29uJylcbiAqICAgICAgICAgLnNlbmQoJ3tcIm5hbWVcIjpcInRqXCJ9JylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtYW51YWwgeC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCgnbmFtZT10aicpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGRlZmF1bHRzIHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAqICAgICAgICAuc2VuZCgnc3BlY2llcz1mZXJyZXQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKXtcbiAgY29uc3QgaXNPYmogPSBpc09iamVjdChkYXRhKTtcbiAgbGV0IHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gIGlmICh0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIi5zZW5kKCkgY2FuJ3QgYmUgdXNlZCBpZiAuYXR0YWNoKCkgb3IgLmZpZWxkKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iaiAmJiAhdGhpcy5fZGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgfSBlbHNlIGlmICghdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEgJiYgdGhpcy5fZGF0YSAmJiB0aGlzLl9pc0hvc3QodGhpcy5fZGF0YSkpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbid0IG1lcmdlIHRoZXNlIHNlbmQgY2FsbHNcIik7XG4gIH1cblxuICAvLyBtZXJnZVxuICBpZiAoaXNPYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgLy8gZGVmYXVsdCB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnZm9ybScpO1xuICAgIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIGlmICgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyA9PSB0eXBlKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YVxuICAgICAgICA/IGAke3RoaXMuX2RhdGF9JiR7ZGF0YX1gXG4gICAgICAgIDogZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGF0YSA9ICh0aGlzLl9kYXRhIHx8ICcnKSArIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG5cbiAgaWYgKCFpc09iaiB8fCB0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdG8ganNvblxuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU29ydCBgcXVlcnlzdHJpbmdgIGJ5IHRoZSBzb3J0IGZ1bmN0aW9uXG4gKlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIGRlZmF1bHQgb3JkZXJcbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KClcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBjdXN0b21pemVkIHNvcnQgZnVuY3Rpb25cbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KGZ1bmN0aW9uKGEsIGIpe1xuICogICAgICAgICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICogICAgICAgICB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNvcnRRdWVyeSA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgLy8gX3NvcnQgZGVmYXVsdCB0byB0cnVlIGJ1dCBvdGhlcndpc2UgY2FuIGJlIGEgZnVuY3Rpb24gb3IgYm9vbGVhblxuICB0aGlzLl9zb3J0ID0gdHlwZW9mIHNvcnQgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IHNvcnQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb21wb3NlIHF1ZXJ5c3RyaW5nIHRvIGFwcGVuZCB0byByZXEudXJsXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fZmluYWxpemVRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIGNvbnN0IHF1ZXJ5ID0gdGhpcy5fcXVlcnkuam9pbignJicpO1xuICBpZiAocXVlcnkpIHtcbiAgICB0aGlzLnVybCArPSAodGhpcy51cmwuaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPycpICsgcXVlcnk7XG4gIH1cbiAgdGhpcy5fcXVlcnkubGVuZ3RoID0gMDsgLy8gTWFrZXMgdGhlIGNhbGwgaWRlbXBvdGVudFxuXG4gIGlmICh0aGlzLl9zb3J0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IHF1ZXJ5QXJyID0gdGhpcy51cmwuc3Vic3RyaW5nKGluZGV4ICsgMSkuc3BsaXQoJyYnKTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5fc29ydCkge1xuICAgICAgICBxdWVyeUFyci5zb3J0KHRoaXMuX3NvcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlBcnIuc29ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgJz8nICsgcXVlcnlBcnIuam9pbignJicpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQgb25seVxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9hcHBlbmRRdWVyeVN0cmluZyA9ICgpID0+IHtjb25zb2xlLnRyYWNlKFwiVW5zdXBwb3J0ZWRcIik7fVxuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHRpbWVvdXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbihyZWFzb24sIHRpbWVvdXQsIGVycm5vKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKGAke3JlYXNvbiArIHRpbWVvdXR9bXMgZXhjZWVkZWRgKTtcbiAgZXJyLnRpbWVvdXQgPSB0aW1lb3V0O1xuICBlcnIuY29kZSA9ICdFQ09OTkFCT1JURUQnO1xuICBlcnIuZXJybm8gPSBlcnJubztcbiAgdGhpcy50aW1lZG91dCA9IHRydWU7XG4gIHRoaXMuYWJvcnQoKTtcbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9zZXRUaW1lb3V0cyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcblxuICAvLyBkZWFkbGluZVxuICBpZiAodGhpcy5fdGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdUaW1lb3V0IG9mICcsIHNlbGYuX3RpbWVvdXQsICdFVElNRScpO1xuICAgIH0sIHRoaXMuX3RpbWVvdXQpO1xuICB9XG4gIC8vIHJlc3BvbnNlIHRpbWVvdXRcbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVGltZW91dCAmJiAhdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdSZXNwb25zZSB0aW1lb3V0IG9mICcsIHNlbGYuX3Jlc3BvbnNlVGltZW91dCwgJ0VUSU1FRE9VVCcpO1xuICAgIH0sIHRoaXMuX3Jlc3BvbnNlVGltZW91dCk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlQmFzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZXNwb25zZUJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VCYXNlYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlQmFzZShvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKGNvbnN0IGtleSBpbiBSZXNwb25zZUJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXNwb25zZUJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiB0aGlzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogU2V0IGhlYWRlciByZWxhdGVkIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGAudHlwZWAgdGhlIGNvbnRlbnQgdHlwZSB3aXRob3V0IHBhcmFtc1xuICpcbiAqIEEgcmVzcG9uc2Ugb2YgXCJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICogd2lsbCBwcm92aWRlIHlvdSB3aXRoIGEgYC50eXBlYCBvZiBcInRleHQvcGxhaW5cIi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRIZWFkZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24oaGVhZGVyKXtcbiAgICAvLyBUT0RPOiBtb2FyIVxuICAgIC8vIFRPRE86IG1ha2UgdGhpcyBhIHV0aWxcblxuICAgIC8vIGNvbnRlbnQtdHlwZVxuICAgIGNvbnN0IGN0ID0gaGVhZGVyWydjb250ZW50LXR5cGUnXSB8fCAnJztcbiAgICB0aGlzLnR5cGUgPSB1dGlscy50eXBlKGN0KTtcblxuICAgIC8vIHBhcmFtc1xuICAgIGNvbnN0IHBhcmFtcyA9IHV0aWxzLnBhcmFtcyhjdCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB0aGlzW2tleV0gPSBwYXJhbXNba2V5XTtcblxuICAgIHRoaXMubGlua3MgPSB7fTtcblxuICAgIC8vIGxpbmtzXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGhlYWRlci5saW5rKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtzID0gdXRpbHMucGFyc2VMaW5rcyhoZWFkZXIubGluayk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgZmxhZ3Mgc3VjaCBhcyBgLm9rYCBiYXNlZCBvbiBgc3RhdHVzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBhIDJ4eCByZXNwb25zZSB3aWxsIGdpdmUgeW91IGEgYC5va2Agb2YgX190cnVlX19cbiAqIHdoZXJlYXMgNXh4IHdpbGwgYmUgX19mYWxzZV9fIGFuZCBgLmVycm9yYCB3aWxsIGJlIF9fdHJ1ZV9fLiBUaGVcbiAqIGAuY2xpZW50RXJyb3JgIGFuZCBgLnNlcnZlckVycm9yYCBhcmUgYWxzbyBhdmFpbGFibGUgdG8gYmUgbW9yZVxuICogc3BlY2lmaWMsIGFuZCBgLnN0YXR1c1R5cGVgIGlzIHRoZSBjbGFzcyBvZiBlcnJvciByYW5naW5nIGZyb20gMS4uNVxuICogc29tZXRpbWVzIHVzZWZ1bCBmb3IgbWFwcGluZyByZXNwb25kIGNvbG9ycyBldGMuXG4gKlxuICogXCJzdWdhclwiIHByb3BlcnRpZXMgYXJlIGFsc28gZGVmaW5lZCBmb3IgY29tbW9uIGNhc2VzLiBDdXJyZW50bHkgcHJvdmlkaW5nOlxuICpcbiAqICAgLSAubm9Db250ZW50XG4gKiAgIC0gLmJhZFJlcXVlc3RcbiAqICAgLSAudW5hdXRob3JpemVkXG4gKiAgIC0gLm5vdEFjY2VwdGFibGVcbiAqICAgLSAubm90Rm91bmRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRTdGF0dXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24oc3RhdHVzKXtcbiAgICBjb25zdCB0eXBlID0gc3RhdHVzIC8gMTAwIHwgMDtcblxuICAgIC8vIHN0YXR1cyAvIGNsYXNzXG4gICAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0dXNUeXBlID0gdHlwZTtcblxuICAgIC8vIGJhc2ljc1xuICAgIHRoaXMuaW5mbyA9IDEgPT0gdHlwZTtcbiAgICB0aGlzLm9rID0gMiA9PSB0eXBlO1xuICAgIHRoaXMucmVkaXJlY3QgPSAzID09IHR5cGU7XG4gICAgdGhpcy5jbGllbnRFcnJvciA9IDQgPT0gdHlwZTtcbiAgICB0aGlzLnNlcnZlckVycm9yID0gNSA9PSB0eXBlO1xuICAgIHRoaXMuZXJyb3IgPSAoNCA9PSB0eXBlIHx8IDUgPT0gdHlwZSlcbiAgICAgICAgPyB0aGlzLnRvRXJyb3IoKVxuICAgICAgICA6IGZhbHNlO1xuXG4gICAgLy8gc3VnYXJcbiAgICB0aGlzLmNyZWF0ZWQgPSAyMDEgPT0gc3RhdHVzO1xuICAgIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICAgIHRoaXMubm9Db250ZW50ID0gMjA0ID09IHN0YXR1cztcbiAgICB0aGlzLmJhZFJlcXVlc3QgPSA0MDAgPT0gc3RhdHVzO1xuICAgIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEFjY2VwdGFibGUgPSA0MDYgPT0gc3RhdHVzO1xuICAgIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEZvdW5kID0gNDA0ID09IHN0YXR1cztcbiAgICB0aGlzLnVucHJvY2Vzc2FibGVFbnRpdHkgPSA0MjIgPT0gc3RhdHVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudHlwZSA9IHN0ciA9PiBzdHIuc3BsaXQoLyAqOyAqLykuc2hpZnQoKTtcblxuLyoqXG4gKiBSZXR1cm4gaGVhZGVyIGZpZWxkIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJhbXMgPSBzdHIgPT4gc3RyLnNwbGl0KC8gKjsgKi8pLnJlZHVjZSgob2JqLCBzdHIpID0+IHtcbiAgY29uc3QgcGFydHMgPSBzdHIuc3BsaXQoLyAqPSAqLyk7XG4gIGNvbnN0IGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gIGNvbnN0IHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgaWYgKGtleSAmJiB2YWwpIG9ialtrZXldID0gdmFsO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIFBhcnNlIExpbmsgaGVhZGVyIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcnNlTGlua3MgPSBzdHIgPT4gc3RyLnNwbGl0KC8gKiwgKi8pLnJlZHVjZSgob2JqLCBzdHIpID0+IHtcbiAgY29uc3QgcGFydHMgPSBzdHIuc3BsaXQoLyAqOyAqLyk7XG4gIGNvbnN0IHVybCA9IHBhcnRzWzBdLnNsaWNlKDEsIC0xKTtcbiAgY29uc3QgcmVsID0gcGFydHNbMV0uc3BsaXQoLyAqPSAqLylbMV0uc2xpY2UoMSwgLTEpO1xuICBvYmpbcmVsXSA9IHVybDtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBTdHJpcCBjb250ZW50IHJlbGF0ZWQgZmllbGRzIGZyb20gYGhlYWRlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuY2xlYW5IZWFkZXIgPSAoaGVhZGVyLCBjaGFuZ2VzT3JpZ2luKSA9PiB7XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LWxlbmd0aCddO1xuICBkZWxldGUgaGVhZGVyWyd0cmFuc2Zlci1lbmNvZGluZyddO1xuICBkZWxldGUgaGVhZGVyWydob3N0J107XG4gIC8vIHNlY3VpcnR5XG4gIGlmIChjaGFuZ2VzT3JpZ2luKSB7XG4gICAgZGVsZXRlIGhlYWRlclsnYXV0aG9yaXphdGlvbiddO1xuICAgIGRlbGV0ZSBoZWFkZXJbJ2Nvb2tpZSddO1xuICB9XG4gIHJldHVybiBoZWFkZXI7XG59O1xuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiLyogZ2xvYmFsIEgsIGRvY3VtZW50LCBJbWFnZSAqL1xyXG5cInVzZSBzdHJpY3RcIjtcclxuY29uc3QgY20gPSByZXF1aXJlKFwiY29tbW9uXCIpO1xyXG5jb25zdCBtID0gcmVxdWlyZShcIm1hcFwiKTtcclxuXHJcbi8vIG1hcCBvbiB3aGljaCB0byBhZGQgdGhlIGNsdXN0ZXIgbGF5ZXJcclxubGV0IG1hcCA9IG51bGw7XHJcblxyXG4vL3RoZSBjbHVzdGVyIGxheWVyXHJcbmxldCBjbHVzdGVyTGF5ZXIgPSBudWxsO1xyXG5sZXQgX3Zpc2libGUgPSBmYWxzZTtcclxuXHJcbmxldCBpY29uTm9pc2UgPSBudWxsO1xyXG5sZXQgY2x1c3RlclN0eWxlID0gW107IC8vIGFycmF5IG9mIHt3ZWlnaHQscG9zIGltYWdlZGF0YX1cclxuXHJcbmxldCBjbHVzdGVyZWREYXRhUHJvdmlkZXIgPSBudWxsO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGVzIGEgY2x1c3RlciBvZiBwb2ludHNcclxuICogQGFsaWFzIGhtOmNsdXN0ZXJcclxuICogQHBhcmFtIGNvb3JkcyB7QXJyYXl9ICBhcnJheSBvZiBcXFtsYXQsbG5nLHBheWxvYWRcXF1cclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSBvcHRpb25zIGZvciBjbHVzdGVyXHJcbiAqIEBwYXJhbSBbb3B0Lm1pblpvb21dIHtudW1iZXJ9IG1pbiB6b29tIGZvciBjbHVzdGVyIHRvIGJlIHZpc2libGVcclxuICogQHBhcmFtIFtvcHQubWF4Wm9vbV0ge251bWJlcn0gbWF4IHpvb20gZm9yIGNsdXN0ZXIgdG8gYmUgdmlzaWJsZVxyXG4gKiBAcGFyYW0gW29wdC5ub2lzZV0ge29iamVjdH0gZ3JhcGhpYyB0byByZXByZXNlbnQgc3RhbmQtYWxvbmUgcG9pbnQuIHtpY29uLHNpemV9XHJcbiAqIEBwYXJhbSBbb3B0Lm5vaXNlLmljb25dIHtzdHJpbmd9IHBuZy9qcGcvc2NnIGZpbGUuIEAgYXMgZmlyc3QgY2hhcmFjdGVyIGluZGljYXRlcyBhIGZpbGUgZnJvbSB0aGlzIHBhY2thZ2UuIEFuY2hvciB3aWxsIGJlIGJvdHRvbS1jZW50ZXJcclxuICogQHBhcmFtIFtvcHQubm9pc2Uuc2l6ZV0ge251bWJlcn0gb3B0aW9uYWwgc2l6ZSBvZiBpY29uXHJcbiAqIEBwYXJhbSBbb3B0LmNsdXN0ZXJdIHtvYmplY3R9IHsgd2VpZ2h0OntpY29uLHNpemV9LCB3ZWlnaHQ6e2ljb24sc2l6ZX0sLi4uIH1cclxuICogQHBhcmFtIFtvcHQuY2x1c3Rlci5pY29uXSB7c3RyaW5nfSBncmFwaGljIGZvciBncm91cCBvZiBwb2lzLiBAIGFzIGZpcnN0IGNoYXJhY3RlciBpbmRpY2F0ZXMgYSBmaWxlIGZyb20gdGhpcyBwYWNrYWdlLiBBbmNob3Igd2lsbCBiZSBtaWRkbGUgb2YgaWNvblxyXG4gKiBAcGFyYW0gW29wdC5jbHVzdGVyLnNpemVdIHtudW1iZXJ9IHNpemUgb2YgaWNvblxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBjYWxsYmFjayB0byBiZSBjYWxsZWQgaWYgY2xpY2sgb24gaXRlbS4gRm9ybWF0IGNiKGV2ZW50LCBjb29yZCwgcGF5bG9hZCwgd2VpZ3RoKS4gXHJcbiAqIGBjb29yZGAgaXMgY29vcmQgb2YgaWNvblxyXG4gKiBgcGF5bG9hZGAgaXMgcGF5bG9hZCBhc3NvY2lhdGVkIHRvIHBvaW50LiBcclxuICogYHdlaWdodGAgaXMgbnVtYmVyIG9mIHBvaW50cyBhZ2dyZWdhdGVkLCB3aGVuIGNsaWNraW5nIG9uIGEgY2x1c3RlciBpY29uLCAxIGlmIHNpbmdsZSBwb2ludFxyXG4gKiBcclxuICogQHJldHVybiB7SC5tYXAubGF5ZXIuT2JqZWN0TGF5ZXJ9ICBsYXllciBjcmVhdGVkXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiBsZXQgcG9pcyA9IFtbNDguOCwyLjMsXCJIZWxsbyB3b3JsZFwiXSxbNDguNSwyLjQsXCJIb3cgYXJlIHlvdVwiXSxbNDUuMiwyLjkzLFwiVmVyeSB3ZWxsXCJdXTtcclxuICogXHJcbiAqIGhtLmNsdXN0ZXIocG9pcyk7XHJcbiAqIFxyXG4gKiAvLyB3aXRoIG1vcmUgZ3JhcGhpYyBvcHRpb25zIGFuZCBjYWxsYmFjayBkZWZpbmVkXHJcbiAqICAgbGV0IG9wdCA9IHtcclxuICogICAgbm9pc2U6IHtcclxuICogICAgICAgICAgaWNvbjogXCJtY2RvLnBuZ1wiLFxyXG4gKiAgICAgICAgICBzaXplOiAxMlxyXG4gKiAgICAgIH0sXHJcbiAqICAgIGNsdXN0ZXI6IHtcclxuICogICAgICAgMjAwOiB7XHJcbiAqICAgICAgICAgICBpY29uOiBcIkBzdmcvY2x1c3Rlcl9yZWQuc3ZnXCIsXHJcbiAqICAgICAgICAgICBjb2xvcjogXCIjQjUwMDE1XCIsXHJcbiAqICAgICAgICAgICBzaXplOiA2NFxyXG4gKiAgICAgICB9LFxyXG4gKiAgICAgICA3NToge1xyXG4gKiAgICAgICAgICAgaWNvbjogXCJAc3ZnL2NsdXN0ZXJfb3JhbmdlLnN2Z1wiLFxyXG4gKiAgICAgICAgICAgY29sb3I6IFwiI0ZGNjkwMFwiLFxyXG4gKiAgICAgICAgICAgc2l6ZTogNTJcclxuICogICAgICAgfSxcclxuICogICAgICAgMjoge1xyXG4gKiAgICAgICAgICAgaWNvbjogXCJAc3ZnL2NsdXN0ZXJfZ3JlZW4uc3ZnXCIsXHJcbiAqICAgICAgICAgICBjb2xvcjogXCIjN0JEMzBBXCIsXHJcbiAqICAgICAgICAgICBzaXplOiA0MFxyXG4gKiAgICAgICAgfVxyXG4gKiAgICB9XHJcbiAqICAgfTtcclxuICogIGhtLmNsdXN0ZXIocG9pcywgb3B0LFxyXG4gKiAgICAgICAgICAgKGV2ZW50LCBjb29yZGluYXRlLCBkYXRhLCB3ZWlnaHQpID0+IHtcclxuICogICAgICAgICAgICAgICBpZiAoZGF0YSlcclxuICogICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjbGljayBvbiBwb2ludCBcIiwgZGF0YSk7XHJcbiAqICAgICAgICAgICAgICAgZWxzZVxyXG4gKiAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNsaWNrIG9uIGNsdXN0ZXIgd2l0aCB3ZWlnaHRcIiwgd2VpZ2h0KTtcclxuICogICAgICAgICAgIH0pO1xyXG4gKiBgYGBcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNsdXN0ZXIoY29vcmRzLCBvcHQsIGNiID0gbnVsbCkge1xyXG5cclxuICAgIGxldCBkYXRhUG9pbnRzID0gW107XHJcbiAgICBtYXAgPSBtLmdldE1hcCgpO1xyXG4gICAgbGV0IF9ob21lID0gY20uZ2V0SG9tZSgpO1xyXG5cclxuICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBlcHM6IDY0LFxyXG4gICAgICAgIG1pblpvb206IDEsIC8vIG1pbiB6b29tXHJcbiAgICAgICAgbWF4Wm9vbTogMjQsIC8vIG1heCB6b29tXHJcbiAgICAgICAgbm9pc2U6IHtcclxuICAgICAgICAgICAgaWNvbjogX2hvbWUgKyBcInN2Zy9ibHVlZG90LnN2Z1wiLFxyXG4gICAgICAgICAgICBzaXplOiAxNlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2x1c3Rlcjoge1xyXG4gICAgICAgICAgICAyMDA6IHtcclxuICAgICAgICAgICAgICAgIGljb246IF9ob21lICsgXCJzdmcvY2x1c3Rlcl9yZWQuc3ZnXCIsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIjQjUwMDE1XCIsXHJcbiAgICAgICAgICAgICAgICBzaXplOiA2NFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA3NToge1xyXG4gICAgICAgICAgICAgICAgaWNvbjogX2hvbWUgKyBcInN2Zy9jbHVzdGVyX29yYW5nZS5zdmdcIixcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIiNGRjY5MDBcIixcclxuICAgICAgICAgICAgICAgIHNpemU6IDQ4XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDI6IHtcclxuICAgICAgICAgICAgICAgIGljb246IF9ob21lICsgXCJzdmcvY2x1c3Rlcl9ncmVlbi5zdmdcIixcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIiM3QkQzMEFcIixcclxuICAgICAgICAgICAgICAgIHNpemU6IDQwXHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmIChvcHQpXHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBsZXQgdXNlVGhlbWUgPSB0cnVlOyAvLyBkbyB3ZSB1c2Ugb3VyIG93biB0aGVtZSA/XHJcbiAgICBpZiAoIW9wdCB8fCAob3B0ICYmICFvcHQubm9pc2UgJiYgIW9wdC5jbHVzdGVyKSlcclxuICAgICAgICB1c2VUaGVtZSA9IGZhbHNlO1xyXG5cclxuICAgIGNvb3Jkcy5mb3JFYWNoKGNvb3JkID0+IHtcclxuICAgICAgICAvLyB1c2Ugb3Bfd2VpZ2h0IG9mIDEgZm9yIGVhY2ggY29vcmRcclxuICAgICAgICAvLyBwcm92aWRlcyBhbGwgY29vcmQgYXMgZGF0YVxyXG4gICAgICAgIGxldCBkcCA9IG5ldyBILmNsdXN0ZXJpbmcuRGF0YVBvaW50KGNvb3JkWzBdLCBjb29yZFsxXSwgMSwgY29vcmQpO1xyXG4gICAgICAgIGRhdGFQb2ludHMucHVzaChkcCk7XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IG1pbldlaWdodCA9IDI7IC8vIG1pbmltdW0gd2VpZ2h0IGJ5IGRlZmF1bHRcclxuXHJcbiAgICBpZiAodXNlVGhlbWUpIHtcclxuXHJcbiAgICAgICAgLy8gY3JlYXRpbmcgaWNvbiBmb3Igbm9pc2UgKGluZGl2aWR1YWwgcG9pbnQpXHJcbiAgICAgICAgbGV0IGljb24gPSBzZXR0aW5ncy5ub2lzZS5pY29uO1xyXG4gICAgICAgIGlmIChpY29uWzBdID09IFwiQFwiKSAvLyB0byBpbmRpY2F0ZSBsb2NhbFxyXG4gICAgICAgICAgICBpY29uID0gY20uZ2V0SG9tZSgpICsgaWNvbi5zdWJzdHIoMSk7XHJcblxyXG4gICAgICAgIGxldCBpY29uT3B0ID0gbnVsbDtcclxuICAgICAgICBpZiAoc2V0dGluZ3Mubm9pc2Uuc2l6ZSlcclxuICAgICAgICAgICAgaWNvbk9wdCA9IHtcclxuICAgICAgICAgICAgICAgIHNpemU6IHtcclxuICAgICAgICAgICAgICAgICAgICB3OiBzZXR0aW5ncy5ub2lzZS5zaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIGg6IHNldHRpbmdzLm5vaXNlLnNpemVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBpY29uTm9pc2UgPSBuZXcgSC5tYXAuSWNvbihpY29uLCBpY29uT3B0KTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IGxpc3Qgb2Ygd2VpZ2h0XHJcbiAgICAgICAgbGV0IHdlaWdodE9yZGVyID0gT2JqZWN0LmtleXMoc2V0dGluZ3MuY2x1c3Rlcikuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYiAtIGE7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gbWlud2VpZ2h0IGlzIHRoZSBzbWFsbGVzdCB3ZWlnaHRcclxuICAgICAgICBtaW5XZWlnaHQgPSB3ZWlnaHRPcmRlclt3ZWlnaHRPcmRlci5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAgICAgbGV0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgY2x1c3RlclN0eWxlID0gd2VpZ2h0T3JkZXIubWFwKCh3ZWlnaHQpID0+IHtcclxuICAgICAgICAgICAgbGV0IHNpemUgPSBzZXR0aW5ncy5jbHVzdGVyW3dlaWdodF0uc2l6ZTtcclxuICAgICAgICAgICAgbGV0IGljb24gPSBzZXR0aW5ncy5jbHVzdGVyW3dlaWdodF0uaWNvbjtcclxuICAgICAgICAgICAgaWYgKGljb25bMF0gPT0gXCJAXCIpIC8vIHRvIGluZGljYXRlIGxvY2FsXHJcbiAgICAgICAgICAgICAgICBpY29uID0gY20uZ2V0SG9tZSgpICsgaWNvbi5zdWJzdHIoMSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgcCA9IGxvYWRJY29uRmlsZShpY29uLCBzaXplLCBzaXplKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwKTtcclxuICAgICAgICAgICAgbGV0IGVudHJ5ID0ge1xyXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiBwYXJzZUludCh3ZWlnaHQpLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogaWNvblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIHdhaXQgZm9yIGFsbCBwcm9taXNlcyB0byBiZSByZXNvbHZlZFxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICAvLyBhc3NvY2lhdGVkIHRvIGVhY2ggZW50cnkgb2YgY2x1c3RlcnN0eWxlXHJcbiAgICAgICAgcmVzdWx0LmZvckVhY2goKGltYWdlRGF0YSwgaSkgPT4ge1xyXG4gICAgICAgICAgICBjbHVzdGVyU3R5bGVbaV0uaW1hZ2VEYXRhID0gaW1hZ2VEYXRhO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgbGV0IG9wdFByb3ZpZGVyID0ge1xyXG4gICAgICAgIGNsdXN0ZXJpbmdPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIC8vIE1heGltdW0gcmFkaXVzIG9mIHRoZSBuZWlnaGJvcmhvb2RcclxuICAgICAgICAgICAgZXBzOiBzZXR0aW5ncy5lcHMsXHJcbiAgICAgICAgICAgIC8vIG1pbmltdW0gd2VpZ2h0IG9mIHBvaW50cyByZXF1aXJlZCB0byBmb3JtIGEgY2x1c3RlclxyXG4gICAgICAgICAgICBtaW5XZWlnaHQ6IG1pbldlaWdodFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWluOiBzZXR0aW5ncy5taW5ab29tLCAvLyBtaW4gem9vbVxyXG4gICAgICAgIG1heDogc2V0dGluZ3MubWF4Wm9vbSAvLyBtYXggem9vbVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBpZiB3ZSB1c2Ugb3VyIG93biB0aGVtZVxyXG4gICAgaWYgKHVzZVRoZW1lKVxyXG4gICAgICAgIG9wdFByb3ZpZGVyLnRoZW1lID0ge1xyXG4gICAgICAgICAgICBnZXRDbHVzdGVyUHJlc2VudGF0aW9uOiBnZXRDbHVzdGVyUHJlc2VudGF0aW9uLFxyXG4gICAgICAgICAgICBnZXROb2lzZVByZXNlbnRhdGlvbjogZ2V0Tm9pc2VQcmVzZW50YXRpb25cclxuICAgICAgICB9O1xyXG5cclxuICAgIC8vIGNyZWF0ZSBjbHVzdGVyIHByb3ZpZGVyXHJcbiAgICBjbHVzdGVyZWREYXRhUHJvdmlkZXIgPSBuZXcgSC5jbHVzdGVyaW5nLlByb3ZpZGVyKGRhdGFQb2ludHMsIG9wdFByb3ZpZGVyKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYSBsYXllciB0aGF0IGluY2x1ZGVzIHRoZSBkYXRhIHByb3ZpZGVyIGFuZCBpdHMgZGF0YSBwb2ludHM6XHJcbiAgICBjbHVzdGVyTGF5ZXIgPSBuZXcgSC5tYXAubGF5ZXIuT2JqZWN0TGF5ZXIoY2x1c3RlcmVkRGF0YVByb3ZpZGVyKTtcclxuICAgIC8vIEFkZCB0aGUgbGF5ZXIgdG8gdGhlIG1hcDpcclxuICAgIG1hcC5hZGRMYXllcihjbHVzdGVyTGF5ZXIpO1xyXG5cclxuICAgIC8vIGxheWVyIGlzIHZpc2libGUgYnkgZGVmYXVsdFxyXG4gICAgX3Zpc2libGUgPSB0cnVlO1xyXG5cclxuICAgIC8vIGlmIGEgY2FsbGJhY2sgaXMgZGVmaW5lZCwgYWRkIGV2ZW50IGxpc3RlbmVyXHJcbiAgICBpZiAoY2IpIHtcclxuICAgICAgICBjbHVzdGVyZWREYXRhUHJvdmlkZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRhcFwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgLy8gTG9nIGRhdGEgYm91bmQgdG8gdGhlIG1hcmtlciB0aGF0IGhhcyBiZWVuIHRhcHBlZDpcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBldi50YXJnZXQuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBtYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBsZXQgaXNDbHVzdGVyID0gZGF0YS5pc0NsdXN0ZXIoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc0NsdXN0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGxldCB3ZWlndGggPSBkYXRhLmdldFdlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgY2IoZXYsIG0uY29vcmRPMkEoY29vcmQpLCBudWxsLCB3ZWlndGgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IHVzZXJEYXRhID0gZGF0YS5nZXREYXRhKCk7IC8vIGxhdCxsbmcsIHBheWxvYWRcclxuICAgICAgICAgICAgICAgIGNiKGV2LCBtLmNvb3JkTzJBKGNvb3JkKSwgdXNlckRhdGFbMl0sIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNsdXN0ZXJMYXllcjtcclxufVxyXG5cclxuXHJcblxyXG4vLyB0aGlzIGZ1bmN0aW9uICBjcmVhdGVzIHRoZSBpY29uIGZvciBhIGNsdXN0ZXJcclxuZnVuY3Rpb24gZ2V0Q2x1c3RlclByZXNlbnRhdGlvbihjbHVzdGVyKSB7XHJcblxyXG4gICAgLy8gYnVpbGRpbmcgZGF0YSBvYmplY3Qgd2hpY2ggd2lsbCBiZSByZXR1cm5lZCB3aGVuIGNsaWNraW5nIG9uIHRoZSBpY29uXHJcbiAgICBsZXQgZGF0YSA9IHt9O1xyXG4gICAgZGF0YS5pc0NsdXN0ZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9OyAvLyBzbyB3ZSBrbm93IGl0IGlzIGEgY2x1c3RlclxyXG4gICAgbGV0IHdlaWdodCA9IGNsdXN0ZXIuZ2V0V2VpZ2h0KCk7XHJcblxyXG4gICAgZGF0YS5nZXRXZWlnaHQgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHdlaWdodDtcclxuICAgIH07IC8vIG51bWJlciBvZiBpbmRpdmlkdWFsIGl0ZW0gY2x1c3RlcmVkIHRvZ2V0aGVyXHJcblxyXG4gICAgLy8gbGV0J3MgZmluZCB0aGUgcmVsZXZhbnQgY29sb3IgYW5kIHNpemVcclxuICAgIGxldCBlbnRyeSA9IGNsdXN0ZXJTdHlsZS5maW5kKGVsdCA9PiAod2VpZ2h0ID49IGVsdC53ZWlnaHQpKTtcclxuICAgIGxldCBpbWFnZURhdGEgPSBlbnRyeS5pbWFnZURhdGE7XHJcblxyXG4gICAgbGV0IGljb24gPSBidWlsZENsdXN0ZXJJY29uKGltYWdlRGF0YSwgXCJcIiArIHdlaWdodCk7XHJcbiAgICAvLyBjcmVhdGUgYSBtYXJrZXIgZm9yIHRoZSBDbHVzdGVyXHJcbiAgICBsZXQgbWluID0gY2x1c3Rlci5nZXRNaW5ab29tKCk7XHJcbiAgICBsZXQgbWF4ID0gY2x1c3Rlci5nZXRNYXhab29tKCk7XHJcbiAgICBsZXQgY2x1c3Rlck1hcmtlciA9IG5ldyBILm1hcC5NYXJrZXIoY2x1c3Rlci5nZXRQb3NpdGlvbigpLCB7XHJcbiAgICAgICAgLy8gdG8gc2hvdyBpdCBjb3JyZWN0bHkgYXQgY2VydGFpbiB6b29tIGxldmVsczpcclxuICAgICAgICBtaW46IG1pbixcclxuICAgICAgICBtYXg6IG1heCxcclxuICAgICAgICBpY29uOiBpY29uLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTGluayBkYXRhIGZyb20gdGhlIGZyb20gdGhlIGNsdXN0ZXIgdG8gdGhlIG1hcmtlcixcclxuICAgIC8vIHRvIG1ha2UgaXQgYWNjZXNzaWJsZSBvbiBjYWxsYmFja1xyXG4gICAgY2x1c3Rlck1hcmtlci5zZXREYXRhKGRhdGEpO1xyXG5cclxuICAgIHJldHVybiBjbHVzdGVyTWFya2VyO1xyXG59XHJcblxyXG4vLyBmdW5jdGlvbiB0byByZXByZXNlbnQgYSBzaW5nbGUgaXRlbVxyXG5mdW5jdGlvbiBnZXROb2lzZVByZXNlbnRhdGlvbihub2lzZVBvaW50KSB7XHJcblxyXG4gICAgLy8gZGF0YSB0byBiZSBzZW50IG9uIGNhbGxiYWNrXHJcbiAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgIGdldERhdGE6ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vaXNlUG9pbnQuZ2V0RGF0YSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNDbHVzdGVyOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFdlaWdodDogKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIG1hcmtlciBmb3IgdGhlIG5vaXNlUG9pbnRcclxuICAgIHZhciBub2lzZU1hcmtlciA9IG5ldyBILm1hcC5NYXJrZXIobm9pc2VQb2ludC5nZXRQb3NpdGlvbigpLCB7XHJcbiAgICAgICAgLy8gVXNlIG1pbiB6b29tIGZyb20gYSBub2lzZSBwb2ludFxyXG4gICAgICAgIC8vIHRvIHNob3cgaXQgY29ycmVjdGx5IGF0IGNlcnRhaW4gem9vbSBsZXZlbHM6XHJcbiAgICAgICAgbWluOiBub2lzZVBvaW50LmdldE1pblpvb20oKSxcclxuICAgICAgICBpY29uOiBpY29uTm9pc2VcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIExpbmsgYSBkYXRhIGZyb20gdGhlIHBvaW50IHRvIHRoZSBtYXJrZXJcclxuICAgIC8vIHRvIG1ha2UgaXQgYWNjZXNzaWJsZSBvbiBjYWxsYmFja1xyXG4gICAgbm9pc2VNYXJrZXIuc2V0RGF0YShkYXRhKTtcclxuXHJcbiAgICByZXR1cm4gbm9pc2VNYXJrZXI7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIGxvYWQgYSBmaWxlIGludG8gYSBjYW52YXNcclxuICogQGlnbm9yZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIG9mIHBuZyxqcGcsc3ZnIGZpbGUgXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBmb3Igc3ZnLCBkZWZpbmUgd2lkdGhcclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBmb3Igc3ZnLCBkZWZpbmUgaGVpZ2h0XHJcbiAqL1xyXG5mdW5jdGlvbiBsb2FkSWNvbkZpbGUoZmlsZSwgd2lkdGggPSBudWxsLCBoZWlnaHQgPSBudWxsKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoXHJcbiAgICAgICAgKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgdmFyIG5ld0ltZyA9IG5ldyBJbWFnZTtcclxuICAgICAgICAgICAgbmV3SW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IG5ld0ltZy53aWR0aDtcclxuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBuZXdJbWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgLy8gY29weSBpY29uIGludG8gYSBjYW52YXNcclxuICAgICAgICAgICAgICAgIGxldCBzcmMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgICAgICAgICAgc3JjLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICBzcmMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgbGV0IGN0eCA9IHNyYy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29weSBpbWFnZSBpbnRvIGNhbnZhcyBjbHVzdGVyXHJcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKG5ld0ltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGltYWdlRGF0YSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBuZXdJbWcuY3Jvc3NPcmlnaW4gPSBcIkFub255bW91c1wiOyAvLyB1c2VmdWwuLiA/XHJcbiAgICAgICAgICAgIGlmICh3aWR0aCkgbmV3SW1nLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgIGlmIChoZWlnaHQpIG5ld0ltZy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBuZXdJbWcuc3JjID0gZmlsZTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIGFuIGljb24gYnkgY29weWluZyBpbWFnZURhdGEgYW5kIGFkZGluZyB0ZXh0XHJcbiAqIEBpZ25vcmVcclxuICogQHBhcmFtIHsqfSBpbWdEYXRhICBmcm9tIGNhbnZhcy5nZXRJbWFnZURhdGFcclxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgIHRleHQgdG8gd3JpdGVcclxuICogQHBhcmFtIHsqT2JqZWN0fSB0ZXh0UG9zICBwb3NpdGlvbiBvZiB0ZXh0IGFzIHt4LHl9XHJcbiAqL1xyXG5mdW5jdGlvbiBidWlsZENsdXN0ZXJJY29uKGltZ0RhdGEsIHRleHQpIHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICBjYW52YXMud2lkdGggPSBpbWdEYXRhLndpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xyXG4gICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICBjb25zdCBmb250U2l6ZSA9IDEyO1xyXG5cclxuICAgIGN0eC5mb250ID0gXCJib2xkIFwiICsgZm9udFNpemUgKyBcInB4IEFyaWFsXCI7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4gICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcblxyXG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcclxuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBjYW52YXMud2lkdGggLyAyLCAoY2FudmFzLmhlaWdodCArIGZvbnRTaXplKSAvIDIgLSAyKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IEgubWFwLkljb24oY2FudmFzLCB7XHJcbiAgICAgICAgYW5jaG9yOiB7XHJcbiAgICAgICAgICAgIHg6IGNhbnZhcy53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgIHk6IGNhbnZhcy5oZWlnaHQgLyAyXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEhpZGUgY2x1c3RlciBsYXllclxyXG4gKiAgQGFsaWFzIGhtOmNsdXN0ZXJIaWRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjbHVzdGVySGlkZSgpIHtcclxuICAgIGlmICghX3Zpc2libGUgfHwgIWNsdXN0ZXJMYXllcilcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgbWFwLnJlbW92ZUxheWVyKGNsdXN0ZXJMYXllcik7XHJcbiAgICBfdmlzaWJsZSA9IGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogc2hvdyBDbHVzdGVyIGxheWVyXHJcbiAqIEBhbGlhcyBobTpjbHVzdGVyU2hvd1xyXG4gKi9cclxuZnVuY3Rpb24gY2x1c3RlclNob3coKSB7XHJcbiAgICBpZiAoX3Zpc2libGUgfHwgIWNsdXN0ZXJMYXllcilcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgbWFwLmFkZExheWVyKGNsdXN0ZXJMYXllcik7XHJcbiAgICBfdmlzaWJsZSA9IHRydWU7XHJcblxyXG59XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY2x1c3RlcjogY2x1c3RlcixcclxuICAgIGNsdXN0ZXJTaG93OiBjbHVzdGVyU2hvdyxcclxuICAgIGNsdXN0ZXJIaWRlOiBjbHVzdGVySGlkZVxyXG59OyIsIlwidXNlIHN0cmljdFwiO1xyXG4vKiBnbG9iYWwgZG9jdW1lbnQgKi9cclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBnZW5lcmljIGZ1bmN0aW9uIG9mIGhlcmVtYXBcclxuICogQGF1dGhvciBkZXZiYWJcclxuICovXHJcblxyXG5jb25zdCByZXF1ZXN0ID0gcmVxdWlyZShcInN1cGVyYWdlbnRcIik7XHJcblxyXG4vLyBieSBkZWZhdWx0LCB1bmxlc3Mgc3BlY2lmaWVkIGZieSBjYWxsaW5nIGNvbmZpZ1xyXG4vLyBlbnZpcm9ubWVudCB1c2FibGUgd2l0aCBub2RlXHJcbmxldCBBUFBfSUQgPSBwcm9jZXNzLmVudi5BUFBfSUQ7XHJcbmxldCBBUFBfQ09ERSA9IHByb2Nlc3MuZW52LkFQUF9DT0RFO1xyXG5sZXQgQ0lUID0gXCJcIjsgLy8gcHJvZHVjdGlvbiBieSBkZWZhdWx0XHJcbmxldCBQUk9UT0NPTCA9IFwiaHR0cHM6XCI7IC8vIGJ5IGRlZmF1bHRcclxubGV0IF91c2VIVFRQUyA9IHRydWU7IC8vIGJ5IGRlZmF1bHRcclxubGV0IF9ob21lID0gXCIuXCI7XHJcblxyXG5cclxuLy8gZmluZCBvdXQgd2hlcmUgd2UgYXJlIGFuZCByZWxhdGl2ZSBwb3NpdGlvbiBmb3IgcG5nL3N2ZyBmaWxlc1xyXG4vLyBwYXkgYXR0ZW50aW9uIGlmIGxpYnJhcnkgaXMgYnVpbGQgaW4gLi9kaXN0XHJcbmlmIChwcm9jZXNzLmJyb3dzZXIpIHtcclxuICAgIGxldCBfc2NyaXB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XHJcbiAgICBsZXQgX2ZpbGUgPSBfc2NyaXB0W19zY3JpcHQubGVuZ3RoIC0gMV0uc3JjO1xyXG4gICAgbGV0IF9wYXRoID0gX2ZpbGUuc3Vic3RyaW5nKDAsIF9maWxlLmxhc3RJbmRleE9mKFwiL1wiKSk7XHJcbiAgICBsZXQgcG9zID0gX3BhdGguaW5kZXhPZihcImhlcmVtYXBcIik7XHJcbiAgICBfaG9tZSA9IF9wYXRoLnN1YnN0cmluZygwLCBwb3MgKyBcImhlcmVtYXBcIi5sZW5ndGgpICsgXCIvXCI7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogVG8gY29uZmlndXJlIGFwcF9pZCwgYXBwX2NvZGUgYW5kIG9wdGlvbmFsbHkgdXNlIENJVCBhbmQgaHR0cFxyXG4gKiBAYWxpYXMgaG06Y29uZmlnXHJcbiAqXHJcbiAqIEBwYXJhbSBvcHQge09iamVjdH0gIC0gYG9wdGAgd2l0aCBwYXJhbWV0ZXJzLlxyXG4gKiBAcGFyYW0gW29wdC5hcHBfaWRdIHtzdHJpbmd9IC0gdGhlIGFwcF9pZCBmcm9tIGRldmVsb3Blci5oZXJlLmNvbVxyXG4gKiBAcGFyYW0gW29wdC5hcHBfY29kZV0ge3N0cmluZ30gLSB0aGUgYXBwX2NvZGUgZnJvbSBkZXZlbG9wZXIuaGVyZS5jb21cclxuICogQHBhcmFtIFtvcHQudXNlQ0lUPWZhbHNlXSB7Ym9vbGVhbn0gLSB0cnVlIHRvIHVzZSBDSVQgZW52aXJvbm1lbnQuIFxyXG4gKiBAcGFyYW0gW29wdC51c2VIVFRQPWZhbHNlXSB7c3RyaW5nfSAtIHRydWUgdG8gdXNlIEhUVFAuIFxyXG4gKiBAcGFyYW0gW29wdC51c2VIVFRQUz10cnVlXSB7c3RyaW5nfSAtIHRydWUgdG8gdXNlIEhUVFBTLiBcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogIGhtLmNvbmZpZyh7XHJcbiAqICAgICAgYXBwX2lkOiBcIllPVVIgQVBQX0lEXCIsXHJcbiAqICAgICAgYXBwX2NvZGU6IFwiWU9VUiBBUFBfQ09ERVwiLFxyXG4qICAgfSk7XHJcbiogIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gY29uZmlnKG9wdCkge1xyXG4gICAgaWYgKG9wdC5hcHBfaWQpIEFQUF9JRCA9IG9wdC5hcHBfaWQ7XHJcbiAgICBpZiAob3B0LmFwcF9jb2RlKSBBUFBfQ09ERSA9IG9wdC5hcHBfY29kZTtcclxuICAgIGlmIChvcHQudXNlQ0lUKSBDSVQgPSBcIi5jaXRcIjtcclxuICAgIGlmIChvcHQudXNlSFRUUCkge1xyXG4gICAgICAgIFBST1RPQ09MID0gXCJodHRwOlwiO1xyXG4gICAgICAgIF91c2VIVFRQUyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdC51c2VIVFRQUykge1xyXG4gICAgICAgIFBST1RPQ09MID0gXCJodHRwczpcIjtcclxuICAgICAgICBfdXNlSFRUUFMgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogcmV0dXJuIFVSTCBvZiBtb2R1bGUgaG9tZSBkaXJlY3RvcnkuIFxyXG4gKiBzdmcgaWNvbnMgYXJlIHVuZGVyIGdldEhvbWUoKStcIi9zdmcvXCJcclxuICogaW1hZ2VzIGFyZSB1bmRlciBnZXRIb21lKCkrXCIvaW1nL1wiXHJcbiAqIEBpZ25vcmVcclxuICogIEBhbGlhcyBobTpnZXRIb21lXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gdXJsIG9mIGhvbWUgZGlyZWN0b3J5IGluY2x1ZGluZyBodHRwIG9yIGh0dHBzLiBcclxuICovXHJcbmZ1bmN0aW9uIGdldEhvbWUoKSB7XHJcbiAgICByZXR1cm4gX2hvbWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm5zIGFwcF9pZFxyXG4gKiBAaWdub3JlXHJcbiAqICBAYWxpYXMgaG06Z2V0QXBwSWRcclxuICogQHJldHVybiB7c3RyaW5nfSBhcHBfaWRcclxuKi9cclxuZnVuY3Rpb24gZ2V0QXBwSWQoKSB7XHJcbiAgICByZXR1cm4gQVBQX0lEO1xyXG59XHJcblxyXG4vKipcclxuICogcmV0dXJuIGFwcF9jb2RlXHJcbiAqICBAaWdub3JlXHJcbiAqICBAYWxpYXMgaG06Z2V0SG9tZVxyXG4gKiAgQGFsaWFzIGhtOmdldEFwcENvZGVcclxuICAqIEByZXR1cm4ge3N0cmluZ30gYXBwX2NvZGVcclxuKi9cclxuZnVuY3Rpb24gZ2V0QXBwQ29kZSgpIHtcclxuICAgIHJldHVybiBBUFBfQ09ERTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHJldHVybiB0cnVlIGlmIHVzaW5nIENJVFxyXG4gKiBAaWdub3JlXHJcbiAqIEBhbGlhcyBobTpnZXRDSVRcclxuICogQHJldHVybiB7Ym9vb2xlYW59IHRydWUgaWYgdXNpbmcgQ0lUXHJcbiovXHJcbmZ1bmN0aW9uIGdldENJVCgpIHtcclxuICAgIHJldHVybiBDSVQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gcHJvdG9jb2wgdXNlZCwgaHR0cDovLyBvciBodHRwczovL1xyXG4gKiBAaWdub3JlXHJcbiAqIEBhbGlhcyBobTpnZXRQcm90b2NvbFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gcHJvdG9jb2xcclxuKi9cclxuZnVuY3Rpb24gZ2V0UHJvdG9jb2woKSB7XHJcbiAgICByZXR1cm4gUFJPVE9DT0w7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gdHJ1ZSBpcyBodHRwcyBpcyB1c2VkXHJcbiAqIEBpZ25vcmVcclxuICogIEBhbGlhcyBobTp1c2VIVFRQU1xyXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIHRydWUgaWYgaHR0cHMgaXMgdXNlZFxyXG4qL1xyXG5mdW5jdGlvbiB1c2VIVFRQUygpIHtcclxuICAgIHJldHVybiBfdXNlSFRUUFM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBhZGQgY3JlZGVudGlhbHMgdG8gb2JqZWN0IHByb3ZpZGVkXHJcbiAgKiBAaWdub3JlXHJcbiAqICBAYWxpYXMgaG06YWRkQ3JlZGVudGlhbHNcclxuICogQHBhcmFtICB7Li4ub2JqZWN0c30gbGlzdCBvZiBgb2JqZWN0c2AgXHJcbiAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0IHdpdGggYWxsIGlucHV0IG9iamVjdGNvbmNhdGVuYXRlZCwgYW5kIGFwcF9pZC9hcHBfY29kZSBpbnNlcnRlZFxyXG4gKi9cclxuZnVuY3Rpb24gYWRkQ3JlZGVudGlhbHMoLi4ub2JqKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgYXBwX2lkOiBBUFBfSUQsXHJcbiAgICAgICAgYXBwX2NvZGU6IEFQUF9DT0RFXHJcbiAgICB9LCAuLi5vYmopO1xyXG59XHJcblxyXG4vKipcclxuICogYnVpbGQgSEVSRSBSRVNUIGZ1bGwgdXJsLCB0YWtpbmcgaW4gYWNjb3VudCBwcm90b2NvbCBhbmQgY2l0LiBmb3IgaW5zdGFuY2UgIGNtLmJ1aWxkVXJsKFwiZ2VvY29kZXJcIiwgXCJhcGkuaGVyZS5jb20vNi4yL2dlb2NvZGUuanNvblwiXHJcbiAqIEBpZ25vcmVcclxuICogQGFsaWFzIGhtOmJ1aWxkVXJsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIC0gYmFzZSBuYW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIGVuZCBwb2ludFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGZ1bGwgdXJsXHJcbiAqL1xyXG5mdW5jdGlvbiBidWlsZFVybChiYXNlLCBlbmRwb2ludCkge1xyXG4gICAgcmV0dXJuIFBST1RPQ09MICsgXCIvL1wiICsgYmFzZSArIENJVCArIFwiLlwiICsgZW5kcG9pbnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBkb2VzIGdldC9wb3N0IHJlcXVlc3QgdG8gSEVSRSBSRVNEVCBiYWNrZW5kIGFuZCBtYW5hZ2UgbWFpbiBlcnJvcnNcclxuICogQGlnbm9yZVxyXG4gKiBAYWxpYXMgaG06aGVyZVJlc3RcclxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAgLSB1cmwgdG8gY2FsbCAsIGZvciBpbnN0YW5jZSBmcm9tIGJ1aWxkVXJsXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyAtIHNldHRpbmdzIHRvIGFkZCBpbiByZXF1ZXN0XHJcbiAqIEBwYXJhbSAge3N0cmluZ30gbW9kZT1nZXQgLSBtb2RlIFwiZ2V0XCIgb3IgXCJwb3N0XCJcclxuICogQHJldHVybiB7cHJvbWlzZX0gLSBwcm9taXNlIHRvIHJlc29sdmUvcmVqZWN0XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBoZXJlUmVzdCh1cmwsIHNldHRpbmdzLCBtb2RlID0gXCJnZXRcIiwgbmVlZHJlc3AgPSBcInRydWVcIikge1xyXG5cclxuICAgIGxldCBwID0gcmVxdWVzdC5nZXQodXJsKTtcclxuICAgIGlmIChtb2RlID09IFwicG9zdFwiKVxyXG4gICAgICAgIHAgPSByZXF1ZXN0LnBvc3QodXJsKTtcclxuXHJcbiAgICByZXR1cm4gcFxyXG4gICAgICAgIC5xdWVyeShzZXR0aW5ncylcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICAvLyByZXMuYm9keSwgcmVzLmhlYWRlcnMsIHJlcy5zdGF0dXNcclxuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT0gXCIyMDBcIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJFcnJvciBcIiArIHJlcy5zdGF0dXMgKyBcIjpcIiArIHJlcy5ib2R5KTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChuZWVkcmVzcCAmJiAhcmVzLmJvZHkuUmVzcG9uc2UgJiYgIXJlcy5ib2R5LnJlc3BvbnNlKSB7IC8vIG9uZSBvZiB0aGUgdHdvIHNob3VsZCBiZSBpbiB0aGUgYW5zd2VyXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcy5ib2R5KTtcclxuICAgICAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiUXVlcnkgZXJyb3I6XCIgKyByZXMuYm9keSk7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzLmJvZHkucmVzcG9uc2UgJiYgcmVzLmJvZHkucmVzcG9uc2UudHlwZSA9PSBcIkFwcGxpY2F0aW9uRXJyb3JcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMuYm9keSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIkVycm9yXCIgKyByZXMuYm9keS5yZXNwb25zZS5kZXRhaWxzKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY29uZmlnOiBjb25maWcsXHJcbiAgICBidWlsZFVybDogYnVpbGRVcmwsXHJcbiAgICBnZXRBcHBJZDogZ2V0QXBwSWQsXHJcbiAgICBnZXRBcHBDb2RlOiBnZXRBcHBDb2RlLFxyXG4gICAgZ2V0Q0lUOiBnZXRDSVQsXHJcbiAgICBnZXRQcm90b2NvbDogZ2V0UHJvdG9jb2wsXHJcbiAgICBnZXRIb21lOiBnZXRIb21lLFxyXG4gICAgdXNlSFRUUFM6IHVzZUhUVFBTLFxyXG4gICAgYWRkQ3JlZGVudGlhbHM6IGFkZENyZWRlbnRpYWxzLFxyXG4gICAgaGVyZVJlc3Q6IGhlcmVSZXN0XHJcbn07IiwiLyoqXHJcbiAqIEBmaWxlIEdlb2NvZGluZyBmdW5jdGlvbnMgOiBhZGRyZXNzZXMgPC0tPiBbbGF0LGxuZ11cclxuICogQGF1dGhvciBEZXZiYWIgXHJcbiAqL1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmNvbnN0IGNtID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIGdlb2NvZGUgYW4gYWRkcmVzc1xyXG4gKiBAYWxpYXMgaG06Z2VvY29kZVxyXG4gKiBAcGFyYW0gYWRkcmVzcyB7c3RyaW5nfSAgYWRkcmVzcyBhcyBzdHJpbmdcclxuICogQHJldHVybnMgIHtQcm9taXNlfSAgIHtjb29yZCxib2R5fS4gY29vcmQgaXMgZ2VvY29kZSBhcyBcXFtsYXQsbG5nXFxdLiBib2R5IGlzIGZ1bGwganNvbiBhbnN3ZXJcclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IHJlcyA9IGF3YWl0IGhtLmdlb2NvZGUoXCJhdmVudWUgZGVzIGNoYXBzIGVseXNlZXMsIHBhcmlzXCIpO1xyXG4gKiBjb25zb2xlLmxvZyAocmVzLmNvb3JkKTtcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW9jb2RlKGFkZHJlc3MpIHtcclxuXHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IGNtLmFkZENyZWRlbnRpYWxzKHtcclxuICAgICAgICBzZWFyY2hUZXh0OiBhZGRyZXNzXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1cmwgPSBjbS5idWlsZFVybChcImdlb2NvZGVyXCIsIFwiYXBpLmhlcmUuY29tLzYuMi9nZW9jb2RlLmpzb25cIik7XHJcbiAgICByZXR1cm4gY20uaGVyZVJlc3QodXJsLCBzZXR0aW5ncylcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlcy5ib2R5LlJlc3BvbnNlLlZpZXcubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiR2VvY29kZSBBZGRyZXNzIG5vdCBmb3VuZDogXCIgKyBhZGRyZXNzKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHJlcy5ib2R5LlJlc3BvbnNlLlZpZXdbMF0uUmVzdWx0WzBdLkxvY2F0aW9uO1xyXG4gICAgICAgICAgICB2YXIgY29vcmQgPSBbbG9jYXRpb24uTmF2aWdhdGlvblBvc2l0aW9uWzBdLkxhdGl0dWRlLCBsb2NhdGlvbi5OYXZpZ2F0aW9uUG9zaXRpb25bMF0uTG9uZ2l0dWRlXTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgY29vcmQ6IGNvb3JkLCBib2R5OiByZXMuYm9keSB9O1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIHJldmVyc2UgZ2VvY29kZSBhIGNvb3JkaW5hdGVcclxuICogQGFsaWFzIGhtOnJldmVyc2VHZW9jb2RlXHJcbiAqIEBwYXJhbSBjb29yZCB7Q29vcmR9ICAtIGNvb3JkIFxcW2xhdCxsbmdcXF0gdG8gcmV2ZXJzZS1nZW9jb2RlXHJcbiAqIEByZXR1cm5zICB7UHJvbWlzZX0gcmV0dXJucyB7IGxvY2F0aW9uOm9iamVjdCwgYWRkcmVzczpvYmplY3QsIGJvZHk6b2JqZWN0fS4gXHJcbiAqL1xyXG5mdW5jdGlvbiByZXZlcnNlR2VvY29kZShjb29yZCkge1xyXG5cclxuICAgIGNvbnN0IHNldHRpbmdzID0gY20uYWRkQ3JlZGVudGlhbHMoe1xyXG4gICAgICAgIG1vZGU6IFwicmV0cmlldmVBZGRyZXNzZXNcIixcclxuICAgICAgICBwcm94OiBjb29yZFswXSArIFwiLFwiICsgY29vcmRbMV1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwicmV2ZXJzZS5nZW9jb2RlclwiLCBcImFwaS5oZXJlLmNvbS82LjIvcmV2ZXJzZWdlb2NvZGUuanNvblwiKTtcclxuXHJcbiAgICByZXR1cm4gY20uaGVyZVJlc3QodXJsLCBzZXR0aW5ncylcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICAvLyByZXMuYm9keSwgcmVzLmhlYWRlcnMsIHJlcy5zdGF0dXNcclxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmJvZHkuUmVzcG9uc2UuVmlld1swXS5SZXN1bHRbMF0uTG9jYXRpb247XHJcbiAgICAgICAgICAgIHJldHVybiAoeyBsb2NhdGlvbjogbG9jYXRpb24sIGFkZHJlc3M6IGxvY2F0aW9uLkFkZHJlc3MsIGJvZHk6IHJlcy5ib2R5IH0pO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBnZW9jb2RlOiBnZW9jb2RlLFxyXG4gICAgcmV2ZXJzZUdlb2NvZGU6IHJldmVyc2VHZW9jb2RlXHJcbn07XHJcblxyXG4iLCJjb25zdCBzaW1wbGlmeUpzID0gcmVxdWlyZShcInNpbXBsaWZ5LWpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYXJyYXkgb2YgW2xhdCxsbmddIHRvIGFycmF5IG9mIHt4LHl9XHJcbiAqIEBhbGlhcyBobTpjb29yZHMyWFlcclxuICogQHBhcmFtIHthcnJheX0gY29vcmRzIGFycmF5IG9mIFtsYXQsbG5nXVxyXG4gKiBAcmV0dXJuIHthcnJheX1hcnJheSBvZiB7eCx5fVxyXG4gKi9cclxuZnVuY3Rpb24gY29vcmRzMlhZKGNvb3Jkcykge1xyXG4gICAgcmV0dXJuIGNvb3Jkcy5tYXAoY29vcmQgPT4geyByZXR1cm4geyB4OiBjb29yZFsxXSwgeTogY29vcmRbMF0gfTsgfSk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnQgYXJyYXkgb2Yge3gseX0gdG8gYXJyYXkgb2YgW2xhdCxsbmddXHJcbiAqIEBhbGlhcyBobTp4eTJDb29yZHNcclxuICogQHBhcmFtIHthcnJheX0gY29vcmRzIGFycmF5IG9mIHt4LHl9IFxyXG4gKiBAcmV0dXJuIHthcnJheX1hcnJheSBvZiBbbGF0LGxuZ11cclxuICovXHJcbmZ1bmN0aW9uIHh5MkNvb3Jkcyh4eXMpIHtcclxuICAgIHJldHVybiB4eXMubWFwKHh5ID0+IFt4eS55LCB4eS54XSk7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogU2ltcGxpZnkgYSBwb2x5bGluZSBieSB1c2luZyB0aGUgUmFtZXItRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobVxyXG4gKiBAYWxpYXMgaG06c2ltcGxpZnlcclxuICogQHBhcmFtIHthcnJheX0gY29vcmRzIGFycmF5IG9mIFtsYXQsbG5nXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFxyXG4gKiBAcmV0dXJuIHthcnJheX0gc2ltcGxpZmllZCBwb2x5bGluZVxyXG4gKi9cclxuZnVuY3Rpb24gc2ltcGxpZnkoY29vcmRzLCB0b2xlcmFuY2UsIGhpZ2hhY2MgPSBmYWxzZSkge1xyXG5cclxuICAgIC8vIGNvbnZlcnQgdG8geHlcclxuICAgIGxldCB4eSA9IGNvb3JkczJYWShjb29yZHMpO1xyXG4gICAgbGV0IHNpbXBsaWZpZWQgPSBzaW1wbGlmeUpzKHh5LCB0b2xlcmFuY2UsIGhpZ2hhY2MpO1xyXG5cclxuICAgIGlmIChzaW1wbGlmaWVkLmxlbmd0aCA8IDEpIC8vIG5vdCBlbm91Z2ggcG9pbnRzXHJcbiAgICAgICAgcmV0dXJuIGNvb3JkcztcclxuXHJcbiAgICAvLyBjb252ZXJ0IGJhY2sgdG8gW2xhdCxsbmddXHJcbiAgICByZXR1cm4geHkyQ29vcmRzKHNpbXBsaWZpZWQpO1xyXG59XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY29vcmRzMlhZOiBjb29yZHMyWFksXHJcbiAgICB4eTJDb29yZHM6IHh5MkNvb3JkcyxcclxuICAgIHNpbXBsaWZ5OiBzaW1wbGlmeVxyXG59OyIsIi8qIGdsb2JhbCBILCBmZXRjaCwgZG9jdW1lbnQsIG5hdmlnYXRvciwgbWFwc2pzLCB3aW5kb3cgQVBQX0lEX0pBUEFOLEFQUF9DT0RFX0pBUEFOLEFQUF9JRF9LT1JFQSxBUFBfQ09ERV9LT1JFQSovXHJcblxyXG4vKipcclxuICogQGZpbGUgbWFuYWdlcyBtYXAgZGlzcGxheSBvbiBhIHdlYiBjYW52YXNcclxuICogQGF1dGhvciBkZXZiYWJcclxuICovXHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuY29uc3QgY20gPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XHJcblxyXG5sZXQgX3BsYXRmb3JtID0gbnVsbDtcclxubGV0IF9wcm92aWRlciA9IG51bGw7XHJcbmxldCBfZGVmYXVsdExheWVycyA9IG51bGw7XHJcbmxldCBfdWkgPSBudWxsO1xyXG5sZXQgX21hcCA9IG51bGw7XHJcbmxldCBfYmVoYXZpb3IgPSBudWxsO1xyXG5sZXQgZ3JvdXAgPSBudWxsO1xyXG5sZXQgX2xheWVycyA9IFtdOyAvLyBsaXN0IGFsbCBsYXllcnNcclxubGV0IF9rZXkgPSB7fTsgLy8ga2V5cyAgXHJcbmxldCBfYnViYmxlTWFya2VyID0gbnVsbDsgLy8gYnViYmxlIGRlIG1hbXJrZXJcclxubGV0IF9zY2hlbWUgPSBcIm5vcm1hbC5kYXkuZ3JleVwiO1xyXG5sZXQgX2xvY2F0ZU1lID0gbnVsbDsgLy8gaWQgd2hlbiBsb2NhdGUgaXMgYWN0aXZlXHJcbmxldCBfaHRtbEl0ZW0gPSBudWxsOyAvL3RoZSBodG1sIGl0ZW0gb24gd2hpY2ggdG8gcHV0IHRoZSBtYXBcclxuXHJcblxyXG5mdW5jdGlvbiBjb29yZE8yQShvYmopIHtcclxuICAgIHJldHVybiBbb2JqLmxhdCwgb2JqLmxuZ107XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvb3JkQTJPKGFycikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsYXQ6IGFyclswXSxcclxuICAgICAgICBsbmc6IGFyclsxXVxyXG4gICAgfTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgYSBtYXAgYXJlYSB3aXRoaW4gdGhlIHNwZWNpZmllZCBpdGVtXHJcbiAgKiBAYWxpYXMgaG06bWFwXHJcblxyXG4gKiBAcGFyYW0gaHRtbEl0ZW0ge3N0cmluZ30gIC0gaWRlbnRpZmllciBvZiBodG1sIGRpdiBpdGVtIG9uIHdoaWNoIHRvIGluc2VydCBtYXBcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSAgLSBvcHRpb25zXHJcbiAqIEBwYXJhbSBbb3B0Lnpvb209MTBdIHtudW1iZXJ9ICAtIHpvb20gZmFjdG9yXHJcbiAqIEBwYXJhbSBbb3B0LmNlbnRlcj1bNDguODYsIDIuM11dIHtDb29yZH0gIC0gQ29vcmQgb2YgdGhlIGNlbnRlclxyXG4gKiBAcGFyYW0gW29wdC5zY2hlbWU9bm9ybWFsLmRheS5ncmV5XSB7c3RyaW5nfSAgLSBhbnkgc2NoZW1lIGRlZmluZWQgYnkgSEVSRSwgcGx1cyBcImphcGFuXCIsIFwia29yZWFcIiwgXCJibGFja1wiLCBcIndoaXRlXCIsIFwidHJhbnNwYXJlbnRcIi4gRm9yIGphcGFuL2tvcmVhLCBvbmUgbmVlZHMgc3BlY2lhbCBjcmVkZW50aWFscyBhcyBBUFBfW0lEfENPREVdX0pBUEFOIEFQUF9bSUR8Q09ERV1fS09SRUFcclxuICogQHBhcmFtIFtvcHQuY2xpY2s9bnVsbF0ge2Z1bmN0aW9uKCl9ICAtIGNhbGxiYWNrIG9uIG1vdXNlIGNsaWNrOiBjYWxsYmFjayhjb29yZCxidXR0b24sa2V5KVxyXG4gKiBAcGFyYW0gW29wdC5kYkNsaWNrPW51bGxdIHtmdW5jdGlvbigpfSAgLSBjYWxsYmFjayBvbiBtb3VzZSBkb3VibGUgY2xpY2s6IGNhbGxiYWNrKGNvb3JkLGJ1dHRvbixrZXkpXHJcbiAqIEBwYXJhbSBbb3B0LmNsaWNrTGVmdD1udWxsXSB7ZnVuY3Rpb259ICAtIGNhbGxiYWNrIG9uIG1vdXNlIGNsaWNrIGxlZnQ6IGNhbGxiYWNrKGNvb3JkLGJ1dHRvbixrZXkpXHJcbiAqIEBwYXJhbSBbb3B0LmNsaWNrUmlnaHQ9bnVsbF0ge2Z1bmN0aW9uKCl9ICAtIGNhbGxiYWNrIG9uIG1vdXNlIGNsaWNrIHJpZ2h0LjogY2FsbGJhY2soY29vcmQsYnV0dG9uLGtleSlcclxuICogQHBhcmFtIFtvcHQua2V5RG93bj1udWxsXSB7ZnVuY3Rpb259ICAtIGNhbGxiYWNrIG9uIGtleSBkb3duIDogY2FsbGJhY2soa2V5KVxyXG4gKiBAcGFyYW0gW29wdC52aWV3Q2hhbmdlPW51bGxdIHtmdW5jdGlvbn0gIC0gY2FsbGJhY2sgaWYgbWFwIGlzIHBhbm5lZCBvciB6b29tZWQgOiBjYWxsYmFjayh6b29tLGNvb3JkQ2VudGVyKVxyXG4gKiBAcGFyYW0gW29wdC5sb2FkVGlsZT1udWxsXSB7ZnVuY3Rpb259ICAtIGNhbGxiYWNrIHdoZW4gYSB0aWxlIGlzIGxvYWRlZCA6IGNhbGxiYWNrKHoseCx5LHVybClcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogY29uc3QgaG0gPSB3aW5kb3cuaGVyZW1hcDtcclxuICogXHJcbiAqIGhtLmNvbmZpZyh7XHJcbiAqICAgIGFwcF9pZDogXCJZT1VSIEFQUF9JRFwiLFxyXG4gKiAgICBhcHBfY29kZTogXCJZT1VSIEFQUF9DT0RFXCIsXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBobS5tYXAoXCJtYXBcIiwge1xyXG4gKiAgICB6b29tOjUsXHJcbiAqICAgIGNlbnRlcjogWzQ4LjgsMi4zXSxcclxuICogICAgY2xpY2s6IGZ1bmN0aW9uKGNvb3JkLGJ1dHRvbixrZXkpIHtjb25zb2xlLmxvZyhcImNsaWNrZWQgb25cIixjb29yZCxcIndpdGggYnV0dG9uXCIsYnV0dG9uKTt9XHJcbiAqIH0pO1xyXG4qICBgYGBcclxuKi9cclxuZnVuY3Rpb24gbWFwKGh0bWxJdGVtLCBvcHQpIHtcclxuXHJcbiAgICBfaHRtbEl0ZW0gPSBodG1sSXRlbTtcclxuXHJcbiAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgem9vbTogMTAsXHJcbiAgICAgICAgY2VudGVyOiBbNDguODYsIDIuM10sXHJcbiAgICAgICAgY2xpY2tMZWZ0OiBudWxsLFxyXG4gICAgICAgIGNsaWNrUmlnaHQ6IG51bGwsXHJcbiAgICAgICAga2V5RG93bjogbnVsbCwgLy8ga2V5Ym9hcmQgZXZlbnRcclxuICAgICAgICBjbGljazogbnVsbCxcclxuICAgICAgICBkYkNsaWNrOiBudWxsLFxyXG4gICAgICAgIHZpZXdDaGFuZ2U6IG51bGwsIC8vICh6b29tLGNvb3JkKVxyXG4gICAgICAgIGxvYWRUaWxlOiBudWxsIC8vIHF1YW5kIHVuZSB0aWxlIGVzdCBhZmZpY2jDqWVcclxuICAgIH07XHJcblxyXG4gICAgbGV0IG1wcyA9IDE7XHJcblxyXG4gICAgbGV0IGFwcF9pZCA9IGNtLmdldEFwcElkKCk7XHJcbiAgICBsZXQgYXBwX2NvZGUgPSBjbS5nZXRBcHBDb2RlKCk7XHJcblxyXG4gICAgaWYgKCFhcHBfaWQgfHwgIWFwcF9jb2RlKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJhcHBfaWQvYXBwX2NvZGUgbm90IGluaXRpYWxpc2VkXCIpO1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGh0bWxJdGVtKS5pbm5lckhUTUwgPSBcImFwcF9pZC9hcHBfY29kZSBub3QgaW5pdGlhbGlzZWRcIjtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgX3BsYXRmb3JtID0gbmV3IEguc2VydmljZS5QbGF0Zm9ybSh7XHJcbiAgICAgICAgYXBwX2lkOiBhcHBfaWQsXHJcbiAgICAgICAgYXBwX2NvZGU6IGFwcF9jb2RlLFxyXG4gICAgICAgIHVzZUNJVDogY20uZ2V0Q0lUKCksXHJcbiAgICAgICAgdXNlSFRUUFM6IGNtLnVzZUhUVFBTKClcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcbiAgICBpZiAoc2V0dGluZ3Muc2NoZW1lKSBfc2NoZW1lID0gc2V0dGluZ3Muc2NoZW1lOyAvLyBzdG9yZSBzY2hlbWUgaWYgZGVmaW5lZFxyXG5cclxuICAgIF9kZWZhdWx0TGF5ZXJzID0gX3BsYXRmb3JtLmNyZWF0ZURlZmF1bHRMYXllcnMoKTtcclxuXHJcbiAgICAvLyBodHRwOi8vaGVyZW1hcHMuZ2l0aHViLmlvL2V4YW1wbGVzL2V4cGxvcmVyLmh0bWwjbWFwLXRpbGVzX19iYXNlLW1hcC1zdHlsZXMtYW5kLW1vZGVzXHJcbiAgICBfcHJvdmlkZXIgPSBuZXcgSC5tYXAucHJvdmlkZXIuSW1hZ2VUaWxlUHJvdmlkZXIoe1xyXG4gICAgICAgIGxhYmVsOiBcIkJhc2UgUHJvdmlkZXJcIixcclxuICAgICAgICBkZXNjcjogXCJcIixcclxuICAgICAgICBtaW46IDAsXHJcbiAgICAgICAgbWF4OiAyMCxcclxuICAgICAgICBjcm9zc09yaWdpbjogXCJhbm9ueW1vdXNcIixcclxuICAgICAgICBnZXRVUkw6IGZ1bmN0aW9uIChjb2wsIHJvdywgbGV2ZWwpIHtcclxuICAgICAgICAgICAgbXBzKys7XHJcbiAgICAgICAgICAgIGlmIChtcHMgPiA0KSBtcHMgPSAxO1xyXG4gICAgICAgICAgICBsZXQgdXJsID0gW2NtLmdldFByb3RvY29sKCksIFwiLy9cIiwgbXBzLCBcIi5iYXNlLm1hcHNcIiArIGNtLmdldENJVCgpICsgXCIuYXBpLmhlcmUuY29tL21hcHRpbGUvXCIsIFwiMi4xXCIsXHJcbiAgICAgICAgICAgICAgICBcIi9cIiwgXCJtYXB0aWxlXCIsIFwiL1wiLCBcIm5ld2VzdFwiLCBcIi9cIixcclxuICAgICAgICAgICAgICAgIF9zY2hlbWUsIFwiL1wiLCBsZXZlbCwgXCIvXCIsIGNvbCwgXCIvXCIsIHJvdywgXCIvXCIsIFwiMjU2XCIsXHJcbiAgICAgICAgICAgICAgICBcIi9cIiwgXCJwbmdcIiwgXCI/bGc9XCIsIFwiRlJFXCIsXHJcbiAgICAgICAgICAgICAgICBcIiZhcHBfY29kZT1cIiwgYXBwX2NvZGUsIFwiJmFwcF9pZD1cIixcclxuICAgICAgICAgICAgICAgIGFwcF9pZFxyXG4gICAgICAgICAgICBdLmpvaW4oXCJcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3NjaGVtZSA9PSBcImphcGFuXCIpXHJcbiAgICAgICAgICAgICAgICB1cmwgPSBbY20uZ2V0UHJvdG9jb2woKSwgXCIvL1wiLCBcIm0ubGJzXCIgKyBjbS5nZXRDSVQoKSArIFwiLmFwaS5oZXJlbWFwcy5qcC92MS9tYXA/YXBwX2lkPVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIEFQUF9JRF9KQVBBTixcclxuICAgICAgICAgICAgICAgICAgICBcIiZhcHBfY29kZT1cIixcclxuICAgICAgICAgICAgICAgICAgICBBUFBfQ09ERV9KQVBBTixcclxuICAgICAgICAgICAgICAgICAgICBcIiZ0aWxlbWF0cml4PUVQU0c6OTAwOTEzOlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiJnRpbGVjb2w9XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiJnRpbGVyb3c9XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcm93XHJcbiAgICAgICAgICAgICAgICBdLmpvaW4oXCJcIik7XHJcblxyXG4gICAgICAgICAgICBlbHNlIGlmIChfc2NoZW1lID09IFwia29yZWFcIilcclxuICAgICAgICAgICAgICAgIHVybCA9IFtjbS5nZXRQcm90b2NvbCgpLCBcIi8vXCIsIFwiMy5iYXNlLm1hcHNcIiArIGNtLmdldENJVCgpICsgXCIuYXBpLmhlcmVtYXBzLmtyL21hcHRpbGUvMi4xL21hcHRpbGUvMzQ0MzkzNDhjMy9ub3JtYWwuZGF5L1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiL1wiLCBsZXZlbCwgXCIvXCIsIGNvbCwgXCIvXCIsIHJvdywgXCIvXCIsIFwiMjU2XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCIvXCIsIFwicG5nXCIsIFwiP2xnPVwiLCBcIkZSRVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiJmFwcF9jb2RlPVwiLCBBUFBfQ09ERV9LT1JFQSwgXCImYXBwX2lkPVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIEFQUF9JRF9LT1JFQVxyXG4gICAgICAgICAgICAgICAgXS5qb2luKFwiXCIpO1xyXG5cclxuICAgICAgICAgICAgZWxzZSBpZiAoX3NjaGVtZSA9PSBcImJsYWNrXCIpXHJcbiAgICAgICAgICAgICAgICB1cmwgPSBjbS5nZXRIb21lKCkgKyBcInBuZy9ibGFjay5wbmdcIjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoX3NjaGVtZSA9PSBcIndoaXRlXCIpXHJcbiAgICAgICAgICAgICAgICB1cmwgPSBjbS5nZXRIb21lKCkgKyBcInBuZy93aGl0ZS5wbmdcIjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoX3NjaGVtZSA9PSBcInRyYW5zcGFyZW50XCIpXHJcbiAgICAgICAgICAgICAgICB1cmwgPSBjbS5nZXRIb21lKCkgKyBcInBuZy90cmFuc3BhcmVudC5wbmdcIjtcclxuXHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubG9hZFRpbGUpXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5sb2FkVGlsZShsZXZlbCwgY29sLCByb3csIHVybCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IF9fbGF5ZXIgPSBuZXcgSC5tYXAubGF5ZXIuVGlsZUxheWVyKF9wcm92aWRlcik7XHJcblxyXG4gICAgLy9jb25zb2xlLmxvZyhcIm5vcm1hbCBtYXBcIik7XHJcbiAgICAvL1N0ZXAgMjogaW5pdGlhbGl6ZSBhIEhFUkVNYXAgXHJcbiAgICBfbWFwID0gbmV3IEguTWFwKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGh0bWxJdGVtKSxcclxuICAgICAgICBfX2xheWVyLCB7XHJcbiAgICAgICAgICAgIGNlbnRlcjogY29vcmRBMk8oc2V0dGluZ3MuY2VudGVyKSxcclxuICAgICAgICAgICAgem9vbTogc2V0dGluZ3Muem9vbVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIF9iZWhhdmlvciA9IG5ldyBILm1hcGV2ZW50cy5CZWhhdmlvcihuZXcgSC5tYXBldmVudHMuTWFwRXZlbnRzKF9tYXApKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIGRlZmF1bHQgVUkgY29tcG9uZW50c1xyXG4gICAgX3VpID0gSC51aS5VSS5jcmVhdGVEZWZhdWx0KF9tYXAsIF9kZWZhdWx0TGF5ZXJzKTtcclxuXHJcbiAgICAvLyBjcmVhdGUgZGVmYXVsdCBsYXllclxyXG4gICAgbGF5ZXJDcmVhdGUoXCJkZWZhdWx0XCIpO1xyXG5cclxuICAgIC8vIGlmIGNhbGxiYWNrIG9uIHpvb20gQ2hhbmdlXHJcbiAgICBpZiAoc2V0dGluZ3Mudmlld0NoYW5nZSkge1xyXG4gICAgICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1hcHZpZXdjaGFuZ2VlbmRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsZXQgYm91bmQgPSBfbWFwLmdldFZpZXdCb3VuZHMoKTtcclxuICAgICAgICAgICAgbGV0IGxhdCA9IChib3VuZC5rYSArIGJvdW5kLmphKSAvIDI7XHJcbiAgICAgICAgICAgIGxldCBsbmcgPSAoYm91bmQuZ2EgKyBib3VuZC5oYSkgLyAyO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInZpZXdDaGFuZ2UgY2VudGVyIFwiICsgbGF0ICsgXCIgXCIgKyBsbmcpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy52aWV3Q2hhbmdlKF9tYXAuZ2V0Wm9vbSgpLCBbbGF0LCBsbmddKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKiogICAgICAgICAgIHRvIGhhbmRsZSBrZXlib2FyZCB3aGlsZSBtb3VzZSBpbiBtYXAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgbGV0IGt1cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfa2V5LmN0cmwgPSBmYWxzZTtcclxuICAgICAgICBfa2V5LnNoaWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgX2tleS5hbHQgPSBmYWxzZTtcclxuICAgICAgICBfa2V5LmtleSA9IFwiXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBrZG93biA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgX2tleS5jdHJsID0gKChlLmtleSA9PSBcIkNvbnRyb2xcIikgfHwgKGUua2V5SWRlbnRpZmllciA9PSBcIkNvbnRyb2xcIikgfHwgKGUuY3RybEtleSA9PSB0cnVlKSk7XHJcbiAgICAgICAgX2tleS5zaGlmdCA9ICgoZS5rZXkgPT0gXCJTaGlmdFwiKSB8fCAoZS5rZXlJZGVudGlmaWVyID09IFwiU2hpZnRcIikgfHwgKGUuc2hpZnRLZXkgPT0gdHJ1ZSkpO1xyXG4gICAgICAgIF9rZXkuYWx0ID0gKChlLmtleSA9PSBcIkFsdFwiKSB8fCAoZS5rZXlJZGVudGlmaWVyID09IFwiQWx0XCIpIHx8IChlLnNoaWZ0S2V5ID09IHRydWUpKTtcclxuICAgICAgICBfa2V5LmtleSA9IGUua2V5O1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5rZXlEb3duKSBzZXR0aW5ncy5rZXlEb3duKF9rZXkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm1hcCBtb3VzZSBlbnRlclwiKTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZG93bik7XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGt1cCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJtYXAgcG9pbnRlciBlbnRlclwiKTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZG93bik7XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGt1cCk7XHJcbiAgICB9KTtcclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwibWFwIG1vdXNlIGxlYXZlXCIpO1xyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtkb3duKTtcclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga3VwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKiAgICAgICAgICAgdG8gaGFuZGxlIGRvdWJsZSBjbGljayAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgX21hcC5hZGRFdmVudExpc3RlbmVyKFwiZGJsdGFwXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEgubWFwLk1hcmtlcikgcmV0dXJuOyAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiBjbGljayBvbiBtYXJrZXJcclxuXHJcbiAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgbGV0IGJ1dHRvbiA9IGV2LmN1cnJlbnRQb2ludGVyLmJ1dHRvbjtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuZGJDbGljayAhPSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYnV0dG9uKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZGJDbGljayhjb29yZE8yQShjb29yZCksIFwibGVmdFwiLCBfa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kYkNsaWNrKGNvb3JkTzJBKGNvb3JkKSwgXCJyaWdodFwiLCBfa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKiAgICAgICAgICAgdG8gaGFuZGxlIHNpbXBsZSBjbGljayAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgX21hcC5hZGRFdmVudExpc3RlbmVyKFwidGFwXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcblxyXG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBILm1hcC5NYXJrZXIpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgbGV0IGJ1dHRvbiA9IGV2LmN1cnJlbnRQb2ludGVyLmJ1dHRvbjtcclxuXHJcbiAgICAgICAgaWYgKChidXR0b24gPT0gMCkgJiYgKHNldHRpbmdzLmNsaWNrTGVmdCkpXHJcbiAgICAgICAgICAgIHNldHRpbmdzLmNsaWNrTGVmdChjb29yZE8yQShjb29yZCksIFwibGVmdFwiLCBfa2V5KTtcclxuICAgICAgICBpZiAoKGJ1dHRvbiA9PSAyKSAmJiAoc2V0dGluZ3MuY2xpY2tSaWdodCkpXHJcbiAgICAgICAgICAgIHNldHRpbmdzLmNsaWNrUmlnaHQoY29vcmRPMkEoY29vcmQpLCBcInJpZ2h0XCIsIF9rZXkpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5jbGljaykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmNsaWNrKGNvb3JkTzJBKGNvb3JkKSwgXCJsZWZ0XCIsIF9rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmNsaWNrKGNvb3JkTzJBKGNvb3JkKSwgXCJyaWdodFwiLCBfa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKioqKioqKiogIGRpc2FibGUgdGhlIGRlZmF1bHQgZHJhZ2dhYmlsaXR5IG9mIHRoZSB1bmRlcmx5aW5nIG1hcCB3aGVuIHN0YXJ0aW5nIHRvIGRyYWcgYSBtYXJrZXIgb2JqZWN0ICoqKioqKioqKioqKioqKioqL1xyXG4gICAgX21hcC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEgubWFwLk1hcmtlcikge1xyXG4gICAgICAgICAgICBfYmVoYXZpb3IuZGlzYWJsZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAvKioqKioqKioqKioqICAgcmUgLSBlbmFibGUgdGhlIGRlZmF1bHQgZHJhZ2dhYmlsaXR5IG9mIHRoZSB1bmRlcmx5aW5nIG1hcCB3aGVuIGRyYWdnaW5nIGhhcyBjb21wbGV0ZWQgKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIG1hcHNqcy5tYXAuTWFya2VyKSB7XHJcbiAgICAgICAgICAgIF9iZWhhdmlvci5lbmFibGUoKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQuZHJhZ2dlZCAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgICAgICAodGFyZ2V0LmRyYWdnZWQpKHRhcmdldCwgY29vcmRPMkEoY29vcmQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKiogIExpc3RlbiB0byB0aGUgZHJhZyBldmVudCBhbmQgbW92ZSB0aGUgcG9zaXRpb24gb2YgdGhlIG1hcmtlciBhcyBuZWNlc3NhcnkgKioqKioqKioqKioqKioqKioqKi9cclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldCxcclxuICAgICAgICAgICAgcG9pbnRlciA9IGV2LmN1cnJlbnRQb2ludGVyO1xyXG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBtYXBzanMubWFwLk1hcmtlcikge1xyXG4gICAgICAgICAgICB0YXJnZXQuc2V0UG9zaXRpb24oX21hcC5zY3JlZW5Ub0dlbyhwb2ludGVyLnZpZXdwb3J0WCwgcG9pbnRlci52aWV3cG9ydFkpKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqICBkZXRlY3QgbWFwIHJlc2l6ZSBhbmQgYWRqdXN0IGFjY29yaWRuZ2x5ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbWFwLmdldFZpZXdQb3J0KCkucmVzaXplKCk7XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIF9tYXA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBsaXN0IG9mIGFsbCBhdmFpbGFibGUgbWFwIHN0eWxlcyBub3JtYWwuZGF5LCBuaWdodC4uLi4gXHJcbiAqIEBhbGlhcyBobTpnZXRBdmFpbGFibGVNYXBTdHlsZVxyXG4gKiBAcmV0dXJuIHtqc29ufSBsaXN0IG9mIG1hcCBzdHlsZXMgYXMganNvblxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QXZhaWxhYmxlTWFwU3R5bGUoKSB7XHJcbiAgICAvLyBodHRwczovLzEuYmFzZS5tYXBzLmFwaS5oZXJlLmNvbS9tYXB0aWxlLzIuMS9pbmZvP3hubHA9Q0xfSlNNdjMuMC4xNy4wJmFwcF9pZD1uT1NoMjEyMTRKRk1TRVBRa3FubyZhcHBfY29kZT1yWF9sN1l2QUx0TmtxVTJieDVGV0VBJm91dHB1dD1qc29uXHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBjbS5hZGRDcmVkZW50aWFscyh7XHJcbiAgICAgICAgb3V0cHV0OiBcImpzb25cIlxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXJsID0gY20uYnVpbGRVcmwoXCIxLmJhc2UubWFwc1wiLCBcImFwaS5oZXJlLmNvbS9tYXB0aWxlLzIuMS9pbmZvXCIpO1xyXG4gICAgcmV0dXJuIGNtLmhlcmVSZXN0KHVybCwgc2V0dGluZ3MpXHJcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcy5ib2R5LnJlc3BvbnNlO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogZGVmaW5lIHRoZSBzY2hlbWUuIExpc3Qgb2Ygc2NoZW1lIGNhbiBiZSBvYnRhaW5lZCBmcm9tIHtobS5nZXRBdmFpbGFibGVNYXBTdHlsZSgpfVxyXG4gKiBAYWxpYXMgaG06c2V0U2NoZW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlbWUgc2NoZW1lIG5hbWVcclxuICovXHJcbmZ1bmN0aW9uIHNldFNjaGVtZShzY2hlbWUpIHtcclxuICAgIF9zY2hlbWUgPSBzY2hlbWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgYSBsYXllclxyXG4gKiBAYWxpYXMgaG06bGF5ZXJDcmVhdGVcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgIC0gbmFtZSBvZiBsYXllclxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZpc2libGUgIC0gaW5pdGlhbCBzdGF0dXNcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogaG0ubGF5ZXJDcmVhdGUoXCJsYXllcjFcIik7XHJcbiAqICBgYGBcclxuICovXHJcbmZ1bmN0aW9uIGxheWVyQ3JlYXRlKG5hbWUsIHZpc2libGUpIHtcclxuICAgIGdyb3VwID0gbmV3IEgubWFwLkdyb3VwKCk7XHJcbiAgICBncm91cC5uYW1lID0gbmFtZTtcclxuICAgIF9tYXAuYWRkT2JqZWN0KGdyb3VwKTtcclxuXHJcbiAgICAvLyBwdXNoIGludG8gbGlzdCBvZiBsYXllcnNcclxuICAgIF9sYXllcnMucHVzaChncm91cCk7XHJcblxyXG4gICAgLy8gY2FuIGJlIHZpc2libGUgb3IgaGlkZGVuXHJcbiAgICBpZiAodHlwZW9mIHZpc2libGUgIT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICBncm91cC5zZXRWaXNpYmlsaXR5KHZpc2libGUpO1xyXG5cclxuICAgIHJldHVybiBncm91cDtcclxufVxyXG5cclxuLyoqXHJcbiAqIGRlbGV0ZSBhIGxheWVyXHJcbiAqIEBhbGlhcyBobTpsYXllckRlbGV0ZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIGxheWVyXHJcbiAqL1xyXG5mdW5jdGlvbiBsYXllckRlbGV0ZShuYW1lKSB7XHJcbiAgICBsZXQgbGF5ZXIgPSBsYXllckZpbmQobmFtZSk7XHJcbiAgICBpZiAoIWxheWVyKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAvLyByZW1vdmUgZ3JvdXAgZnJvbSBtYXBcclxuICAgIF9tYXAucmVtb3ZlT2JqZWN0KGxheWVyKTtcclxuICAgIC8vcmVtb3ZlIGZvcm0gbGlzdCBvZiBsYXllcnNcclxuICAgIF9sYXllcnMgPSBfbGF5ZXJzLmZpbHRlcihpdGVtID0+IHtcclxuICAgICAgICByZXR1cm4gaXRlbS5uYW1lICE9PSBuYW1lO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbXB0eSBhIGxheWVyLFxyXG4gKiBAYWxpYXMgaG06bGF5ZXJFbXB0eVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgXHJcbiAqL1xyXG5mdW5jdGlvbiBsYXllckVtcHR5KG5hbWUpIHtcclxuICAgIGxldCBsYXllciA9IGxheWVyRmluZChuYW1lKTtcclxuICAgIGlmICghbGF5ZXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgbGF5ZXIucmVtb3ZlQWxsKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgYSBsYXllclxyXG4gKiBAYWxpYXMgaG06bGF5ZXJTZXRWaXNpYmlsaXR5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAtIG5hbWUgb2YgbGF5ZXJcclxuICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlICAtIHZpc2libGUgb3Igbm90XHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGhtLmxheWVyVmlzaWJsZShcImxheWVyMVwiLHRydWUpO1xyXG4gKiAgYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBsYXllclNldFZpc2liaWxpdHkobmFtZSwgdmlzaWJsZSkge1xyXG4gICAgbGV0IGxheWVyID0gbGF5ZXJGaW5kKG5hbWUpO1xyXG4gICAgaWYgKCFsYXllcilcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgbGF5ZXIuc2V0VmlzaWJpbGl0eSh2aXNpYmxlKTtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBmaW5kIGxheWVyIGJ5IGl0cyBuYW1lIG9yIHJldHVybiBudWxsIFxyXG4gKiBAYWxpYXMgaG06bGF5ZXJGaW5kXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxyXG4gKi9cclxuZnVuY3Rpb24gbGF5ZXJGaW5kKG5hbWUpIHtcclxuICAgIGxldCBsID0gX2xheWVycy5maW5kKGxheWVyID0+IHtcclxuICAgICAgICByZXR1cm4gbGF5ZXIubmFtZSA9PSBuYW1lO1xyXG4gICAgfSk7XHJcbiAgICBpZiAodHlwZW9mIGwgPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gbDtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBzZXQgY2VudGVyIG9mIHRoZSBtYXBcclxuICogQGFsaWFzIGhtOnNldENlbnRlclxyXG4gKiBAcGFyYW0ge0FycmF5fSAtIGNvb3JkIGFzIFtsYXQsbG5nXVxyXG4gKiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGhtLnNldENlbnRlcihbNDguOCwyLjNdKTtcclxuICogIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q2VudGVyKGNvb3JkKSB7XHJcbiAgICBfbWFwLnNldENlbnRlcihjb29yZEEyTyhjb29yZCkpO1xyXG59XHJcblxyXG4vKipcclxuICogcmV0dXJuIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwXHJcbiAqIEBhbGlhcyBobTpnZXRDZW50ZXJcclxuICogQHJldHVybnMge2Nvb3JkfSBjb29yZCBvZiB0aGUgY2VudGVyIGFzIFxcW2xhdCxsbmdcXF1cclxuICovXHJcbmZ1bmN0aW9uIGdldENlbnRlcigpIHtcclxuICAgIGxldCBib3VuZCA9IF9tYXAuZ2V0Vmlld0JvdW5kcygpO1xyXG4gICAgLy9fSE0ubG9nKFwidmlld2JvdW5kXCIsYm91bmQpO1xyXG5cclxuICAgIGxldCBsbmcgPSAoYm91bmQuZ2EgKyBib3VuZC5oYSkgLyAyO1xyXG4gICAgbGV0IGxhdCA9IChib3VuZC5rYSArIGJvdW5kLmphKSAvIDI7XHJcbiAgICByZXR1cm4gW2xhdCwgbG5nXTtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gYm91bmRpbmcgYm94IG9mIHZpc2libGUgcGFydCBvZiBtYXBcclxuICogQGFsaWFzIGhtOmdldFZpZXdCQlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBib3VkaW5nIGJveCBvZiB2aXNpYmxlIHBhcnQgb2YgdGhlIG1hcCwgYXMgXFxbbGF0bSxsYXRNLGxvbmdtLGxuZ01cXF1cclxuICovXHJcbmZ1bmN0aW9uIGdldFZpZXdCQigpIHtcclxuICAgIGxldCBiYiA9IF9tYXAuZ2V0Vmlld0JvdW5kcygpO1xyXG5cclxuICAgIGxldCBiYjIgPSB7XHJcbiAgICAgICAgbGF0bTogYmIuamEsXHJcbiAgICAgICAgbGF0TTogYmIua2EsXHJcbiAgICAgICAgbG5nbTogYmIuZ2EsXHJcbiAgICAgICAgbG5nTTogYmIuaGFcclxuICAgIH07XHJcbiAgICByZXR1cm4gYmIyO1xyXG59XHJcblxyXG4vKipcclxuICogc2V0cyBib3VkaW5nIGJveCB0byBiZSBkaXNwbGF5ZWRcclxuICogQGFsaWFzIGhtOnNldFZpZXdCQlxyXG4gKiBAcGFyYW0gb3B0IHtPYmplY3R8IHN0cmluZ30gIGVpdGhlciBhbiBvYmplY3Qgc3BlY2lmeWluZyBob3cgdG8gc2V0IGJvdW5kaW5nIGJveCwgb3IgIGEgU3RyaW5nIGJlaW5nIHRoZSBuYW1lIG9mIGEgbGF5ZXJcclxuICogQHBhcmFtIFtvcHQubGF5ZXJdIHtzdHJpbmd9IGJvdWRpbmcgYm94IGFyb3VkIGFsbCBvYmplY3RzIG9mIHRoZSBsYXllclxyXG4gKiBAcGFyYW0gW29wdC5wb2lzXSB7YXJyYXl9IGJvdWRpbmcgYm94IGFyb3VkIGFsbCBjb29yZHMgZGVmaW5lZCBhcyBcXFtjb29yZCxjb29yZC4uLlxcXVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiBobS5zZXRWaWV3QkIoXCJsYXllcjFcIik7XHJcbiAqXHJcbiAqIGhtLnNldFZpZXdCQih7XHJcbiAqICAgIHBvaXM6IGNvb3Jkc1xyXG4gKiB9KTtcclxuICogIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Vmlld0JCKG9wdCkge1xyXG5cclxuICAgIGlmICh0eXBlb2Ygb3B0ID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgb3B0ID0ge1xyXG4gICAgICAgICAgICBsYXllcjogb3B0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbGF5ZXI6IG51bGwsXHJcbiAgICAgICAgcG9pczogbnVsbCAvLyBhcnJheSBvZiBbbGF0LGxuZ11cclxuICAgIH07XHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIGxldCBiYm94O1xyXG5cclxuICAgIC8vc2V0IEJCIGJhc2VkIG9uIGxheWVyXHJcbiAgICBpZiAoc2V0dGluZ3MubGF5ZXIpIHtcclxuICAgICAgICBsZXQgbGF5ZXIgPSBsYXllckZpbmQoc2V0dGluZ3MubGF5ZXIpO1xyXG4gICAgICAgIGlmICghbGF5ZXIpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gZ2V0IHZpZXcgYm91bmQgYW5kIGFkZCBhIGJpdCBhcm91bmQsIGxpa2UgMS81XHJcbiAgICAgICAgbGV0IGJiID0gbGF5ZXIuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgaWYgKCFiYikgLy8gYXMgaWYgbm90aGluZyBpbiBsYXllclxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgYmIubGF0bSA9IGJiLmphO1xyXG4gICAgICAgIGJiLmxhdE0gPSBiYi5rYTtcclxuICAgICAgICBiYi5sbmdtID0gYmIuZ2E7XHJcbiAgICAgICAgYmIubG5nTSA9IGJiLmhhO1xyXG4gICAgICAgIGxldCBkeCA9IGJiLmxuZ00gLSBiYi5sbmdtO1xyXG4gICAgICAgIGxldCBkeSA9IGJiLmxhdE0gLSBiYi5sYXRtO1xyXG4gICAgICAgIGR4ID0gZHggLyA1O1xyXG4gICAgICAgIGR5ID0gZHkgLyA1O1xyXG4gICAgICAgIGJiLmxhdE0gKz0gZHk7XHJcbiAgICAgICAgYmIubG5nbSAtPSBkeDtcclxuICAgICAgICBiYi5sYXRtIC09IGR5O1xyXG4gICAgICAgIGJiLmxuZ00gKz0gZHg7XHJcbiAgICAgICAgYmJveCA9IG5ldyBILmdlby5SZWN0KGJiLmxhdE0sIGJiLmxuZ20sIGJiLmxhdG0sIGJiLmxuZ00pO1xyXG4gICAgICAgIF9tYXAuc2V0Vmlld0JvdW5kcyhiYm94LCB0cnVlKTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnBvaXMpIHtcclxuICAgICAgICBsZXQgYmIgPSB7XHJcbiAgICAgICAgICAgIGxhdE06IDAsXHJcbiAgICAgICAgICAgIGxuZ206IDE4MCxcclxuICAgICAgICAgICAgbGF0bTogOTAsXHJcbiAgICAgICAgICAgIGxuZ006IC0xODAsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgYXJyID0gc2V0dGluZ3MucG9pcztcclxuICAgICAgICBhcnIuZm9yRWFjaCgocG9pKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwb2lbMF0gPiBiYi5sYXRNKSBiYi5sYXRNID0gcG9pWzBdO1xyXG4gICAgICAgICAgICBpZiAocG9pWzFdID4gYmIubG5nTSkgYmIubG5nTSA9IHBvaVsxXTtcclxuICAgICAgICAgICAgaWYgKHBvaVswXSA8IGJiLmxhdG0pIGJiLmxhdG0gPSBwb2lbMF07XHJcbiAgICAgICAgICAgIGlmIChwb2lbMV0gPCBiYi5sbmdtKSBiYi5sbmdtID0gcG9pWzFdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGJib3ggPSBuZXcgSC5nZW8uUmVjdChiYi5sYXRNLCBiYi5sbmdtLCBiYi5sYXRtLCBiYi5sbmdNKTtcclxuICAgICAgICBfbWFwLnNldFZpZXdCb3VuZHMoYmJveCwgdHJ1ZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogcmV0dXJuIHpvb20gdmFsdWVcclxuICogQGFsaWFzIGhtOmdldFpvb21cclxuICogQHJldHVybnMge251bWJlcn0gem9vbSBsZXZlbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Wm9vbSgpIHtcclxuICAgIHJldHVybiBfbWFwLmdldFpvb20oKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHNldCB6b29tIGxldmVsXHJcbiAqIEBhbGlhcyBobTpzZXRab29tXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Wm9vbSh6b29tKSB7XHJcbiAgICBfbWFwLnNldFpvb20oem9vbSk7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIGNyZWF0ZSBhbiBpY29uLCB0byBiZSB1c2VkIGZvciBhIG1hcmtlclxyXG4gKiBAYXN5bmNcclxuICogQGFsaWFzIGhtOmJ1aWxkSWNvblxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9IG9wdGlvbnMgdG8gc3BlY2lmeSB0aGUgaWNvblxyXG4gKiBAcGFyYW0gW29wdC5pbWddIHtzdHJpbmd9ICB1c2UgYSBwbmcvanBnIGltYWdlLiBTcGVjaWZ5IHRoZSB1cmwgXHJcbiAqIEBwYXJhbSBbb3B0LnN2Z10ge3N0cmluZ30gIHVybCBhIHN2Zy4gVGhpcyBjYW4gYmUgYW4gaW5saW5lIHN2ZywgYSB1cmwsIG9yIGEgc3ZnIGZyb20gaGVyZW1hcFxyXG4gKiBAcGFyYW0gW29wdC5vcHRdIHtvYmplY3R9ICAgc3R5bGUgb2JqZWN0XHJcbiAqIEBwYXJhbSBbb3B0Lm9wdC5zaXplXSB7bnVtYmVyfHN0cmluZ30gICBzaXplIG9mIGljb24sIGFzIDI0IG9yIDI0eDMyXHJcbiAqIEBwYXJhbSBbb3B0Lm9wdC5yYXRpb10ge251bWJlcn0gICBmb3Igc3ZnIGZpbGVzLCByYXRpbyBvZiBzaXplLiAwLjUgPSBoYWxmXHJcbiAqIEBwYXJhbSBbb3B0Lm9wdC5hbmNob3JdIHtudW1iZXJ8c3RyaW5nfSAgIGFuY2hvciBvZiBpY29uLCBhcyAyNCBvciBcIjI0eDMyXCIgb3IgXCJjZW50ZXJcIi4gQnkgZGVmYXVsdCwgYm90dG9tLWNlbnRlclxyXG4gKiBAcGFyYW0gW29wdC5vcHQudGFnXSB7c3RyaW5nfSAgIGZvciBzdmcsIGFueSB0YWcgbGlrZXt0YWd9LiB3aWxsIGJlIHJlcGxhY2VkIGJ5IGFzc29jaWF0ZWQgdmFsdWVcclxuICogQHJldHVybiB7SC5tYXAuSWNvbn0gdGhlIGNyZWF0ZWQgaWNvblxyXG4gKiBAZXhhbXBsZSBcclxuICogYGBganNcclxuICogaG0uYnVpbGRJY29uKHtcclxuICogICAgaW1nOiBcImh0dHA6Ly93aGF0ZXZlci5jb20vaW1hZ2UucG5nXCIsXHJcbiAqICAgIG9wdDoge3NpemU6MjR9XHJcbiAqIH0pO1xyXG4gKiBcclxuICogaG0uYnVpbGRJY29uKHtcclxuICogICAgc3ZnOiBcImh0dHA6Ly93aGF0ZXZlci5jb20vaW1hZ2Uuc3ZnXCIsXHJcbiAqICAgIG9wdDoge1xyXG4gKiAgICAgICByYXRpbzowLjUsXHJcbiAqICAgICAgIGFuY2hvcjoyNHgzMlxyXG4gKiAgICB9XHJcbiAqIH0pO1xyXG4gKiAgXHJcbiAqIGhtLmJ1aWxkSWNvbih7XHJcbiAqICAgIHN2ZzogXCJzdmcvY2x1c3Rlci5zdmdcIixcclxuICogICAgb3B0OiB7XHJcbiAqICAgICAgIHNpemU6MjQsXHJcbiAqICAgICAgIGNvbG9yOlwicmVkXCJcclxuICogICAgfVxyXG4gKiB9KTtcclxuICogXHJcbiAqIGNvbnN0IHN2ZyA9IGA8c3ZnIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4gPGVsbGlwc2Ugc3Ryb2tlPVwibnVsbFwiIHJ5PVwiOFwiIHJ4PVwiNy42MTg4OTZcIiBpZD1cInN2Z18xXCIgY3k9XCI4XCIgY3g9XCI3LjgzNzQyN1wiIGZpbGw9XCJ7Y29sb3J9XCIgZmlsbC1vcGFjaXR5PVwiMC45XCIvPjwvc3ZnPmA7XHJcbiAqIGhtLmJ1aWxkSWNvbih7XHJcbiAqICAgIHN2Zzogc3ZnLFxyXG4gKiAgICBvcHQ6IHtcclxuICogICAgICAgc2l6ZToyNCxcclxuICogICAgICAgY29sb3I6XCJyZWRcIlxyXG4gKiAgICB9IFxyXG4gKiB9KTtcclxuICogIGBgYFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gYnVpbGRJY29uKG9wdCkge1xyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIGltZzogbnVsbCwgLy8gICBwbmcsIGpwZy4gaWYgbm90IGh0dHAgaW4gdGhlIGJlZ2lubmluZywgbG9vayBsb2NhbGx5XHJcbiAgICAgICAgc3ZnOiBudWxsLCAvLyBzdmcgZmlsZTogIGlzIGEgdXJsIG9yIGEgc3RyaW5nXHJcbiAgICAgICAgb3B0OiBudWxsLCAvLyBzaXplLCBjb2xvciwgYW5jaG9yLCB0ZXh0Li4uc1xyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIGlmICghc2V0dGluZ3MuaW1nICYmICFzZXR0aW5ncy5zdmcpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgaWNvbiwgaWNvblNyYztcclxuXHJcbiAgICBpZiAoc2V0dGluZ3MuaW1nKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJzZXR0aW5ncy5pbWdcIiwgc2V0dGluZ3MuaW1nKTtcclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmltZ1swXSA9PSBcIkBcIikgLy8gdG8gaW5kaWNhdGUgbG9jYWxcclxuICAgICAgICAgICAgaWNvblNyYyA9IGNtLmdldEhvbWUoKSArIHNldHRpbmdzLmltZy5zdWJzdHIoMSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBpY29uU3JjID0gc2V0dGluZ3MuaW1nOyAvLyBsb2NhbCBmaWxlXHJcblxyXG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncy5zdmcpIHtcclxuXHJcbiAgICAgICAgbGV0IHVybCA9IG51bGw7XHJcbiAgICAgICAgaWNvblNyYyA9IHNldHRpbmdzLnN2ZztcclxuICAgICAgICBpZiAoc2V0dGluZ3Muc3ZnWzBdID09IFwiQFwiKSAvLyBsb2NhbCBcclxuICAgICAgICAgICAgdXJsID0gY20uZ2V0SG9tZSgpICsgc2V0dGluZ3Muc3ZnLnN1YnN0cigxKTtcclxuICAgICAgICBlbHNlIGlmIChzZXR0aW5ncy5zdmcuc3Vic3RyKDAsIDQpID09IFwiPHN2Z1wiKSAvLyB1cmxcclxuICAgICAgICAgICAgdXJsID0gbnVsbDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHVybCA9IHNldHRpbmdzLnN2ZzsgLy8gbm90IGVtYmVkZGVkIHN0cmluZywgc2hvdWxkIGJlIGEgdXJsXHJcblxyXG4gICAgICAgIGlmICh1cmwpIC8vIGFuIHVybCB0byBkb3dubG9hZFxyXG4gICAgICAgICAgICBpY29uU3JjID0gYXdhaXQgZmV0Y2godXJsKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzLnN0YXR1cyAhPSAyMDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMudGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGljb25PcHQgPSB7XHJcbiAgICAgICAgY3Jvc3NPcmlnaW46IHRydWVcclxuICAgIH07IC8vIHRvIGF2b2lkIGlzc3VlZCB3aXRoIGNhcHR1cmVcclxuICAgIGlmIChzZXR0aW5ncy5vcHQgJiYgc2V0dGluZ3Mub3B0LnNpemUpIHtcclxuICAgICAgICBsZXQgdywgaDtcclxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLm9wdC5zaXplID09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgIHcgPSBoID0gc2V0dGluZ3Mub3B0LnNpemU7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBbdywgaF0gPSBzZXR0aW5ncy5vcHQuc2l6ZS5zcGxpdChcInhcIik7XHJcblxyXG4gICAgICAgIGljb25PcHQuc2l6ZSA9IHtcclxuICAgICAgICAgICAgdzogdyxcclxuICAgICAgICAgICAgaDogaFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldHNpemVTdmcoaWNvblNyYykge1xyXG4gICAgICAgIGxldCB3ID0gbnVsbCxcclxuICAgICAgICAgICAgaCA9IG51bGwsXHJcbiAgICAgICAgICAgIG1hdGNoO1xyXG4gICAgICAgIGxldCByID0gL3dpZHRoPVwiKFxcZCspXCIvO1xyXG4gICAgICAgIG1hdGNoID0gaWNvblNyYy5tYXRjaChyKTtcclxuICAgICAgICBpZiAobWF0Y2gpIHcgPSBtYXRjaFsxXTtcclxuXHJcbiAgICAgICAgciA9IC9oZWlnaHQ9XCIoXFxkKylcIi87XHJcbiAgICAgICAgbWF0Y2ggPSBpY29uU3JjLm1hdGNoKHIpO1xyXG4gICAgICAgIGlmIChtYXRjaCkgaCA9IG1hdGNoWzFdO1xyXG4gICAgICAgIHJldHVybiBbdywgaF07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLnN2ZyAmJiBzZXR0aW5ncy5vcHQgJiYgc2V0dGluZ3Mub3B0LnJhdGlvKSB7XHJcbiAgICAgICAgbGV0IHcgPSBudWxsLFxyXG4gICAgICAgICAgICBoID0gbnVsbDtcclxuICAgICAgICBbdywgaF0gPSBfZ2V0c2l6ZVN2ZyhpY29uU3JjKTtcclxuXHJcbiAgICAgICAgaWNvbk9wdC5zaXplID0ge1xyXG4gICAgICAgICAgICB3OiBNYXRoLmZsb29yKHcgKiBzZXR0aW5ncy5vcHQucmF0aW8pLFxyXG4gICAgICAgICAgICBoOiBNYXRoLmZsb29yKGggKiBzZXR0aW5ncy5vcHQucmF0aW8pXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2V0dGluZ3Mub3B0ICYmIHNldHRpbmdzLm9wdC5hbmNob3IpIHtcclxuICAgICAgICBsZXQgeCA9IG51bGwsXHJcbiAgICAgICAgICAgIHkgPSBudWxsO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Mub3B0LmFuY2hvciA9PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICB4ID0geSA9IHNldHRpbmdzLm9wdC5hbmNob3I7XHJcbiAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3Mub3B0LmFuY2hvciA9PSBcImNlbnRlclwiICYmIHNldHRpbmdzLnN2ZykgeyAvLyBmb3Igc3ZnIGZpbGUgb25seSBjZW50ZXI6IGdldCBzaXplIG9mIHNwbGl0IGluIDJcclxuICAgICAgICAgICAgW3gsIHldID0gX2dldHNpemVTdmcoaWNvblNyYyk7XHJcbiAgICAgICAgICAgIHggLz0gMjtcclxuICAgICAgICAgICAgeSAvPSAyO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBbeCwgeV0gPSBzZXR0aW5ncy5vcHQuYW5jaG9yLnNwbGl0KFwieFwiKTtcclxuXHJcbiAgICAgICAgaWYgKCF4IHx8ICF5KSB7XHJcbiAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiQnVpbGRJY29uOiBpbmNvcnJlY3QgYW5jaG9yXCIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpY29uT3B0LmFuY2hvciA9IHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWxsIG90aGVyIGZpZWxkcyBhcmUgdHJlYXRlZCBhcyBncmFwaGljIGVuaGFuY2VlbnRcclxuICAgIGlmIChzZXR0aW5ncy5vcHQpIHtcclxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNldHRpbmdzLm9wdCkge1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImZpbGVcIiB8fCBuYW1lID09IFwic2l6ZVwiIHx8IG5hbWUgPT0gXCJhbmNob3JcIikgY29udGludWU7XHJcbiAgICAgICAgICAgIGxldCByZSA9IG5ldyBSZWdFeHAoXCJ7XCIgKyBuYW1lICsgXCJ9XCIsIFwiZ1wiKTtcclxuICAgICAgICAgICAgaWNvblNyYyA9IGljb25TcmMucmVwbGFjZShyZSwgc2V0dGluZ3Mub3B0W25hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coXCJpY29uU3JjXCIsIGljb25TcmMpO1xyXG4gICAgLy8gY29uc29sZS5sb2coXCJpY29uT3B0XCIsIGljb25PcHQpO1xyXG4gICAgaWNvbiA9IG5ldyBILm1hcC5JY29uKGljb25TcmMsIGljb25PcHQpO1xyXG5cclxuICAgIHJldHVybiBpY29uO1xyXG5cclxufSAvL2VuZCBvZiBpY29uXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIGFkZCBhIG1hcmtlciBpbiBhIGxheWVyXHJcbiAqIHN2ZyBmaWxlcyBjYW4gYmUgY3JlYXRlZCB3aXRoIGh0dHBzOi8vZWRpdG9yLm1ldGhvZC5hYy8gXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06bWFya2VyXHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gb3B0aW9ucyB0byBjcmVhdGUgdGhlIG1hcmtlciwgY2FuIGJlIGEgY29vcmQgZGlyZWN0bHlcclxuICogQHBhcmFtIFtvcHQubGF5ZXJdIHtzdHJpbmd9ICAgbGF5ZXIgbmFtZVxyXG4gKiBAcGFyYW0gW29wdC5jb29yZF0ge2Nvb3JkfSAgIGNvb3JkIG9mIHRoZSBtYXJrZXIgYXMgXFxbbGF0LGxuZ1xcXVxyXG4gKiBAcGFyYW0gW29wdC5pY29uXSB7c3RyaW5nfSAgIGNyZWF0ZWQgZnJvbSBobS5idWlsZEljb25cclxuICogQHBhcmFtIFtvcHQuc3ZnXSB7c3RyaW5nfSAgIHNlZSBobS5idWlsZEljb25cclxuICogQHBhcmFtIFtvcHQub3B0XSB7T2JqZWN0fSAgIHNlZSBobS5idWlsZEljb25cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LnBvaW50ZXJlbnRlciAgaWYgZW50ZXIsIGNhbGxiYWNrKHRhcmdldCxjb29yZCxldilcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LnBvaW50ZXJDbGljayAgaWYgY2xpY2ssIGNhbGxiYWNrKHRhcmdldCxjb29yZCxldilcclxuICogQHBhcmFtIHtzdHJpbmd9IG9wdC5kYXRhICBvcHRpb25hbCBkYXRhXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmJ1YmJsZSAgaWYgdHJ1ZSwgc2hvdyBidWJsZSBvbiBjbGljayB3aXRoIGRhdGFcclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZHJhZ2dhYmxlICBkcmFnZ2FibGUgbWFya2VyXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdC5kcmFnZ2VkICBpZiBkcmFnZ2VkLCBjYWxsYmFjayh0YXJnZXQsY29vcmQpXHJcbiAqIEBleGFtcGxlIFxyXG4gKiBgYGBqc1xyXG4gKiBobS5tYXJrZXIoWzQ4LjgsMi4zXSk7XHJcbiAqXHJcbiAqIGhtLm1hcmtlcih7XHJcbiAqICAgIGNvb3JkOiBbNDguOCwyLjNdLFxyXG4gKiB9KTtcclxuICogXHJcbiAqIGhtLm1hcmtlcih7XHJcbiAqICAgc3ZnOiBcInN2Zy9tYXJrZXIuc3ZnXCIsXHJcbiAqICAgY29sb3I6XCJyZWRcIixcclxuICogICByYXRpbzowLjVcclxuICogfSk7XHJcbiAqIFxyXG4gKiBobS5tYXJrZXIoe1xyXG4gKiAgICBpbWc6IFwiaHR0cDovL3doYXRldmVyLmNvbS9pbWFnZS5wbmdcIixcclxuICogICAgY29vcmQ6IFs0OC44LDIuM11cclxuICogfSk7XHJcbiAqIFxyXG4gKiBobS5tYXJrZXIoe1xyXG4gKiAgICBjb29yZDogWzQ4LjgsMi4zXSxcclxuICogICAgZGF0YTpcIkhlbGxvIHdvcmxkXCIsXHJcbiAqICAgIGJ1YmJsZTogdHJ1ZVxyXG4gKiB9KTtcclxuICogXHJcbiAqIGhtLm1hcmtlcih7XHJcbiAqICAgIGNvb3JkOiBbNDguOCwyLjNdLFxyXG4gKiAgICBkcmFnZ2FibGU6dHJ1ZSxcclxuICogICAgZHJhZ2dlZDogZnVuY3Rpb24odGFyZ2V0LGNvb3JkKSB7Y29uc29sZS5sb2coXCJkcmFnZ2VkIHRvXCIsY29vcmQpO31cclxuICogfSk7XHJcbiAqICBgYGBcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIG1hcmtlcihvcHQpIHtcclxuICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBsYXllcjogXCJkZWZhdWx0XCIsIC8vICBsYXllciBpbiB3aGljaCB0byBhZGQgbWFya2VyXHJcbiAgICAgICAgY29vcmQ6IG51bGwsIC8vICBjb29yZCBvZiB0aGUgbWFya2VyXHJcbiAgICAgICAgaW1nOiBudWxsLCAvLyAgaW1hZ2UgY2FuIGJlIHVybCwgcG5nLCBqcGcuLlxyXG4gICAgICAgIHN2ZzogbnVsbCwgLy8gc3ZnIGZpbGVcclxuICAgICAgICBpY29uOiBudWxsLCAvLyBpY29uIHByZXZpb3VzbHkgY3JlYXRlZFxyXG4gICAgICAgIG9wdDoge30sIC8vIG9wdCBmb3IgaWNvblxyXG4gICAgICAgIHBvaW50ZXJFbnRlcjogbnVsbCwgLy8gIGNhbGxiYWNrKHRhcmdldCxjb29yZCxldilcclxuICAgICAgICBwb2ludGVyQ2xpY2s6IG51bGwsIC8vICBjYWxsYmFjayh0YXJnZXQsY29vcmQsZXYpXHJcbiAgICAgICAgZGF0YTogbnVsbCwgLy8gIHVzZXIgZGF0YVxyXG4gICAgICAgIGJ1YmJsZTogZmFsc2UsIC8vICBzaG93IGEgYnViYmxlIHdpdGggdXNlciBkYXRhXHJcbiAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSwgLy8gIGljb24gaXMgZHJhZ2dhbGJlXHJcbiAgICAgICAgZHJhZ2dlZDogbnVsbCAvLyAgY2FsbGJhY2sodGFyZ2V0LGNvb3JkKVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBjYW4gcGFzcyBkaXJlY3RseSBvbmx5IHRoZSBjb29yZFxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0KSlcclxuICAgICAgICBvcHQuY29vcmQgPSBvcHQ7XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBsZXQgbGF5ZXIgPSBsYXllckZpbmQoc2V0dGluZ3MubGF5ZXIpO1xyXG4gICAgaWYgKCFsYXllcikge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwibGF5ZXIgbm90IGZvdW5kOlwiICsgc2V0dGluZ3MubGF5ZXIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0dGluZ3MuY29vcmQgPSB7XHJcbiAgICAgICAgbGF0OiBzZXR0aW5ncy5jb29yZFswXSxcclxuICAgICAgICBsbmc6IHNldHRpbmdzLmNvb3JkWzFdXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHRoZXNlIHBhcmFtZXRlcnMgY2FuIGJlIGluIG9wdC5vcHQgb3IgZGlyZWN0bHkgaW4gb3B0XHJcbiAgICBpZiAoc2V0dGluZ3MuY29sb3IpIHNldHRpbmdzLm9wdC5jb2xvciA9IHNldHRpbmdzLmNvbG9yO1xyXG4gICAgaWYgKHNldHRpbmdzLnNpemUpIHNldHRpbmdzLm9wdC5zaXplID0gc2V0dGluZ3Muc2l6ZTtcclxuICAgIGlmIChzZXR0aW5ncy5yYXRpbykgc2V0dGluZ3Mub3B0LnJhdGlvID0gc2V0dGluZ3MucmF0aW87XHJcbiAgICBpZiAoc2V0dGluZ3MuYW5jaG9yKSBzZXR0aW5ncy5vcHQuYW5jaG9yID0gc2V0dGluZ3MuYW5jaG9yO1xyXG5cclxuICAgIGxldCBtYXJrZXJPcHQgPSBudWxsO1xyXG4gICAgaWYgKHNldHRpbmdzLmltZyB8fCBzZXR0aW5ncy5zdmcpIHtcclxuICAgICAgICBsZXQgaWNvbiA9IGF3YWl0IGJ1aWxkSWNvbihzZXR0aW5ncyk7XHJcbiAgICAgICAgbWFya2VyT3B0ID0ge1xyXG4gICAgICAgICAgICBpY29uOiBpY29uXHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuaWNvbikge1xyXG4gICAgICAgIG1hcmtlck9wdCA9IHtcclxuICAgICAgICAgICAgaWNvbjogc2V0dGluZ3MuaWNvblxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy9jb25zb2xlLmxvZyhcIm1hcmtlciBzZXR0aW5ncy5jb29yZFwiLCBzZXR0aW5ncy5jb29yZCk7XHJcbiAgICBsZXQgbWFya2VyID0gbmV3IEgubWFwLk1hcmtlcihzZXR0aW5ncy5jb29yZCwgbWFya2VyT3B0KTtcclxuXHJcbiAgICBtYXJrZXIuZHJhZ2dhYmxlID0gc2V0dGluZ3MuZHJhZ2dhYmxlO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5kcmFnZ2VkKSBtYXJrZXIuZHJhZ2dlZCA9IHNldHRpbmdzLmRyYWdnZWQ7XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLmRhdGEpIHtcclxuICAgICAgICBsZXQgZGF0YSA9IHNldHRpbmdzLmRhdGE7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmRhdGEgPT0gXCJfX09QVF9fXCIpIHtcclxuICAgICAgICAgICAgZGF0YSA9IHNldHRpbmdzO1xyXG4gICAgICAgICAgICBkZWxldGUgZGF0YS5jb29yZDtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBkYXRhKVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhW3BdKSBkZWxldGUgZGF0YVtwXTtcclxuICAgICAgICAgICAgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpLnJlcGxhY2UoL1xcbi9nLCBcIjxici8+XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrZXIuc2V0RGF0YShkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBnZXQgY2xpY2sgZnJvbSBtb3VzZVxyXG4gICAgaWYgKHNldHRpbmdzLnBvaW50ZXJFbnRlcikge1xyXG4gICAgICAgIG1hcmtlci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmVudGVyXCIsIGZ1bmN0aW9uIChldikge1xyXG5cclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnBvaW50ZXJFbnRlcih0YXJnZXQsIGNvb3JkTzJBKGNvb3JkKSwgZXYpO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKioqKioqKioqKioqICBjYWxsYmFjayB3aGVuIGNsaWNrIG9uIG1hcmtlciAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyQ2xpY2spIHtcclxuICAgICAgICBtYXJrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRhcFwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnBvaW50ZXJDbGljayh0YXJnZXQsIGNvb3JkTzJBKGNvb3JkKSwgZXYpO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKioqKioqKioqKioqICBzaG93IGEgYnViYmxlIHdoZW4gY2xpY2tpbmcgb24gbWFya2VyICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgaWYgKHNldHRpbmdzLmJ1YmJsZSkge1xyXG4gICAgICAgIG1hcmtlci5hZGRFdmVudExpc3RlbmVyKFwidGFwXCIsIGZ1bmN0aW9uIChldikge1xyXG5cclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB0YXJnZXQuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuXHJcbiAgICAgICAgICAgIGJ1YmJsZVVuaXF1ZShjb29yZE8yQShjb29yZCksIGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGxheWVyLmFkZE9iamVjdChtYXJrZXIpO1xyXG4gICAgcmV0dXJuIG1hcmtlcjtcclxuXHJcbn0gLy9lbmQgb2YgbWFya2VyXHJcblxyXG4vKipcclxuICogZGlzcGxheSBhIHVuaXF1ZSBidWJibGUuIEFzc29jaWF0ZWQgQ1NTIHN0eWxlIGlzIC5IX2liX2JvZHlcclxuICogQGFsaWFzIGhtOmJ1YmJsZVVuaXF1ZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBjb29yZCBvZiB0aGUgYnViYmxlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgaHRtbCB0ZXh0IHRvIGRpc3BsYXlcclxuICovXHJcbmZ1bmN0aW9uIGJ1YmJsZVVuaXF1ZShjb29yZCwgdHh0KSB7XHJcblxyXG4gICAgaWYgKCFfYnViYmxlTWFya2VyKSB7XHJcbiAgICAgICAgX2J1YmJsZU1hcmtlciA9IG5ldyBILnVpLkluZm9CdWJibGUoXHJcbiAgICAgICAgICAgIGNvb3JkQTJPKGNvb3JkKSwge1xyXG4gICAgICAgICAgICAgICAgY29udGVudDogdHh0XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfdWkuYWRkQnViYmxlKF9idWJibGVNYXJrZXIpO1xyXG4gICAgICAgIF9idWJibGVNYXJrZXIuYWRkQ2xhc3MoXCJidWJibGVVbmlxdWVcIik7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBfYnViYmxlTWFya2VyLnNldFBvc2l0aW9uKGNvb3JkQTJPKGNvb3JkKSk7XHJcbiAgICAgICAgX2J1YmJsZU1hcmtlci5zZXRDb250ZW50KHR4dCk7XHJcbiAgICAgICAgX2J1YmJsZU1hcmtlci5vcGVuKCk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIGhpZGUgYSB1bmlxdWUgYnViYmxlXHJcbiAqIEBhbGlhcyBobTpidWJibGVVbmlxdWVIaWRlXHJcbiAqL1xyXG5mdW5jdGlvbiBidWJibGVVbmlxdWVIaWRlKCkge1xyXG4gICAgaWYgKCFfYnViYmxlTWFya2VyKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIF9idWJibGVNYXJrZXIuY2xvc2UoKTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIERyYXcgYSBwb2x5bGluZS4gXHJcbiAqIEBhbGlhcyBobTpwb2x5bGluZVxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9ICAgb3B0aW9ucyB0byBkcmF3IHBvbHlsaW5lXHJcbiAqIEBwYXJhbSBbb3B0LmxheWVyXSB7U3RyaW5nfSBvcHRpb25hbCBsYXllciB0byB1c2UgXHJcbiAqIEBwYXJhbSBbb3B0LmNvb3Jkc10ge2FycmF5fSBhcnJheSBvZiBjb29yZHMsIGFzIFxcW1xcWzQ4LjgsMi4zXFxdLFxcWzQ4Ljg1LDIuNFxcXSwuLi4gXFxdXHJcbiAqIEBwYXJhbSBbb3B0LnN0eWxlXSB7b2JqZWN0fSBvcHRpb25hbCBncmFwaGljIHN0eWxlXHJcbiAqIEBwYXJhbSBbb3B0LmxpbmVXaWR0aD00XSB7bnVtYmVyfSBsaW5lIHdpZHRoXHJcbiAqIEBwYXJhbSBbb3B0LnN0eWxlLnN0cm9rZUNvbG9yPXJnYmEoMCwgMTI4LCAyNTUsIDAuNyldIHtzdHJpbmd9IGxpbmUgY29sb3JcclxuICogQHBhcmFtIFtvcHQuYXJyb3dzXSB7b2JqZWN0fSBvcHRpb25hbCBhcnJvd1xyXG4gKiBAcGFyYW0gW29wdC5kYXRhXSB7U3RyaW5nfSBvcHRpb25hbCB1c2VyIGRhdGFcclxuICogQHBhcmFtIFtvcHQucG9pbnRlckNsaWNrXSB7ZnVuY3Rpb259IG9wdGlvbmFsIGNhbGxiYWNrIGlmIGNsaWNrIG9uIGxpbmUuIGZvcm1hdCBjYWxsYmFjayh0YXJnZXQsY29vcmQsZXZlbnQpXHJcbiAqIEBwYXJhbSBbb3B0LnBvaW50ZXJlbnRlcl0ge2Z1bmN0aW9ufSBvcHRpb25hbCBjYWxsYmFjayBpZiBtb3VzZSBlbnRlcnMgb24gbGluZS4gZm9ybWF0IGNhbGxiYWNrKHRhcmdldCxjb29yZCxldmVudClcclxuICogQHBhcmFtIFtvcHQucG9pbnRlckxlYXZlXSB7ZnVuY3Rpb259IG9wdGlvbmFsIGNhbGxiYWNrIGlmIG1vdXNlIGxlYXZlcyB0aGUgbGluZS4gZm9ybWF0IGNhbGxiYWNrKHRhcmdldCxjb29yZCxldmVudClcclxuICogQHBhcmFtIFtvcHQuel0ge251bWJlcn0gb3B0aW9uYWwgeiBsZXZlbFxyXG4gKiBgYGBqc1xyXG4gKiBobS5wb2x5bGluZSh7XHJcbiAqICAgIGNvb3JkczogW1s0OC44LDIuM10sWzQ4Ljg1LDIuNF0sWzQ4LjksMi42XV0sXHJcbiAqICAgIGxheWVyOlwibGF5ZXIxXCJcclxuICogfSk7XHJcbiAqIFxyXG4gKiBobS5wb2x5bGluZSh7XHJcbiAqICAgIGNvb3JkczogY29vcmRzLFxyXG4gKiAgICBzdHlsZToge1xyXG4gKiAgICAgICAgbGluZVdpZHRoOiA0LFxyXG4gKiAgICAgICAgc3Ryb2tlQ29sb3I6IFwicmVkXCJcclxuICogICAgfSxcclxuICogfSk7XHJcbiAqIFxyXG4gKiBobS5wb2x5bGluZSh7XHJcbiAqICAgIGNvb3JkczogY29vcmRzLFxyXG4gKiAgICBkYXRhOlwiSGVsbG8gV29ybGRcIixcclxuICogfSk7XHJcbiAqICBgYGBcclxuICovXHJcbmZ1bmN0aW9uIHBvbHlsaW5lKG9wdCkge1xyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIGxheWVyOiBcImRlZmF1bHRcIixcclxuICAgICAgICBjb29yZHM6IG51bGwsIC8vIGNvb3JkcyBpcyBsaXN0IG9mIGFycmF5IG9mIFtsYXQsbG5nXSBvciBhcnJheSBvZiBvYmplY3Qgd2l0aCB7bGF0Oixsbmc6fVxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogNCxcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwicmdiYSgwLCAxMjgsIDI1NSwgMC43KVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhcnJvd3M6IG51bGwsXHJcbiAgICAgICAgZGF0YTogbnVsbCwgLy8gb3B0aW9uYWwgdXNlciBkYXRhIFxyXG4gICAgICAgIHo6IG51bGwsXHJcbiAgICAgICAgcG9pbnRlckNsaWNrOiBudWxsLCAvLyBjbGlja1xyXG4gICAgICAgIHBvaW50ZXJFbnRlcjogbnVsbCwgLy8gY2FsbCBiYWNrXHJcbiAgICAgICAgcG9pbnRlckxlYXZlOiBudWxsIC8vIGNhbGwgYmFja1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHQpKSAvLyBkaXJlY3RlbWVudCBsZXMgY29vcmRcclxuICAgICAgICBvcHQgPSB7XHJcbiAgICAgICAgICAgIGNvb3Jkczogb3B0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIGxldCBsYXllciA9IGxheWVyRmluZChzZXR0aW5ncy5sYXllcik7XHJcbiAgICBpZiAoIWxheWVyKSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJsYXllciBub3QgZm91bmQ6XCIgKyBzZXR0aW5ncy5sYXllcik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXNldHRpbmdzLmNvb3Jkcykge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiUG9seWxpbmU6IGNvb3JkcyBub3QgZm91bmQ6XCIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHN0cmlwID0gbmV3IEguZ2VvLlN0cmlwKCk7XHJcblxyXG4gICAgc2V0dGluZ3MuY29vcmRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgc3RyaXAucHVzaExhdExuZ0FsdChwb2ludFswXSwgcG9pbnRbMV0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IHBvbHlsaW5lID0gbmV3IEgubWFwLlBvbHlsaW5lKHN0cmlwLCB7XHJcbiAgICAgICAgc3R5bGU6IHNldHRpbmdzLnN0eWxlLFxyXG4gICAgICAgIGRhdGE6IHNldHRpbmdzLmRhdGEsXHJcbiAgICAgICAgYXJyb3dzOiBzZXR0aW5ncy5hcnJvd3NcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFogaW5kZXhcclxuICAgIGlmIChzZXR0aW5ncy56KSBwb2x5bGluZS5zZXRaSW5kZXgoc2V0dGluZ3Mueik7XHJcbiAgICAvLyB1c2VyIGRhdGFcclxuICAgIGlmIChzZXR0aW5ncy5kYXRhKSBwb2x5bGluZS5zZXREYXRhKHNldHRpbmdzLmRhdGEpO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyRW50ZXIpXHJcbiAgICAgICAgcG9seWxpbmUuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnBvaW50ZXJFbnRlcih0YXJnZXQsIGNvb3JkTzJBKGNvb3JkKSwgZXYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgaWYgKHNldHRpbmdzLnBvaW50ZXJMZWF2ZSlcclxuICAgICAgICBwb2x5bGluZS5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckxlYXZlKHRhcmdldCwgY29vcmRPMkEoY29vcmQpLCBldik7XHJcbiAgICAgICAgfSk7XHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckNsaWNrKVxyXG4gICAgICAgIHBvbHlsaW5lLmFkZEV2ZW50TGlzdGVuZXIoXCJ0YXBcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyQ2xpY2sodGFyZ2V0LCBjb29yZE8yQShjb29yZCksIGV2KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBsYXllci5hZGRPYmplY3QocG9seWxpbmUpO1xyXG5cclxuICAgIHJldHVybiBwb2x5bGluZTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBEcmF3IGEgcG9seWdvblxyXG4gKiBAYWxpYXMgaG06cG9seWdvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0ICBvcHRpb25zIHRvIGRyYXcgYSBwb2x5Z29uLiBTYW1lIG9wdGlvbnMgYXMgaG0ucG9seWxpbmVcclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb24ob3B0KSB7XHJcbiAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbGF5ZXI6IFwiZGVmYXVsdFwiLFxyXG4gICAgICAgIGNvb3JkczogXCJcIiwgLy8gY29vcmRzIGlzIGFycmF5IG9mIFtsYXQsbG5nXSBvciBhcnJheSBvZiB7bGF0Oixsbmc6fVxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogNCxcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwicmdiYSgwLCAxMjgsIDI1NSwgMC43KVwiLFxyXG4gICAgICAgICAgICBmaWxsQ29sb3I6IFwicmdiYSgwLCAxMjgsIDI1NSwgMC43KVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdHlsZUhvdmVyOiBudWxsLCAvLyBzdHlsZSBzaSBtb3VzZSBvdmVyXHJcbiAgICAgICAgYXJyb3dzOiBudWxsLFxyXG4gICAgICAgIGRhdGE6IG51bGwsIC8vIGFkZGl0aW9uYWwgZGF0YSB0byBjYXJyeVxyXG4gICAgICAgIHo6IG51bGwsXHJcbiAgICAgICAgcG9pbnRlckNsaWNrOiBudWxsLCAvLyBjbGlja1xyXG4gICAgICAgIHBvaW50ZXJFbnRlcjogbnVsbCwgLy8gY2FsbCBiYWNrXHJcbiAgICAgICAgcG9pbnRlckxlYXZlOiBudWxsIC8vIGNhbGwgYmFja1xyXG4gICAgfTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdCkpIC8vIGRpcmVjdGVtZW50IGxlcyBjb29yZFxyXG4gICAgICAgIG9wdCA9IHtcclxuICAgICAgICAgICAgY29vcmRzOiBvcHRcclxuICAgICAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBsZXQgbGF5ZXIgPSBsYXllckZpbmQoc2V0dGluZ3MubGF5ZXIpO1xyXG4gICAgaWYgKCFsYXllcikge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwibGF5ZXIgbm90IGZvdW5kOlwiICsgc2V0dGluZ3MubGF5ZXIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzZXR0aW5ncy5jb29yZHMpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIlBvbHlsaW5lOiBjb29yZHMgbm90IGZvdW5kOlwiKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzdHJpcCA9IG5ldyBILmdlby5TdHJpcCgpO1xyXG4gICAgc2V0dGluZ3MuY29vcmRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgc3RyaXAucHVzaExhdExuZ0FsdChwb2ludFswXSwgcG9pbnRbMV0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IHBvbHlnb24gPSBuZXcgSC5tYXAuUG9seWdvbihzdHJpcCwge1xyXG4gICAgICAgIHN0eWxlOiBzZXR0aW5ncy5zdHlsZSxcclxuICAgICAgICBkYXRhOiBzZXR0aW5ncy5kYXRhLFxyXG4gICAgICAgIGFycm93czogc2V0dGluZ3MuYXJyb3dzXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoc2V0dGluZ3MuZGF0YSkgcG9seWdvbi5zZXREYXRhKHNldHRpbmdzLmRhdGEpO1xyXG4gICAgLy8gWiBpbmRleFxyXG4gICAgaWYgKHNldHRpbmdzLnopIHBvbHlsaW5lLnNldFpJbmRleChzZXR0aW5ncy56KTtcclxuXHJcbiAgICAvLyBzaSB1biBzdHlsZSBkZSBob3ZlclxyXG4gICAgaWYgKHNldHRpbmdzLnN0eWxlSG92ZXIpIHtcclxuICAgICAgICBwb2x5Z29uLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIHRhcmdldC5zZXRTdHlsZShzZXR0aW5ncy5zdHlsZUhvdmVyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwb2x5Z29uLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIHRhcmdldC5zZXRTdHlsZShzZXR0aW5ncy5zdHlsZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLnBvaW50ZXJFbnRlcilcclxuICAgICAgICBwb2x5Z29uLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gdGFyZ2V0LmdldERhdGEoKTtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnBvaW50ZXJFbnRlcih0YXJnZXQsIGNvb3JkTzJBKGNvb3JkKSwgZXYsIGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgaWYgKHNldHRpbmdzLnBvaW50ZXJMZWF2ZSlcclxuICAgICAgICBwb2x5Z29uLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gdGFyZ2V0LmdldERhdGEoKTtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnBvaW50ZXJMZWF2ZSh0YXJnZXQsIGNvb3JkTzJBKGNvb3JkKSwgZXYsIGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgaWYgKHNldHRpbmdzLnBvaW50ZXJDbGljaylcclxuICAgICAgICBwb2x5Z29uLmFkZEV2ZW50TGlzdGVuZXIoXCJ0YXBcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gdGFyZ2V0LmdldERhdGEoKTtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnBvaW50ZXJDbGljayh0YXJnZXQsIGNvb3JkTzJBKGNvb3JkKSwgZXYsIGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIGxheWVyLmFkZE9iamVjdChwb2x5Z29uKTtcclxuXHJcbiAgICByZXR1cm4gcG9seWdvbjtcclxufSAvLyBlbmQgb2YgcG9seWdvblxyXG5cclxuLyoqXHJcbiAqIGRyYXcgYSBjaXJjbGVcclxuICogQGFsaWFzIGhtOmNpcmNsZVxyXG4gKiBAcGFyYW0gb3B0IHsqfSAgIG9wdGlvbiBmb3IgY2lyY2xlXHJcbiAqIEBwYXJhbSBbb3B0LmxheWVyXSB7U3RyaW5nfSBvcHRpb25hbCBsYXllciB0byB1c2UgXHJcbiAqIEBwYXJhbSBbb3B0LmNvb3JkXSB7YXJyYXl9IGNlbnRlciBvZiB0aGUgY2lyY2xlLCBhcyBcXFs0OC44LDIuM1xcXVxyXG4gKiBAcGFyYW0gW29wdC5yYWRpdXNdIHtudW1iZXJ9IHJhZGl1cyBpbiBtZXRlclxyXG4gKiBAcGFyYW0gW29wdC5zdHlsZV0ge29iamVjdH0gb3B0aW9uYWwgZ3JhcGhpYyBzdHlsZVxyXG4gKiBAcGFyYW0gW29wdC5zdHlsZS5zdHJva2VDb2xvcl0ge3N0cmluZ30gY29sb3Igb2YgcGVyaW1ldGVyXHJcbiAqIEBwYXJhbSBbb3B0LnN0eWxlLmxpbmVXaWR0aF0ge251bWJlcn0gbGluZSB3aWR0aFxyXG4gKiBAcGFyYW0gW29wdC5zdHlsZS5maWxsQ29sb3JdIHtzdHJpbmd9IGZpbGwgY29sb3JcclxuICovXHJcbmZ1bmN0aW9uIGNpcmNsZShvcHQpIHtcclxuICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBsYXllcjogXCJkZWZhdWx0XCIsXHJcbiAgICAgICAgY29vcmQ6IG51bGwsXHJcbiAgICAgICAgcmFkaXVzOiAxMDAsIC8vIG1ldGVyc1xyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBcInJnYmEoNTUsIDg1LCAxNzAsIDAuMilcIiwgLy8gQ29sb3Igb2YgdGhlIHBlcmltZXRlclxyXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXHJcbiAgICAgICAgICAgIGZpbGxDb2xvcjogXCJyZ2JhKDAsIDEyOCwgMCwgMC4xKVwiIC8vIENvbG9yIG9mIHRoZSBjaXJjbGVcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgbGV0IGxheWVyID0gbGF5ZXJGaW5kKHNldHRpbmdzLmxheWVyKTtcclxuICAgIGlmICghbGF5ZXIpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcImxheWVyIG5vdCBmb3VuZDpcIiArIHNldHRpbmdzLmxheWVyKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG4gICAgbGV0IGNpcmNsZSA9IG5ldyBILm1hcC5DaXJjbGUoXHJcbiAgICAgICAgLy8gVGhlIGNlbnRyYWwgcG9pbnQgb2YgdGhlIGNpcmNsZVxyXG4gICAgICAgIGNvb3JkQTJPKHNldHRpbmdzLmNvb3JkKSxcclxuICAgICAgICAvLyBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUgaW4gbWV0ZXJzXHJcbiAgICAgICAgc2V0dGluZ3MucmFkaXVzLCB7XHJcbiAgICAgICAgICAgIHN0eWxlOiBzZXR0aW5ncy5zdHlsZVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgbGF5ZXIuYWRkT2JqZWN0KGNpcmNsZSk7XHJcbiAgICByZXR1cm4gY2lyY2xlO1xyXG59XHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogd2F0Y2ggcG9zaXRpb24gb24gSFRNTDUgcG9zaXRpb24uIHJlcXVpcmVzIEhUVFBTXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06bG9jYXRlTWVcclxuICogQHBhcmFtIGNhbGxiYWNrIHtmdW5jdGlvbn0gIGNhbGxiYWNrIHdoZW4gY29vcmQgY2hhbmdlcy4gRm9ybWF0OiBjYWxsYmFjayhjb29yZCxhY2N1cmFjeSkgXHJcbiAqIEBwYXJhbSBvcHQge09iamVjdH0gb3B0aW9uYWwgZ3JhcGhpYyBvcHRpb25zXHJcbiAqIEBwYXJhbSBbb3B0LnBvc2l0aW9uXSB7b2JqZWN0fSAgZ3JhcGhpYyBvcHRpb25zIGZvciBjZW50ZXIuIFNlZSBidWlsZEljb25cclxuICogQHBhcmFtIFtvcHQucG9zaXRpb24uc3ZnXSB7c3RyaW5nfSAgc3ZnIGZpbGVcclxuICogQHBhcmFtIFtvcHQucG9zaXRpb24uY29sb3JdIHtzdHJpbmd9ICBjb2xvciBmb3IgIHtjb2xvcn0gdGFnXHJcbiAqIEBwYXJhbSBbb3B0LnBvc2l0aW9uLnNpemVdIHtudW1iZXJ9ICBzaXplIG9mIGljb25cclxuICogQHBhcmFtIFtvcHQucG9zaXRpb24uYW5jaG9yXSB7bnVtYmVyfSAgYW5jaG9yIG9mIGljb25cclxuICogQHBhcmFtIFtvcHQuYWNjdXJhY3ldIHtvYmplY3R9ICBncmFwaGljIG9wdGlvbnMgZm9yIGFjY3VyYWN5IHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSBbb3B0LmFjY3VyYWN5LnN0cm9rZUNvbG9yXSB7U3RyaW5nfSAgY29sb3Igb2YgY2lyY2xlIGxpbmUgcmVwcmVzZW50aW5nIGFjY3VyYWN5IGFyZWFcclxuICogQHBhcmFtIFtvcHQuYWNjdXJhY3kubGluZVdpZHRoXSB7bnVtYmVyfSAgd2lkdGggb2YgbGluZSBvZiBjaXJjbGVcclxuICogQHBhcmFtIFtvcHQuYWNjdXJhY3kuZmlsbENvbG9yXSB7U3RyaW5nfSAgZmlsbCBjb2xvciBvZiBjaXJjbGUgcmVwcmVzZW50aW5nIGFjY3VyYWN5IGFyZWFcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGxvY2F0ZU1lKGNhbGxiYWNrLCBvcHQpIHtcclxuXHJcbiAgICAvLyBpZiBubyBjYWxsYmFjaywgcmVtb3ZlIHRoZSB3YXRjaFxyXG4gICAgaWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xyXG4gICAgICAgIGlmICghY2FsbGJhY2sgJiYgX2xvY2F0ZU1lKSB7XHJcbiAgICAgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKF9sb2NhdGVNZSk7XHJcbiAgICAgICAgICAgIF9sb2NhdGVNZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICAgICAgICAgIHN2ZzogXCJzdmcvdGFyZ2V0LnN2Z1wiLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiYmxhY2tcIixcclxuICAgICAgICAgICAgICAgIGFuY2hvcjogXCJjZW50ZXJcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY2N1cmFjeToge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwicmdiYSgwLCAxMjgsIDAsIDAuOClcIiwgLy8gQ29sb3Igb2YgdGhlIHBlcmltZXRlclxyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAyLFxyXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yOiBcInJnYmEoMCwgMTI4LCAwLCAwLjQpXCIgLy8gQ29sb3Igb2YgdGhlIGNpcmNsZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgICAgICBsZXQgaWNvbkNyb3NzSGFpciA9IGF3YWl0IGJ1aWxkSWNvbih7XHJcbiAgICAgICAgICAgIHN2Zzogc2V0dGluZ3MucG9zaXRpb24uc3ZnLFxyXG4gICAgICAgICAgICBpbWc6IHNldHRpbmdzLnBvc2l0aW9uLmltZyxcclxuICAgICAgICAgICAgb3B0OiBzZXR0aW5ncy5wb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy9uYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKGZ1bmN0aW9uIHBvcyhwb3NpdGlvbikge1xyXG4gICAgICAgIF9sb2NhdGVNZSA9IG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKChwb3NpdGlvbikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZ3BzID0gW3Bvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSwgcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZV07XHJcblxyXG4gICAgICAgICAgICBsYXllckVtcHR5KFwiX2dwc1wiKTtcclxuXHJcbiAgICAgICAgICAgIC8qIGNpcmNsZSBzaG93aW5nIHRoZSBhY2N1cmFjeSByYWRpdXMqL1xyXG4gICAgICAgICAgICBjaXJjbGUoe1xyXG4gICAgICAgICAgICAgICAgbGF5ZXI6IFwiX2dwc1wiLFxyXG4gICAgICAgICAgICAgICAgY29vcmQ6IGdwcyxcclxuICAgICAgICAgICAgICAgIHJhZGl1czogcG9zaXRpb24uY29vcmRzLmFjY3VyYWN5LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHNldHRpbmdzLmFjY3VyYWN5XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbWFya2VyKHtcclxuICAgICAgICAgICAgICAgIGxheWVyOiBcIl9ncHNcIixcclxuICAgICAgICAgICAgICAgIGNvb3JkOiBncHMsXHJcbiAgICAgICAgICAgICAgICBpY29uOiBpY29uQ3Jvc3NIYWlyXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2soZ3BzLCBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3kpO1xyXG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbXNnID0gXCJcIjtcclxuICAgICAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGVycm9yLlBFUk1JU1NJT05fREVOSUVEOlxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBcIlVzZXIgZGVuaWVkIHRoZSByZXF1ZXN0IGZvciBHZW9sb2NhdGlvbi5cIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgZXJyb3IuUE9TSVRJT05fVU5BVkFJTEFCTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiTG9jYXRpb24gaW5mb3JtYXRpb24gaXMgdW5hdmFpbGFibGUuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGVycm9yLlRJTUVPVVQ6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwidGltZWQgb3V0LlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBlcnJvci5VTktOT1dOX0VSUk9SOlxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJIVE1MNSBsb2NhdGlvbiBlcnJvcjpcIiArIG1zZyk7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICBlbmFibGVIaWdoQWNjdXJhY3k6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJubyBIVE1MNSBnZW9sb2NhdGlvbiBjYXBhYmlsaXRpZXNcIik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBwZXJmb3JtIGEgc2NyZWVuc2hvdCBvZiB0aGUgbWFwIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aXRoIHRoZSBkYXRhXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06c2NyZWVuc2hvdFxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9IG9wdGlvbnMgZm9yIHNjcmVlbnNob3RcclxuICogQHBhcmFtIFtvcHQubmFtZV0ge3N0cmluZ30gZmlsZW5hbWUgZm9yIGRvd25sb2FkXHJcbiAqIEBwYXJhbSBbb3B0LnVpXSB7Ym9vbGVhbn0gdHJ1ZSB0byB1aSAoc2NhbGUsIGV0Yy4uKSBpbiBzY3JlZW5zaG90XHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gb3B0aW9ucyBmb3Igc2NyZWVuc2hvdFxyXG4gKiBcclxuICogQHJldHVybnMge2RhdGF9IGJpbmFyeSBkYXRhIG9mIGltYWdlXHJcbiAqIFxyXG4gKi9cclxuZnVuY3Rpb24gc2NyZWVuc2hvdChvcHQpIHtcclxuICAgIGxldCBwYXJhID0gbnVsbDtcclxuICAgIGlmIChvcHQgJiYgb3B0LnVpKVxyXG4gICAgICAgIHBhcmEgPSBbX3VpXTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShcclxuICAgICAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIF9tYXAuY2FwdHVyZShmdW5jdGlvbiAoY2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNhbnZhcylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KFwiTWFwIHNjcmVlbnNob3Qgbm90IHN1cHBvcnRlZFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoKTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHQgJiYgb3B0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuaHJlZiA9IGRhdGFVUkw7XHJcbiAgICAgICAgICAgICAgICAgICAgYS50YXJnZXQgPSBcIl9ibGFua1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuZG93bmxvYWQgPSBvcHQubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuY2xpY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YVVSTCk7XHJcbiAgICAgICAgICAgIH0sIHBhcmEpO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0TWFwSHRtbEl0ZW0oKSB7XHJcbiAgICByZXR1cm4gX2h0bWxJdGVtO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNYXAoKSB7XHJcbiAgICByZXR1cm4gX21hcDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0QmVoYXZpb3IoKSB7XHJcbiAgICByZXR1cm4gX2JlaGF2aW9yO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0VUkoKSB7XHJcbiAgICByZXR1cm4gX3VpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGNvb3JkTzJBOiBjb29yZE8yQSxcclxuICAgIGNvb3JkQTJPOiBjb29yZEEyTyxcclxuICAgIGdldE1hcDogZ2V0TWFwLFxyXG4gICAgZ2V0VUk6IGdldFVJLFxyXG4gICAgZ2V0QmVoYXZpb3I6IGdldEJlaGF2aW9yLFxyXG4gICAgZ2V0TWFwSHRtbEl0ZW06IGdldE1hcEh0bWxJdGVtLFxyXG4gICAgbWFwOiBtYXAsXHJcbiAgICBnZXRBdmFpbGFibGVNYXBTdHlsZTogZ2V0QXZhaWxhYmxlTWFwU3R5bGUsXHJcbiAgICBzZXRTY2hlbWU6IHNldFNjaGVtZSxcclxuICAgIGxheWVyQ3JlYXRlOiBsYXllckNyZWF0ZSxcclxuICAgIGxheWVyRmluZDogbGF5ZXJGaW5kLFxyXG4gICAgbGF5ZXJEZWxldGU6IGxheWVyRGVsZXRlLFxyXG4gICAgbGF5ZXJTZXRWaXNpYmlsaXR5OiBsYXllclNldFZpc2liaWxpdHksXHJcbiAgICBsYXllckVtcHR5OiBsYXllckVtcHR5LFxyXG4gICAgYnVpbGRJY29uOiBidWlsZEljb24sXHJcbiAgICBidWJibGVVbmlxdWU6IGJ1YmJsZVVuaXF1ZSxcclxuICAgIGJ1YmJsZVVuaXF1ZUhpZGU6IGJ1YmJsZVVuaXF1ZUhpZGUsXHJcbiAgICBtYXJrZXI6IG1hcmtlcixcclxuICAgIGNpcmNsZTogY2lyY2xlLFxyXG4gICAgcG9seWxpbmU6IHBvbHlsaW5lLFxyXG4gICAgcG9seWdvbjogcG9seWdvbixcclxuICAgIGdldENlbnRlcjogZ2V0Q2VudGVyLFxyXG4gICAgc2V0Q2VudGVyOiBzZXRDZW50ZXIsXHJcbiAgICBnZXRab29tOiBnZXRab29tLFxyXG4gICAgc2V0Wm9vbTogc2V0Wm9vbSxcclxuICAgIGdldFZpZXdCQjogZ2V0Vmlld0JCLFxyXG4gICAgc2V0Vmlld0JCOiBzZXRWaWV3QkIsXHJcbiAgICBsb2NhdGVNZTogbG9jYXRlTWUsXHJcbiAgICBzY3JlZW5zaG90OiBzY3JlZW5zaG90XHJcblxyXG59OyIsIlwidXNlIHN0cmljdFwiO1xyXG5jb25zdCBjbSA9IHJlcXVpcmUoXCJjb21tb25cIik7XHJcblxyXG5cclxuLyoqXHJcbiAqIFBsYWNlIEF1dG9TdWdnZXN0XHJcbiAqIEAgYXN5bmNcclxuICogQGFsaWFzIGhtOnBsYWNlQXV0b1N1Z2dlc3RcclxuICogQHBhcmFtIG9wdCB7T2JqZWN0fSBvcHRpb25zIG9mIGF1dG9zdWdnZXN0XHJcbiAqIEBwYXJhbSBvcHQuc2VhcmNoIHtTdHJpbmd9IHNlYXJjaCBzdHJpbmdcclxuICogQHBhcmFtIG9wdC5jZW50ZXIge0Nvb3JkfSBjZW50ZXIgc2VhcmNoIGFyb3VuZCB0aGlzIGNvb3JkXHJcbiAqIEByZXR1cm4gIHtQcm9taXNlfSBBcnJheSBvZiB7cmVzLHRpdGxlLHZhbHVlLGNvb3JkfVxyXG4gKi9cclxuZnVuY3Rpb24gcGxhY2VBdXRvU3VnZ2VzdChvcHQpIHtcclxuXHJcbiAgICBjb25zdCBwYXJhbXMgPSBjbS5hZGRDcmVkZW50aWFscyh7XHJcbiAgICAgICAgYXQ6IG9wdC5jZW50ZXJbMF0gKyBcIixcIiArIG9wdC5jZW50ZXJbMV0sXHJcbiAgICAgICAgcTogb3B0LnNlYXJjaFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXJsID0gY20uYnVpbGRVcmwoXCJwbGFjZXNcIiwgXCJhcGkuaGVyZS5jb20vcGxhY2VzL3YxL2F1dG9zdWdnZXN0XCIpO1xyXG4gICAgcmV0dXJuIGNtLmhlcmVSZXN0KHVybCwgcGFyYW1zLCBcImdldFwiLCBmYWxzZSlcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcGxhY2VzID0gcmVzLmJvZHkucmVzdWx0cy5maWx0ZXIocGxhY2UgPT4gcGxhY2UudmljaW5pdHkpOyAvLyBrZWVwIG9ubHkgaWYgdmljaW5pdHkgZmllbGQgaXMgcHJlc2VudFxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBsYWNlcy5tYXAocGxhY2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogcGxhY2UudGl0bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgLy92YWx1ZTogcGxhY2UudGl0bGUgKyAnLCAnICsgcGxhY2UudmljaW5pdHkucmVwbGFjZSgvPGJyXFwvPi9nLCBcIiwgXCIpICsgJyAoJyArIHBsYWNlLmNhdGVnb3J5ICsgJyknLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwbGFjZS50aXRsZSArIFwiLCBcIiArIHBsYWNlLnZpY2luaXR5LnJlcGxhY2UoLzxiclxcLz4vZywgXCIsIFwiKSxcclxuICAgICAgICAgICAgICAgICAgICBjb29yZDogcGxhY2UucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzOiBwbGFjZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBwbGFjZUF1dG9TdWdnZXN0OiBwbGFjZUF1dG9TdWdnZXN0XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5jb25zdCBjbSA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiBjb21wdXRlIGEgcm91dGUgd2l0aCBvcHRpb25hbCB3YXlwb29pbnRzLiBbU2VlIG1vcmUgaW5mbyBvbiBvcHRpb25hbCBwYXJhbWV0ZXJzXShodHRwOi8vZG9jdW1lbnRhdGlvbi5kZXZlbG9wZXIuaGVyZS5jb20vcGRmL3JvdXRpbmdfaGxwLzcuMi4xMDAvUm91dGluZyUyMEFQSSUyMHY3LjIuMTAwJTIwRGV2ZWxvcGVyJ3MlMjBHdWlkZS5wZGYpXHJcbiAqIEBhbGlhcyBobTpyb3V0ZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlIC0gc291cmNlIGFzIFxcW2xhdCxsbmdcXF0uIENhbiBiZSBhcnJheSBvZiBcXFtsYXQsbG5nXFxdIHRvIGRlZmluZSB3YXlwb2ludHNcclxuICogQHBhcmFtIHtvYmplY3R9IGRlc3QgLSBkZXN0IGFzIFxcW2xhdCxsbmdcXF0uIENhbiBiZSBhcnJheSBvZiBcXFtsYXQsbG5nXFxdIHRvIGRlZmluZSB3YXlwb2ludHNcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSByb3V0ZSBvcHRpb25zIFxyXG4gKiBAcGFyYW0gW29wdC5tb2RlPWZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZGlzYWJsZWRdIHtzdHJpbmd9ICByb3V0aW5nIG1vZGVcclxuICogQHBhcmFtIFtvcHQucm91dGVhdHRyaWJ1dGVzPXdheXBvaW50cyxzdW1tYXJ5LHNoYXBlXSB7c3RyaW5nfSAgcm91dGUgYXR0cmlidXRlc1xyXG4gKiBAcGFyYW0gW29wdC5tYW5ldXZlcmF0dHJpYnV0ZXM9ZGlyZWN0aW9uLGFjdGlvbl0ge3N0cmluZ30gIG1hbm9ldXZlciBhdHRyaWJ1dGVzXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlfSByZXR1cm5zIHsgc3VtbWFyeTogb2JqZWN0LCBjb29yZHM6YXJyYXkscm91dGU6IG9iamVjdCwgYm9keTpvYmplY3R9LiBjb29yZHMgaXMgYXJyYXkgb2YgY29vcmQsIHRvIGJlIHVzZWQgd2l0aCBobS5wb2x5bGluZS4gXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgKiBgYGBqc1xyXG4gICogY29uc3QgcmVzID0gYXdhaXQgaG0ucm91dGUoWzQ4LjgsMi4zXSxbNDguNywyLjVdKTtcclxuICAqIGNvbnNvbGUubG9nIChyZXMuc3VtbWFyeSk7XHJcbiAgKiBcclxuICAqIGNvbnN0IHJlcyA9IGF3YWl0IGhtLnJvdXRlKFtbNDguOCwyLjNdLFs0OC45LDIuN11dLCBbNDkuMywyLjVdKTtcclxuICAqIGNvbnNvbGUubG9nIChyZXMucm91dGUpOyBcclxuICAqIFxyXG4gICogY29uc3QgcmVzID0gYXdhaXQgaG0ucm91dGUoWzQ4LjgsMi4zXSwgW1s0OC45LDIuN10sIFs0OS4zLDIuNV1dKTtcclxuICAqIGNvbnNvbGUubG9nIChyZXMuc3VtbWFyeSk7IFxyXG4gICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiByb3V0ZShzb3VyY2UsIGRlc3QsIG9wdCkge1xyXG5cclxuICAgIGNvbnN0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIG1vZGU6IFwiZmFzdGVzdDtjYXI7dHJhZmZpYzpkaXNhYmxlZFwiLFxyXG4gICAgICAgIHJlcHJlc2VudGF0aW9uOiBcImxpbmtQYWdpbmdcIixcclxuICAgICAgICByb3V0ZWF0dHJpYnV0ZXM6IFwid2F5cG9pbnRzLHN1bW1hcnksc2hhcGVcIixcclxuICAgICAgICBtYW5ldXZlcmF0dHJpYnV0ZXM6IFwiZGlyZWN0aW9uLGFjdGlvblwiXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHBhcmFtcyA9IGNtLmFkZENyZWRlbnRpYWxzKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIC8vIDEgc2V1bCBzb3VyY2Ugb3UgYXJyYXkgZGUgc291cmNlID9cclxuICAgIGxldCBpZCA9IDA7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VbMF0pKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IHNvdXJjZVtpXTtcclxuICAgICAgICAgICAgcGFyYW1zW1wid2F5cG9pbnRcIiArIGlkKytdID0gY29vcmRbMF0gKyBcIixcIiArIGNvb3JkWzFdO1xyXG4gICAgICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICBwYXJhbXNbXCJ3YXlwb2ludFwiICsgaWQrK10gPSBzb3VyY2VbMF0gKyBcIixcIiArIHNvdXJjZVsxXTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZXN0WzBdKSlcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IGRlc3RbaV07XHJcbiAgICAgICAgICAgIHBhcmFtc1tcIndheXBvaW50XCIgKyBpZCsrXSA9IGNvb3JkWzBdICsgXCIsXCIgKyBjb29yZFsxXTtcclxuICAgICAgICB9XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcGFyYW1zW1wid2F5cG9pbnRcIiArIGlkKytdID0gZGVzdFswXSArIFwiLFwiICsgZGVzdFsxXTtcclxuXHJcbiAgICBjb25zdCB1cmwgPSBjbS5idWlsZFVybChcInJvdXRlXCIsIFwiYXBpLmhlcmUuY29tL3JvdXRpbmcvNy4yL2NhbGN1bGF0ZXJvdXRlLmpzb25cIik7XHJcbiAgICByZXR1cm4gY20uaGVyZVJlc3QodXJsLCBwYXJhbXMsIFwicG9zdFwiKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByb3V0ZSA9IHJlcy5ib2R5LnJlc3BvbnNlLnJvdXRlWzBdO1xyXG4gICAgICAgICAgICBjb25zdCBzdW1tYXJ5ID0gcm91dGUuc3VtbWFyeTtcclxuICAgICAgICAgICAgY29uc3QgY29vcmRzID0gcm91dGUuc2hhcGUubWFwKChsYXRsbmcgPT4gbGF0bG5nLnNwbGl0KFwiLFwiKSkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHsgc3VtbWFyeTogc3VtbWFyeSwgY29vcmRzOiBjb29yZHMsIHJvdXRlOiByb3V0ZSwgYm9keTogcmVzLmJvZHkgfTtcclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIGNvbXB1dGUgYW4gaXNvbGluZS4gW1NlZSBtb3JlIGluZm8gb24gb3B0aW9uYWwgcGFyYW1ldGVyc10oaHR0cDovL2RvY3VtZW50YXRpb24uZGV2ZWxvcGVyLmhlcmUuY29tL3BkZi9yb3V0aW5nX2hscC83LjIuMTAwL1JvdXRpbmclMjBBUEklMjB2Ny4yLjEwMCUyMERldmVsb3BlcidzJTIwR3VpZGUucGRmKVxyXG4gICogQGFsaWFzIGhtOmlzb2xpbmVcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSBvcHRpb24gZm9yIGlzb2xpbmVcclxuICogQHBhcmFtIFtvcHQuc3RhcnRdIHtjb29yZH0gY29vcmQgZm9yIHN0YXJ0aW5nIHBvaW50IG9mIGlzb2xpbmVcclxuICogQHBhcmFtIFtvcHQuZGVzdGluYXRpb25dIHtjb29yZH0gY29vcmQgZm9yIGRlc3RpbmF0aW9uIHBvaW50IG9mIGlzb2xpbmVcclxuICogQHBhcmFtIFtvcHQucmFuZ2VUeXBlPVwidGltZVwiXSB7c3RyaW5nfSB0aW1lIG9yIGRpc3RhbmNlXHJcbiAqIEBwYXJhbSBbb3B0LnJhbmdlXSB7bnVtYmVyfSByYW5nZSBpbiBzZWNvbmRzIG9yIGluIG1ldGVyc1xyXG4gKiBAcGFyYW0gW29wdC5tb2RlPVwiZmFzdGVzdDtjYXI7dHJhZmZpYzpkaXNhYmxlZFwiXSB7U3RyaW5nfSByb3V0aW5nIG1vZGVcclxuICogQHBhcmFtIFtvcHQubGlua2F0dHJpYnV0ZXM9c2hdIHtTdHJpbmd9IGF0dHJpYnV0ZXMgdG8gYmUgcmV0dXJuZWRcclxuICogXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlfSAgcmV0dXJucyB7IHBvbHk6YXJyYXksIGJvZHk6b2JqZWN0IH0uIFBvbHkgaXMgYXJyYXkgb2YgY29vcmRzLCBib2R5IGlzIGZ1bGwgYW5zd2VyXHJcbiAqL1xyXG5mdW5jdGlvbiBpc29saW5lKG9wdCkge1xyXG5cclxuICAgIGNvbnN0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIHN0YXJ0OiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgZGlyZWN0IGlzb2xpbmVcclxuICAgICAgICBkZXN0aW5hdGlvbjogbnVsbCwgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHJldmVyc2UgaXNvbGluZVxyXG4gICAgICAgIHJhbmdlVHlwZTogXCJ0aW1lXCIsICAgICAgICAgICAgICAgICAgICAgIC8vIHRpbWUgb3IgZGlzdGFuY2VcclxuICAgICAgICByYW5nZTogbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gc2Vjb25kcyBvciBtZXRlcnNcclxuICAgICAgICBsaW5rYXR0cmlidXRlczogXCJzaFwiLCAgICAgICAgICAgICAgICAgICAvLyB0byBnZXQgdGhlIHNoYXBlXHJcbiAgICAgICAgbW9kZTogXCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkXCIsICAgLy9zaG9ydGVzdDtjYXI7dHJhZmZpYzpkaXNhYmxlZCBcclxuICAgIH07XHJcbiAgICBjb25zdCBwYXJhbXMgPSBjbS5hZGRDcmVkZW50aWFscyhzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBpZiAocGFyYW1zLnN0YXJ0KVxyXG4gICAgICAgIHBhcmFtcy5zdGFydCA9IFwiZ2VvIVwiICsgcGFyYW1zLnN0YXJ0WzBdICsgXCIsXCIgKyBwYXJhbXMuc3RhcnRbMV07XHJcbiAgICBpZiAocGFyYW1zLmRlc3RpbmF0aW9uKVxyXG4gICAgICAgIHBhcmFtcy5kZXN0aW5hdGlvbiA9IFwiZ2VvIVwiICsgcGFyYW1zLmRlc3RpbmF0aW9uWzBdICsgXCIsXCIgKyBwYXJhbXMuZGVzdGluYXRpb25bMV07XHJcblxyXG4gICAgaWYgKCFwYXJhbXMuc3RhcnQgJiYgIXBhcmFtcy5kZXN0aW5hdGlvbikge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiSXNvbGluZSByb3V0aW5nIDogbWlzc2luZyBzdGFydCBvciBkZXN0aW5hdGlvblwiKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFwYXJhbXMucmFuZ2UpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIklzb2xpbmUgcm91dGluZyA6IG1pc3NpbmcgcmFuZ2VcIik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1cmwgPSBjbS5idWlsZFVybChcImlzb2xpbmUucm91dGVcIiwgXCJhcGkuaGVyZS5jb20vcm91dGluZy83LjIvY2FsY3VsYXRlaXNvbGluZS5qc29uXCIpO1xyXG4gICAgcmV0dXJuIGNtLmhlcmVSZXN0KHVybCwgcGFyYW1zLCBcInBvc3RcIilcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG5cclxuICAgICAgICAgICAgLy8gYXJyYXkgb2YgbGF0LGxuZywgdG8gYmUgdHJhbnNmb3JtZWQgaW50byBhcnJheSBvZiBbbGF0LGxuZ11cclxuICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSByZXMuYm9keS5yZXNwb25zZS5pc29saW5lWzBdLmNvbXBvbmVudFswXS5zaGFwZTtcclxuICAgICAgICAgICAgY29uc3QgcG9seSA9IHNoYXBlLm1hcChwb2ludCA9PiBwb2ludC5zcGxpdChcIixcIikpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHsgcG9seTogcG9seSwgYm9keTogcmVzLmJvZHkgfTtcclxuICAgICAgICB9KTtcclxuXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogY29tcHV0ZSBhIG1hdHJpeC4gW1NlZSBtb3JlIGluZm8gb24gb3B0aW9uYWwgcGFyYW1ldGVyc10oaHR0cDovL2RvY3VtZW50YXRpb24uZGV2ZWxvcGVyLmhlcmUuY29tL3BkZi9yb3V0aW5nX2hscC83LjIuMTAwL1JvdXRpbmclMjBBUEklMjB2Ny4yLjEwMCUyMERldmVsb3BlcidzJTIwR3VpZGUucGRmKVxyXG4gKiBcclxuICogTWF0cml4IHNpemUgaXMgbGltaXRlZCB0byAxeDEwMCwgMTAweDEgb3IgMTV4TlxyXG4gICogQGFsaWFzIGhtOm1hdHJpeFxyXG4gKiBAcGFyYW0gc291cmNlIHtvYmplY3R9IHNvdXJjZSBhcyBcXFtsYXQsbG5nXFxdLiBDYW4gYmUgYXJyYXkgb2YgXFxbbGF0LGxuZ1xcXVxyXG4gKiBAcGFyYW0gZGVzdCB7b2JqZWN0fSBkZXN0IGFzIFxcW2xhdCxsbmdcXF0uIENhbiBiZSBhcnJheSBvZiBcXFtsYXQsbG5nXFxdXHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gYWRkaXRpb25hbCBvcHRpb25hbCBwYXJhbWV0ZXJzIGxpa2UgIG1vZGUsIHN1bW1hcnlBdHRyaWJ1dGVzXHJcbiAqIEBwYXJhbSBbb3B0Lm1vZGU9XCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmVuYWJsZWRcIl0ge3N0cmluZ30gcm91dGluZyBtb2RlIHRvIGNvbXB1dGUgbWF0cml4XHJcbiAqIEBwYXJhbSBbb3B0LnN1bW1hcnlBdHRyaWJ1dGVzPVwidHQsZGlcIl0ge3N0cmluZ30gYXR0cmlidXRlcyBpbiB0aGUgYW5zd2VyXHJcbiAqIFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0geyBlbnRyaWVzOiBvYmplY3QsIGJvZHk6b2JqZWN0IH0uIGVudHJpZXMgaXMgdGhlIGFycmF5IG9mIHtzdGFydCxzdG9wfSBpbmZvcm1hdGlvbi4gYm9keSBpcyBmdWxsIGpzb24gYW5zd2VyXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IHJlcyA9IGF3YWl0IGhtLm1hdHJpeCh7XHJcbiAqICAgICAgc291cmNlOls0OC44LDIuM11cclxuICogICAgICBkZXN0OltbNDguNywyLjVdLFs0OC4xLDIuMF0sWzQ0LjIsMi4zXV1cclxuICogfSk7XHJcbiAqIGNvbnNvbGUubG9nIChyZXMuZW50cmllcyk7IFxyXG4gKiBgYGBcclxuICovXHJcblxyXG5mdW5jdGlvbiBtYXRyaXgoc291cmNlLCBkZXN0LCBvcHQpIHtcclxuXHJcbiAgICB2YXIgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbW9kZTogXCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmVuYWJsZWRcIixcclxuICAgICAgICBzdW1tYXJ5QXR0cmlidXRlczogXCJ0dCxkaVwiXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGFyYW1zID0gY20uYWRkQ3JlZGVudGlhbHMoc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNvdXJjZVswXSkpIC8vIGlmIG9ubHkgb25lIGNvb3JkXHJcbiAgICAgICAgc291cmNlID0gW3NvdXJjZV07XHJcbiAgICBzb3VyY2UuZm9yRWFjaCgoY29vcmQsIGkpID0+IHtcclxuICAgICAgICBwYXJhbXNbXCJzdGFydFwiICsgaV0gPSBjb29yZFswXSArIFwiLFwiICsgY29vcmRbMV07XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVzdFswXSkpIC8vIGlmIG9ubHkgb25lIGNvb3JkXHJcbiAgICAgICAgZGVzdCA9IFtkZXN0XTtcclxuICAgIGRlc3QuZm9yRWFjaCgoY29vcmQsIGkpID0+IHtcclxuICAgICAgICBwYXJhbXNbXCJkZXN0aW5hdGlvblwiICsgaV0gPSBjb29yZFswXSArIFwiLFwiICsgY29vcmRbMV07XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1cmwgPSBjbS5idWlsZFVybChcIm1hdHJpeC5yb3V0ZVwiLCBcImFwaS5oZXJlLmNvbS9yb3V0aW5nLzcuMi9jYWxjdWxhdGVtYXRyaXguanNvblwiKTtcclxuICAgIHJldHVybiBjbS5oZXJlUmVzdCh1cmwsIHBhcmFtcywgXCJwb3N0XCIpXHJcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZW50cmllczogcmVzLmJvZHkucmVzcG9uc2UubWF0cml4RW50cnksIGJvZHk6IHJlcy5ib2R5IH07XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29tcHV0ZSB0aGUgZGV0b3VyIGZvciBlYWNoIHdheXBvaW50IHByb3ZpZGVkLCBjb21wYXJlZCB0byBub3JtYWwgcm91dGUgZnJvbSBBIHRvIEJcclxuICogXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06ZGV0b3VyXHJcbiAqIEBwYXJhbSBzdGFydCB7Y29vcmR9ICBzdGFydGluZyBwb2ludCBmb3Igcm91dGVcclxuICogQHBhcmFtIHN0b3Age2Nvb3JkfSAgIGRlc3RpbmF0aW9uIHBvaW50IG9mIHJvdXRlXHJcbiAqIEBwYXJhbSB3YXlwb2ludHMge2FycmF5fSAgbGlzdCBvZiB3YXR5cG9pbnRzIHRvIHRlc3QgXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlfSByZXR1cm5zIHtyZWZlcmVuY2U6IHtzdGFydCwgc3RvcCwgZGlzdGFuY2UsIGRpc3RhbmNlMiwgdGltZSwgdGltZTJ9ICx3YXlwb2ludHM6WyB7Y29vcmQsIGRpc3RBLCB0aW1lQSwgZGlzdEIsIHRpbWVCfV19XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZXRvdXIoc3RhcnQsIHN0b3AsIHdheXBvaW50cykge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICAgbm8tdW5kZWZcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShcclxuICAgICAgICBhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIC8vbGV0IHRTdGFydCA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0KSByZXR1cm4gcmVqZWN0KFwibWlzc2luZyBzdGFydCBwb2ludFwiKTtcclxuICAgICAgICAgICAgaWYgKCFzdG9wKSByZXR1cm4gcmVqZWN0KFwibWlzc2luZyBzdG9wIHBvaW50XCIpO1xyXG4gICAgICAgICAgICBpZiAoIXdheXBvaW50cykgcmV0dXJuIHJlamVjdChcIm1pc3Npbmcgd2F5cG9pbnRzXCIpO1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkpIHJldHVybiByZWplY3QoXCJ3YXlwb2ludHMgc2hvdWxkIGJlIGFuIGFycmF5XCIpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGluaXRpYWxpc2UgbGUgcmVzdWx0YXQgXHJcbiAgICAgICAgICAgIGxldCByZXMgPSB7XHJcbiAgICAgICAgICAgICAgICByZWZlcmVuY2U6IHt9LFxyXG4gICAgICAgICAgICAgICAgd2F5cG9pbnRzOiBbXVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gY2FsY3VsIGxlcyBjb29yZHMgbm9uUG9zdEdyZXMsIGNyZWVyIGwnYXJyYXkgZGUgY29vcmQgZGVzIHdheXBvaW50cy5cclxuICAgICAgICAgICAgbGV0IGRlc3QgPSBbc3RvcF07IC8vIHNvIHdlIGhhdmUgYSBkaXN0YW5jZS90aW1lIHJlZmVyZW5jZSwgbm90IHNhbWUgYXMgZnJvbSByb3V0aW5nIDE6MVxyXG4gICAgICAgICAgICB3YXlwb2ludHMuZm9yRWFjaCh3YXlwb2ludCA9PiB7XHJcbiAgICAgICAgICAgICAgICBkZXN0LnB1c2god2F5cG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgcmVzLndheXBvaW50cy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIHsgY29vcmQ6IHdheXBvaW50IH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBpbnNwZWN0KGRlc3QsIFwiZGVzdCBmcm9tIGRldG91clwiKVxyXG5cclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBzdGFydCB0byBhbGwgd2F5cG9pbnQsIDFzdCB3YXlwb2ludCBpcyBzdG9wIHRvIGdldCBhIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICBsZXQgcDEgPSBtYXRyaXgoc3RhcnQsIGRlc3QsIHsgbW9kZTogXCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkXCIgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBjb21wdXRlIGZyb20gYWxsIHdheXBvaW50IHRvIHN0b3AsIDFzdCB3YXlwb2ludCBpcyBzdGFydCB0byBnZXQgYW5vdGhlciByZWZlcmVuY2VcclxuICAgICAgICAgICAgZGVzdFswXSA9IHN0YXJ0O1xyXG4gICAgICAgICAgICBsZXQgcDIgPSBtYXRyaXgoZGVzdCwgc3RvcCwgeyBtb2RlOiBcImZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZGlzYWJsZWRcIiB9KTtcclxuICAgICAgICAgICAgLy8gd2FpdCBmb3IgYm90aCBtYXRyaXggdG8gY29tcGxldGVcclxuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgIG5vLXVuZGVmXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKFtwMSwgcDJdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgZmlyc3QgcGFydDogc3RhcnQgPT4gTiB3YXlwb2ludHNcclxuICAgICAgICAgICAgbGV0IGVudHJpZXMgPSByZXN1bHRbMF0uZW50cmllcztcclxuICAgICAgICAgICAgLy8gZmlyc3QgZW50cnkgaXMgc3RhcnQgc3RvcFxyXG4gICAgICAgICAgICBsZXQgZGlzdCA9IGVudHJpZXNbMF0uc3VtbWFyeS5kaXN0YW5jZTtcclxuICAgICAgICAgICAgbGV0IHRpbWUgPSBlbnRyaWVzWzBdLnN1bW1hcnkudHJhdmVsVGltZTtcclxuICAgICAgICAgICAgcmVzLnJlZmVyZW5jZS5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICByZXMucmVmZXJlbmNlLnN0b3AgPSBzdG9wO1xyXG4gICAgICAgICAgICByZXMucmVmZXJlbmNlLmRpc3RhbmNlID0gZGlzdDtcclxuICAgICAgICAgICAgcmVzLnJlZmVyZW5jZS50aW1lID0gdGltZTsgLy8gdGhlIHJlZmVyZW5jZSBzYW5zIHdheXBvaW50XHJcblxyXG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSByZXR1cm47IC8vIHNraXAgdGhlIGZpcnN0IHdoaWNoIGlzIHN0YXJ0IHN0b3BcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuc3RhdHVzID09IFwiZmFpbGVkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVudHJ5LCBcImVycm9yIG9uIG1hdHJpeEFcIiArIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coc3RhcnQsIFwiYXNzb2NpYXRlZCBzdGFydFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGRlc3RbaV0sIFwiYXNzb2NpYXRlZCBkZXN0XCIgKyBpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGlkID0gZW50cnkuZGVzdGluYXRpb25JbmRleDtcclxuICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gZW50cnkuc3VtbWFyeS5kaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCB0aW1lID0gZW50cnkuc3VtbWFyeS50cmF2ZWxUaW1lO1xyXG4gICAgICAgICAgICAgICAgcmVzLndheXBvaW50c1tpZCAtIDFdLmRpc3RBID0gZGlzdDtcclxuICAgICAgICAgICAgICAgIHJlcy53YXlwb2ludHNbaWQgLSAxXS50aW1lQSA9IHRpbWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIHByb2Nlc3Mgc2Vjb25kIHBhcnQ6IE4gd2F5cG9pbnRzID0+IHN0b3BcclxuICAgICAgICAgICAgZW50cmllcyA9IHJlc3VsdFsxXS5lbnRyaWVzO1xyXG4gICAgICAgICAgICAvL2luc3BlY3QoZW50cmllc1swXSwgXCJtYXRyaXhCMFwiKTtcclxuXHJcbiAgICAgICAgICAgIHJlcy5yZWZlcmVuY2UuZGlzdGFuY2UyID0gZW50cmllc1swXS5zdW1tYXJ5LmRpc3RhbmNlO1xyXG4gICAgICAgICAgICByZXMucmVmZXJlbmNlLnRpbWUyID0gZW50cmllc1swXS5zdW1tYXJ5LnRyYXZlbFRpbWU7XHJcblxyXG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSByZXR1cm47IC8vIHNraXAgdGhlIGZpcnN0IHdoaWNoIGlzIHN0YXJ0IHN0b3BcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuc3RhdHVzID09IFwiZmFpbGVkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVudHJ5LCBcImVycm9yIG9uIG1hdHJpeEJcIiArIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZW50cnksIFwiYXNzb2NpYXRlZCBzdGFydFwiICsgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzdG9wLCBcImFzc29jaWF0ZWQgc3RvcFwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBlbnRyeS5zdGFydEluZGV4O1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpc3QgPSBlbnRyeS5zdW1tYXJ5LmRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRpbWUgPSBlbnRyeS5zdW1tYXJ5LnRyYXZlbFRpbWU7XHJcbiAgICAgICAgICAgICAgICByZXMud2F5cG9pbnRzW2lkIC0gMV0uZGlzdEIgPSBkaXN0O1xyXG4gICAgICAgICAgICAgICAgcmVzLndheXBvaW50c1tpZCAtIDFdLnRpbWVCID0gdGltZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlcyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBtYXRyaXg6IG1hdHJpeCxcclxuICAgIHJvdXRlOiByb3V0ZSxcclxuICAgIGlzb2xpbmU6IGlzb2xpbmUsXHJcbiAgICBkZXRvdXI6IGRldG91clxyXG59O1xyXG5cclxuIiwiLyogZ2xvYmFsIGRvY3VtZW50LEggKi9cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmNvbnN0IGhtID0gcmVxdWlyZShcIi4vbWFwLmpzXCIpO1xyXG5jb25zdCBzaW1wbGlmeSA9IHJlcXVpcmUoXCJzaW1wbGlmeS1qc1wiKTtcclxuXHJcblxyXG5sZXQgX3RvdWNoT2Zmc2V0ID0gbnVsbDtcclxubGV0IF90b3VjaENvb3JkcyA9IG51bGw7XHJcbmxldCBfdG91Y2hQb2x5bGluZSA9IG51bGw7XHJcbmxldCBfdG91Y2hMYXllciA9IG51bGw7XHJcbmxldCBfdG91Y2hDYWxsYmFjayA9IG51bGw7XHJcbmxldCBfbWFwID0gbnVsbDtcclxubGV0IF9iZWhhdmlvciA9IG51bGw7XHJcblxyXG5sZXQgX2JlaGF2aW9yRW5hYmxlID0gdHJ1ZTtcclxuZnVuY3Rpb24gYmVoYXZpb3JFbmFibGUob25vZmYpIHtcclxuICAgIGlmIChfYmVoYXZpb3JFbmFibGUgJiYgIW9ub2ZmKSB7XHJcbiAgICAgICAgX2JlaGF2aW9yLmRpc2FibGUoKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiYmVoYXZpb3IgZGlzYWJsZWRcIik7XHJcbiAgICAgICAgX2JlaGF2aW9yRW5hYmxlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIV9iZWhhdmlvckVuYWJsZSAmJiBvbm9mZikge1xyXG4gICAgICAgIF9iZWhhdmlvci5lbmFibGUoKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiYmVoYXZpb3IgZW5hYmxlZFwiKTtcclxuICAgICAgICBfYmVoYXZpb3JFbmFibGUgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBhY3RpdmF0ZSB0b3VjaCwgYWxsb3dpbmcgaGFuZCBkcmF3aW5nLCB3aXRoIGVtYmVkZGVkIHNpbXBsaWZpY2F0aW9uIG9mIHRoZSBsaW5lXHJcbiAqIEBhbGlhcyBobTp0b3VjaFxyXG4gKiBAcGFyYW0gb25vZmYge2Jvb2xlYW59ICBhY3RpdmF0ZSBvciBkZWFjdGl2YXRlXHJcbiAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9IG9wdGlvbnMgIHRvIGNvbnRyb2wgdGhlIHRvdWNoIGJlaGF2aW91clxyXG4gKiBAcGFyYW0gW29wdGlvbnMuY2FsbGJhY2tdIHtmdW5jdGlvbn0gY2FsbGluZyBjYWxsYmFjayhjb29yZHMpIHdoZW4gdG91Y2ggZW5kc1xyXG4gKiBAcGFyYW0gW29wdGlvbnMubGF5ZXJdIHtzdHJpbmd9IGxheWVyIHdoZXJlIHRvIHB1dCB0aGUgZHJhd2luZ1xyXG4gKiBAcGFyYW0gW29wdGlvbnMuc3R5bGVdIHtvYmplY3R9IGRyYXdpbmcgc3R5bGUgZm9yIHRoZSBsaW5lXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5hcnJvd10ge29iamVjdH0gYXJyb3cgc3R5bGUgZm9yIHRoZSBsaW5lXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy50b2xlcmFuY2U9NF0ge251bWJlcn0gdG9sZXJhbmNlIGZvciBzaW1wbGlmaWNhdGlvblxyXG4gKiBAcGFyYW0gW29wdGlvbnMua2VlcD1mYWxzZV0ge2Jvb2xlYW59IGtlZXAgZ3JhcGhpYyBvciBub3Qgd2hlbiBjYWxsaW5nIGNhbGxiYWNrXHJcbiAqL1xyXG5mdW5jdGlvbiB0b3VjaChvbm9mZiwgb3B0aW9ucykge1xyXG5cclxuICAgIF9tYXAgPSBobS5nZXRNYXAoKTtcclxuICAgIF9iZWhhdmlvciA9IGhtLmdldEJlaGF2aW9yKCk7XHJcbiAgICBsZXQgZWxtdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhtLmdldE1hcEh0bWxJdGVtKCkpO1xyXG5cclxuICAgIGxldCBiYiA9IGVsbXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBfdG91Y2hPZmZzZXQgPSB7IGxlZnQ6IGJiLngsIHRvcDogYmIueSB9OyAvLyBvZmZzZXQgb2Ygd2luZG93IHRvIGJyb3dzZXJcclxuXHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBjYWxsYmFjazogbnVsbCxcclxuICAgICAgICBsYXllcjogXCJfdG91Y2hcIixcclxuICAgICAgICBrZWVwOiBmYWxzZSxcclxuICAgICAgICBzdHlsZTogeyBsaW5lV2lkdGg6IDUsIHN0cm9rZUNvbG9yOiBcInJnYmEoMjU1LCAwLCAwLCAwLjcpXCIgfSxcclxuICAgICAgICBhcnJvd3M6IHsgZmlsbENvbG9yOiBcIndoaXRlXCIsIGZyZXF1ZW5jeTogNSwgd2lkdGg6IDEsIGxlbmd0aDogMiB9LFxyXG4gICAgICAgIHRvbGVyYW5jZTogNCwgLy8gbGV2ZWwgb2Ygc2ltcGxpZmljYXRpb25cclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgb3B0aW9ucyk7XHJcblxyXG4gICAgX3RvdWNoTGF5ZXIgPSBobS5sYXllckZpbmQoc2V0dGluZ3MubGF5ZXIpO1xyXG4gICAgaWYgKCFfdG91Y2hMYXllcikge1xyXG4gICAgICAgIF90b3VjaExheWVyID0gaG0ubGF5ZXJDcmVhdGUoc2V0dGluZ3MubGF5ZXIpO1xyXG4gICAgICAgIC8vX3RvdWNoTGF5ZXIgPSBobS5sYXllckZpbmQoc2V0dGluZ3MubGF5ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGxiYWNrIGRlcyBldmVudCBMaXN0ZW5lclxyXG4gICAgLy8gZGVmaW5pIHNldWxlbWVudCBzdXIgb25vZmYsIHBvdXIgbmUgcGFzIGNyZWVyIHVuZSBhdXRyZSBmb2lzIGxhIGZvbmN0aW9uXHJcbiAgICBpZiAob25vZmYpXHJcbiAgICAgICAgX3RvdWNoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZSkge1xyXG5cclxuICAgICAgICAgICAgbGV0IHRvdWNob2JqID0gZS5jaGFuZ2VkVG91Y2hlc1swXTsgLy8gcmVmZXJlbmNlIGZpcnN0IHRvdWNoIHBvaW50IChpZTogZmlyc3QgZmluZ2VyKVxyXG5cclxuICAgICAgICAgICAgLy8gaWYgKChlLnRvdWNoZXMubGVuZ3RoID49IDIgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+PSAyKSkge1xyXG4gICAgICAgICAgICBpZiAoKGUudG91Y2hlcy5sZW5ndGggPj0gMikpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgIGNvbnNvbGUubG9nKFwidG91Y2gubGVuZ3RoXCIsIGUudG91Y2hlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgYmVoYXZpb3JFbmFibGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT0gXCJ0b3VjaG1vdmVcIilcclxuICAgICAgICAgICAgICAgIGJlaGF2aW9yRW5hYmxlKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImUudHlwZVwiLCBlLnR5cGUpO1xyXG4gICAgICAgICAgICBsZXQgc2ltcGxpZmllZDtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidG91Y2hzdGFydFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIF90b3VjaENvb3JkcyA9IFtdOyAvLyBjb29yZHNcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidG91Y2htb3ZlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX3RvdWNoQ29vcmRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0b3VjaG9iai5jbGllbnRYIC0gX3RvdWNoT2Zmc2V0LmxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRvdWNob2JqLmNsaWVudFkgLSBfdG91Y2hPZmZzZXQudG9wXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdG91Y2hDb29yZHMubGVuZ3RoIDwgMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVN0cmluZyA9IG5ldyBILmdlby5MaW5lU3RyaW5nO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfdG91Y2hDb29yZHMuZm9yRWFjaChjID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhjLngsIGMueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdHJpbmcucHVzaExhdExuZ0FsdChjb29yZC5sYXQsIGNvb3JkLmxuZywgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBwb2x5bGluZSBpZiBub3QgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdG91Y2hQb2x5bGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdG91Y2hQb2x5bGluZSA9IG5ldyBILm1hcC5Qb2x5bGluZShsaW5lU3RyaW5nLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogc2V0dGluZ3Muc3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvd3M6IHNldHRpbmdzLmFycm93c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RvdWNoTGF5ZXIuYWRkT2JqZWN0KF90b3VjaFBvbHlsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgIC8vIG1vZGlmIGdlb21ldHJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90b3VjaFBvbHlsaW5lLnNldEdlb21ldHJ5KGxpbmVTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b3VjaGVuZFwiOiAvLyBjJ2VzdCBsYSBmaW4sIG9uIHNpbXBsaWZpZSBldCBhcHBlbGxlIGxlIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90b3VjaENvb3Jkcy5sZW5ndGggPCAyKSAvLyBub3QgZW5vdWdoIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNpbXBsaWZpZWQgPSBfdG91Y2hDb29yZHM7IC8vYXMgYXJyYXkgb2Yge3gseX1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbXBsaWZ5IHRoZSByZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnRvbGVyYW5jZSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGlmaWVkID0gc2ltcGxpZnkoX3RvdWNoQ29vcmRzLCBzZXR0aW5ncy50b2xlcmFuY2UsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBlbm91Z2ggcG9pbnRzLCBnbyBiYWNrIHRvIGluaXRpYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpbXBsaWZpZWQubGVuZ3RoIDwgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsaWZpZWQgPSBfdG91Y2hDb29yZHM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGZyb217eCx5fSBzY3JlZW4gdG8gW2xhdCxsbmddXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb29yZHMgPSBzaW1wbGlmaWVkLm1hcChjb29yZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGF0bG5nID0gX21hcC5zY3JlZW5Ub0dlbyhjb29yZC54LCBjb29yZC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbGF0bG5nLmxhdCwgbGF0bG5nLmxuZ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sZXQgY29vcmRzID0gZ2VvbS5zaW1wbGlmeShfdG91Y2hDb29yZHMsIHNldHRpbmdzLnRvbGVyYW5jZSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXAgdG8gY2FsbGJhY2sgdG8gcmVkcmF3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdG91Y2hQb2x5bGluZSAmJiAhc2V0dGluZ3Mua2VlcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90b3VjaExheWVyLnJlbW92ZU9iamVjdChfdG91Y2hQb2x5bGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90b3VjaFBvbHlsaW5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlaGF2aW9yRW5hYmxlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBydW4gY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuY2FsbGJhY2soY29vcmRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTsgLy8gb2YgX3RvdWNoXHJcblxyXG5cclxuXHJcbiAgICBpZiAob25vZmYpIHtcclxuICAgICAgICBlbG10LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF90b3VjaENhbGxiYWNrKTtcclxuICAgICAgICBlbG10LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgX3RvdWNoQ2FsbGJhY2spO1xyXG4gICAgICAgIGVsbXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90b3VjaENhbGxiYWNrKTtcclxuICAgICAgICAvLyAgICAgICAgYmVoYXZpb3JFbmFibGUoZmFsc2UpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxtdC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBfdG91Y2hDYWxsYmFjayk7XHJcbiAgICAgICAgZWxtdC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90b3VjaENhbGxiYWNrKTtcclxuICAgICAgICBlbG10LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBfdG91Y2hDYWxsYmFjayk7XHJcblxyXG4gICAgICAgIGlmIChfdG91Y2hQb2x5bGluZSlcclxuICAgICAgICAgICAgX3RvdWNoTGF5ZXIucmVtb3ZlT2JqZWN0KF90b3VjaFBvbHlsaW5lKTtcclxuXHJcbiAgICAgICAgX3RvdWNoTGF5ZXIgPSBudWxsO1xyXG4gICAgICAgIF90b3VjaFBvbHlsaW5lID0gbnVsbDtcclxuICAgICAgICBfdG91Y2hDb29yZHMgPSBudWxsO1xyXG4gICAgICAgIGJlaGF2aW9yRW5hYmxlKHRydWUpO1xyXG4gICAgfVxyXG5cclxuXHJcbn0gLy8gb2YgdG91Y2hcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHRvdWNoOiB0b3VjaFxyXG59OyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLypcclxuICogQG1vZHVsZSBIRVJFTUFQXHJcbiAqIEB0eXBpY2FsbmFtZSBobVxyXG4gKi9cclxuXHJcbmxldCBtb2R1bGVzID0ge307XHJcbk9iamVjdC5hc3NpZ24obW9kdWxlcywgcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcclxuT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi9nZW9tZXRyeS5qc1wiKSk7XHJcbk9iamVjdC5hc3NpZ24obW9kdWxlcywgcmVxdWlyZShcIi4vcm91dGluZy5qc1wiKSk7XHJcbk9iamVjdC5hc3NpZ24obW9kdWxlcywgcmVxdWlyZShcIi4vZ2VvY29kaW5nLmpzXCIpKTtcclxuT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi9wbGFjZS5qc1wiKSk7XHJcblxyXG5pZiAocHJvY2Vzcy5icm93c2VyKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKG1vZHVsZXMsIHJlcXVpcmUoXCIuL21hcC5qc1wiKSk7XHJcbiAgICBPYmplY3QuYXNzaWduKG1vZHVsZXMsIHJlcXVpcmUoXCIuL2NsdXN0ZXIuanNcIikpO1xyXG4gICAgT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi90b3VjaC5qc1wiKSk7XHJcbn1cclxuLy8gZXhwb3J0IGFsbCB0aGUgYWJvdmVcclxubW9kdWxlLmV4cG9ydHMgPSBtb2R1bGVzO1xyXG4iXX0=
