(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.heremap = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    if (points.length <= 2) return points;

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (typeof define === 'function' && define.amd) define(function() { return simplify; });
else if (typeof module !== 'undefined') {
    module.exports = simplify;
    module.exports.default = simplify;
} else if (typeof self !== 'undefined') self.simplify = simplify;
else window.simplify = simplify;

})();

},{}],3:[function(require,module,exports){
function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects",
 "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(fn => {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function(...args) {
    this._defaults.push({fn, args});
    return this;
  }
});

Agent.prototype._setDefaults = function(req) {
    this._defaults.forEach(def => {
      req[def.fn].apply(req, def.args);
    });
};

module.exports = Agent;

},{}],4:[function(require,module,exports){
/**
 * Root reference for iframes.
 */

let root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

const Emitter = require('component-emitter');
const RequestBase = require('./request-base');
const isObject = require('./is-object');
const ResponseBase = require('./response-base');
const Agent = require('./agent-base');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

const request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = () => {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

const trim = ''.trim
  ? s => s.trim()
  : s => s.replace(/(^\s*|\s*$)/g, '');

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  const pairs = [];
  for (const key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(v => {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(const subkey in val) {
        pushEncodedKeyValuePair(pairs, `${key}[${subkey}]`, val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  const obj = {};
  const pairs = str.split('&');
  let pair;
  let pos;

  for (let i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  const lines = str.split(/\r?\n/);
  const fields = {};
  let index;
  let line;
  let field;
  let val;

  for (let i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) { // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  let status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str) {
  let parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  const req = this.req;
  const method = req.method;
  const url = req.url;

  const msg = `cannot ${method} ${url} (${this.status})`;
  const err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  const self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', () => {
    let err = null;
    let res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    let new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch(custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (1 === arguments.length) pass = '';
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    };
  }

  const encoder = string => {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  const fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  const err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = () => {
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  this._end();
};

Request.prototype._end = function() {
  if (this._aborted) return this.callback(Error("The request has been aborted even before .end() was called"));

  const self = this;
  const xhr = (this.xhr = request.getXHR());
  let data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = () => {
    const readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    let status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  const handleProgress = (direction, e) => {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    const contentType = this._header['content-type'];
    let serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (const field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
};

request.agent = () => new Agent();

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(method => {
  Agent.prototype[method.toLowerCase()] = function(url, fn) {
    const req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = (url, data, fn) => {
  const req = request('GET', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = (url, data, fn) => {
  const req = request('HEAD', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = (url, data, fn) => {
  const req = request('OPTIONS', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  const req = request('DELETE', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = (url, data, fn) => {
  const req = request('PATCH', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = (url, data, fn) => {
  const req = request('POST', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = (url, data, fn) => {
  const req = request('PUT', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./agent-base":3,"./is-object":5,"./request-base":6,"./response-base":7,"component-emitter":9}],5:[function(require,module,exports){
'use strict';

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],6:[function(require,module,exports){
'use strict';

/**
 * Module of mixed-in functions shared between node and client code
 */
const isObject = require('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (const key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(const option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

const ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function(err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      const override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch(e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    const self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise((innerResolve, innerReject) => {
      self.on('error', innerReject);
      self.end((err, res) => {
        if (err) innerReject(err);
        else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (const key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (const key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (const i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', `Basic ${base64Encoder(`${user}:${pass}`)}`);
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', `Bearer ${user}`);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function(n){
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header,
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  const isObj = isObject(data);
  let type = this._header['content-type'];

  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (const key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? `${this._data}&${data}`
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function(){
  const query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    const index = this.url.indexOf('?');
    if (index >= 0) {
      const queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = () => {console.trace("Unsupported");}

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  const err = new Error(`${reason + timeout}ms exceeded`);
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  const self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(() => {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(() => {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

},{"./is-object":5}],7:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

const utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (const key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    const ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    const params = utils.params(ct);
    for (const key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    const type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.created = 201 == status;
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
    this.unprocessableEntity = 422 == status;
};

},{"./utils":8}],8:[function(require,module,exports){
'use strict';

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = str => str.split(/ *; */).shift();

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = str => str.split(/ *; */).reduce((obj, str) => {
  const parts = str.split(/ *= */);
  const key = parts.shift();
  const val = parts.shift();

  if (key && val) obj[key] = val;
  return obj;
}, {});

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = str => str.split(/ *, */).reduce((obj, str) => {
  const parts = str.split(/ *; */);
  const url = parts[0].slice(1, -1);
  const rel = parts[1].split(/ *= */)[1].slice(1, -1);
  obj[rel] = url;
  return obj;
}, {});

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = (header, changesOrigin) => {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};

},{}],9:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],10:[function(require,module,exports){
"use strict";
const cm = require("common");
const m = require("map");


/**
 *  Place autocomplete for use with JQuery
 * @alias hm:placeAC
 * @param [query.term] {object} query.term contains the search
 * @param {function} callback called as callback({title,value,coord,json})
 */
function placeACJQ(query, callback) {
    const center = m.getCenter();
    const params = cm.addCredentials({
        at: center[0] + "," + center[1],
        q: query.term
    });

    const url = cm.buildUrl("places", "api.here.com/places/v1/autosuggest");
    cm.hereRest(url, params, "get", false)
        .then(res => {
            var places = res.body.results.filter(place => place.vicinity);

            places = places.map(place => {
                return {
                    title: place.title,
                    //value: place.title + ', ' + place.vicinity.replace(/<br\/>/g, ", ") + ' (' + place.category + ')',
                    value: place.title + ', ' + place.vicinity.replace(/<br\/>/g, ", "),
                    coord: place.position,
                    res: JSON.stringify(place),

                };
            });
            callback(places);
        });
}

module.exports = {
    placeACJQ: placeACJQ
};

},{"common":12,"map":14}],11:[function(require,module,exports){
/* global H, fetch */
"use strict";
const m = require("map");

let map = null;

let clusterLayer = null;


/**
 * creates a cluster of points
 * @async
 * @alias hm:cluster
 * @param coords {Array}  array of \[lat,lng,payload\]
 * @param opt {object} options for cluster
 * @param [opt.minZoom] {number} min zoom for cluster to be visible
 * @param [opt.maxZoom] {number} max zoom for cluster to be visible
 * @param [opt.noise] {array} graphic to represent stand-alone point. format: [url,size]. Anchor will be bottom-center
 * @param [opt.clusterIcon] {string} url of svg file representing a cluster. Anchor will be middle of icon
 * @param [opt.style] {object} define for each minium aggregation level the color and size of the icon. See example
 * @param {function} cb callback to be called if click on item. Format cb(event, coord, payload, weigth). 
 * `coord` is coord of icon
 * `payload` is payload associated to point. 
 * `weight` is number of points aggregated, when clicking on a cluster icon, 1 if single point
 * 
 * @return {H.map.layer.ObjectLayer}  layer created
 * 
  * @example
  * ```js
  * let pois = [[48.8,2.3,"Hello world"],[48.5,2.4,"How are you"],[45.2,2.93,"Very well"]];
  * 
  * hm.cluster(pois);
  * 
  * // with more graphic options and callback defined
 *  hm.cluster(pois, {
 *           noise: ["mcdo.png", 24],
 *           clusterIcon: '../svg/cluster2.svg',    //  icon for cluster
 *           style: {
 *               200: { color: "#B50015", size: 64 }  // for 200 or more points aggrregated, drag red big icon
 *               75: { color: "#FF6900", size: 58 },  // for 75 or more points aggregated. orange middle size icon
 *               2: { color: "#7BD30A", size: 46 },   // for 2 or more points aggregated. green small icon
 *           }
 *       },
 *           (event, coordinate, data, weight) => {
 *               if (data)
 *                   console.log("click on point ", data);
 *               else
 *                   console.log("click on cluster with weight", weight);
 *           });
* ```
 */
async function cluster(coords, opt, cb = null) {

    let dataPoints = [];
    map = m.getMap();

    let settings = {
        minZoom: 1,     // min zoom
        maxZoom: 24,    // max zoom
        noise: ["http:svg/bluedot.svg", 16],  //  icon+size for noise, can be svg or image
        clusterIcon: "http:svg/cluster.svg",    //  icon for cluster
        style: {
            75: { color: "#FF6900", size: 36 },
            3: { color: "#7BD30A", size: 32 },
            200: { color: "#B50015", size: 48 }
        }
    };
    if (opt)
        Object.assign(settings, opt);


    coords.forEach(coord => {
        // use op_weight of 1 for each coord
        // provides all coord as data
        let dp = new H.clustering.DataPoint(coord[0], coord[1], 1, coord);
        dataPoints.push(dp);

    });


    // noise icon : if SVG, needs to fetch it
    let noiseIcon = settings.noise[0];
    let noiseSize = settings.noise[1];

    if (noiseIcon.substr(-3) == "svg") {
        noiseIcon = await fetch(noiseIcon)
            .then(res => {
                if (res.status != 200)
                    return null;
                return res.text();
            });

    }

    if (!noiseIcon) return; // if no result, let's quit

    // to speed up, create only once the icon for noise
    const iconNoise = new H.map.Icon(noiseIcon, { size: { w: noiseSize, h: noiseSize } });

    // let's now fetch cluster icon
    let svgCluster = await fetch(settings.clusterIcon)
        .then(res => {
            if (res.status != 200)
                return null;
            return res.text();
        });

    if (!svgCluster)
        return;


    // to speed display display, we will cache the various cluster icons
    // from the base svg, we will create different icons with different size/color/text
    let cacheIcon = {}; // cache of icons

    // order style by size descending
    let styleSize = Object.keys(settings.style).sort(function (a, b) { return b - a; });

    // this function  cretaes the icon for a cluster
    function getClusterPresentation(cluster) {

        // building data object which will be returned when clicking on the icon
        var data = {};
        data.isCluster = () => { return true; };  // so we know it is a cluster
        let weight = cluster.getWeight();
        data.getWeight = () => { return weight; }; // number of individual item clustered together

        // let's find the relevant color and size
        let entry = styleSize.find(elt => (weight >= elt));
        let color = settings.style[entry].color;
        let size = settings.style[entry].size;

        // let's create and cache the needed icons
        let key = color + "-" + weight + "-" + size;
        if (typeof cacheIcon[key] == "undefined") {
            let svg = svgCluster.replace("{text}", weight).replace(/{color}/g, color);
            cacheIcon[key] = new H.map.Icon(svg, { size: { w: size, h: size }, anchor: { w: size / 2, h: size / 2 } });
        }

        // create a marker for the Cluster
        var clusterMarker = new H.map.Marker(cluster.getPosition(), {
            // Use min zoom from a noise point
            // to show it correctly at certain zoom levels:
            min: cluster.getMinZoom(),
            max: cluster.getMaxZoom(),
            icon: cacheIcon[key],

        });

        // Link data from the from the cluster to the marker,
        // to make it accessible on callback
        clusterMarker.setData(data);

        return clusterMarker;
    }

    // function to represent a single item
    function getNoisePresentation(noisePoint) {

        // data to be sent on callback
        const data = {
            getData: () => { return noisePoint.getData(); },
            isCluster: () => { return false; },
            getWeight: () => { return 1; }
        };

        // Create a marker for the noisePoint
        var noiseMarker = new H.map.Marker(noisePoint.getPosition(), {
            // Use min zoom from a noise point
            // to show it correctly at certain zoom levels:
            min: noisePoint.getMinZoom(),
            icon: iconNoise
        });


        // Link a data from the point to the marker
        // to make it accessible on callback
        noiseMarker.setData(data);

        return noiseMarker;
    }


    // create cluster provider
    let clusteredDataProvider = new H.clustering.Provider(dataPoints, {
        clusteringOptions: {
            // Maximum radius of the neighborhood
            eps: 64,
            // minimum weight of points required to form a cluster
            minWeight: styleSize[styleSize.length - 1] // minimum clustering is defined by minsize in Style
        },
        min: settings.minZoom, // min zoom
        max: settings.maxZoom, // max zoom
        theme: { getClusterPresentation: getClusterPresentation, getNoisePresentation: getNoisePresentation }
    });

    // Create a layer that includes the data provider and its data points:
    let layer = new H.map.layer.ObjectLayer(clusteredDataProvider);
    // Add the layer to the map:
    map.addLayer(layer);

    // if a callback is defined, add event listener
    if (cb) {
        clusteredDataProvider.addEventListener("tap", function (ev) {
            // Log data bound to the marker that has been tapped:
            let data = ev.target.getData();
            let coord = map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            let isCluster = data.isCluster();

            if (isCluster) {
                let weigth = data.getWeight();
                cb(ev, m.coordO2A(coord), null, weigth);
            }

            else {
                let userData = data.getData(); // lat,lng, payload
                cb(ev, m.coordO2A(coord), userData[2], 1);
            }
        });
    }

    return layer;
}

function hide() {
    clusterLayer.setMax(0);
    clusterLayer.setMin(0);
}

function show() {
    clusterLayer.setMax(24);
    clusterLayer.setMin(0);

}


module.exports = {
    cluster: cluster,
    clusterShow: show,
    clusterHide: hide
};


},{"map":14}],12:[function(require,module,exports){
(function (process){
"use strict";
/* global document */

/**
 * @file generic function of heremap
 * @author devbab
 */

const request = require("superagent");

// by default, unless specified fby calling config
// environment usable with node
let APP_ID = process.env.APP_ID;
let APP_CODE = process.env.APP_CODE;
let CIT = ""; // production by default
let PROTOCOL = "https:"; // by default
let _useHTTPS = true; // by default
let _home = ".";


// find out where we are and relative position for png/svg files
// pay attention if library is build in ./dist
if (process.browser) {
    let _script = document.getElementsByTagName("script");
    let _file = _script[_script.length - 1].src;
    let _path = _file.substring(0, _file.lastIndexOf("/"));

    _home = _path + "/../"; // a bit dirty but ...
}

/**
 * To configure app_id, app_code and optionally use CIT and http
 * @alias hm:config
 *
 * @param opt {Object}  - `opt` with parameters.
 * @param [opt.app_id] {string} - the app_id from developer.here.com
 * @param [opt.app_code] {string} - the app_code from developer.here.com
 * @param [opt.useCIT=false] {boolean} - true to use CIT environment. 
 * @param [opt.useHTTP=false] {string} - true to use HTTP. 
 * @param [opt.useHTTPS=true] {string} - true to use HTTPS. 
 *
 * @example
 * ```js
 *  hm.config({
 *      app_id: "YOUR APP_ID",
 *      app_code: "YOUR APP_CODE",
*   });
*  ```
 */
function config(opt) {
    if (opt.app_id) APP_ID = opt.app_id;
    if (opt.app_code) APP_CODE = opt.app_code;
    if (opt.useCIT) CIT = ".cit";
    if (opt.useHTTP) {
        PROTOCOL = "http:";
        _useHTTPS = false;
    }
    if (opt.useHTTPS) {
        PROTOCOL = "https:";
        _useHTTPS = true;
    }
}

/**
 * return URL of module home directory
 * @ignore
 *  @alias hm:getHome
 * @return {string} url of home directory including http or https
 */
function getHome() {
    return _home;
}

/**
 * returns app_id
 * @ignore
 *  @alias hm:getAppId
 * @return {string} app_id
*/
function getAppId() {
    return APP_ID;
}

/**
 * return app_code
 *  @ignore
 *  @alias hm:getHome
 *  @alias hm:getAppCode
  * @return {string} app_code
*/
function getAppCode() {
    return APP_CODE;
}

/**
 * return true if using CIT
 * @ignore
 * @alias hm:getCIT
 * @return {booolean} true if using CIT
*/
function getCIT() {
    return CIT;
}

/**
 * return protocol used, http:// or https://
 * @ignore
 * @alias hm:getProtocol
 * @return {string} - protocol
*/
function getProtocol() {
    return PROTOCOL;
}

/**
 * return true is https is used
 * @ignore
 *  @alias hm:useHTTPS
 * @return {boolean} - true if https is used
*/
function useHTTPS() {
    return _useHTTPS;
}

/**
 * add credentials to object provided
  * @ignore
 *  @alias hm:addCredentials
 * @param  {...objects} list of `objects` 
 * @return {object} object with all input objectconcatenated, and app_id/app_code inserted
 */
function addCredentials(...obj) {
    return Object.assign({
        app_id: APP_ID,
        app_code: APP_CODE
    }, ...obj);
}

/**
 * build HERE REST full url, taking in account protocol and cit. for instance  cm.buildUrl("geocoder", "api.here.com/6.2/geocode.json"
 * @ignore
 * @alias hm:buildUrl
 * @param {string} base - base name
 * @param {string} endpoint - end point
 * @return {string} full url
 */
function buildUrl(base, endpoint) {
    return PROTOCOL + "//" + base + CIT + "." + endpoint;
}

/**
 * does get/post request to HERE RESDT backend and manage main errors
 * @ignore
 * @alias hm:hereRest
 * @param {string} url  - url to call , for instance from buildUrl
 * @param {object} settings - settings to add in request
 * @param  {string} mode=get - mode "get" or "post"
 * @return {promise} - promise to resolve/reject
 */
async function hereRest(url, settings, mode = "get", needresp = "true") {

    let p = request.get(url);
    if (mode == "post")
        p = request.post(url);

    return p
        .query(settings)
        .then(res => {
            // res.body, res.headers, res.status
            if (res.status != "200") {
                let e = new Error("Error " + res.status + ":" + res.body); // e.message
                throw (e);
            }

            if (needresp && !res.body.Response && !res.body.response) { // one of the two should be in the answer
                console.error(res.body);
                let e = new Error("Query error:" + res.body); // e.message
                throw (e);
            }

            if (res.body.response && res.body.response.type == "ApplicationError") {
                console.error(res.body);
                let e = new Error("Error" + res.body.response.details); // e.message
                throw (e);
            }

            return res;
        });
}

module.exports = {
    config: config,
    buildUrl: buildUrl,
    getAppId: getAppId,
    getAppCode: getAppCode,
    getCIT: getCIT,
    getProtocol: getProtocol,
    getHome: getHome,
    useHTTPS: useHTTPS,
    addCredentials: addCredentials,
    hereRest: hereRest
};
}).call(this,require('_process'))

},{"_process":1,"superagent":4}],13:[function(require,module,exports){
/**
 * @file Geocoding functions : addresses <--> [lat,lng]
 * @author Devbab 
 */

"use strict";
const cm = require("./common.js");

/**
 * geocode an address
 * @alias hm:geocode
 * @param {string} address - address as string
 * @returns {Object} returns  {coord,body}. coord is geocode as \[lat,lng\]. body is full json answer
 * 
 * @example
 * ```js
 * const res = await hm.geocode("avenue des chaps elysees, paris");
 * console.log (res.coord);
 * ```
 */
function geocode(address) {

    const settings = cm.addCredentials({
        searchText: address
    });

    const url = cm.buildUrl("geocoder", "api.here.com/6.2/geocode.json");
    return cm.hereRest(url, settings)
        .then(res => {

            if (res.body.Response.View.length == 0) {
                let e = new Error("Geocode Address not found: " + address); // e.message
                throw (e);
            }

            var location = res.body.Response.View[0].Result[0].Location;
            var coord = [location.NavigationPosition[0].Latitude, location.NavigationPosition[0].Longitude];
            return { coord: coord, body: res.body };
        });
}


/**
 * reverse geocode a coordinate
 * @alias hm:reverseGeocode
 * @param {Coord} coord - coord \[lat,lng\] to reverse geocode
 * @returns {object} returns { location:object, address:object, body:object}. 
 */
function reverseGeocode(coord) {

    const settings = cm.addCredentials({
        mode: "retrieveAddresses",
        prox: coord[0] + "," + coord[1]
    });

    const url = cm.buildUrl("reverse.geocoder", "api.here.com/6.2/reversegeocode.json");

    return cm.hereRest(url, settings)
        .then(res => {
            // res.body, res.headers, res.status
            var location = res.body.Response.View[0].Result[0].Location;
            return ({ location: location, address: location.Address, body: res.body });
        });
}


module.exports = {
    geocode: geocode,
    reverseGeocode: reverseGeocode
};


},{"./common.js":12}],14:[function(require,module,exports){
/* global H, fetch, document, navigator, mapsjs, window APP_ID_JAPAN,APP_CODE_JAPAN,APP_ID_KOREA,APP_CODE_KOREA*/

/**
 * @file manages map display on a web canvas
 * @author devbab
 */

"use strict";
const cm = require("./common.js");

let _platform = null;
let _provider = null;
let _defaultLayers = null;
let _ui = null;
let _map = null;
let _behavior = null;
let group = null;
let _layers = []; // list all layers
let _key = {};     // keys  
let _bubbleMarker = null;     // bubble de mamrker
let _scheme = "normal.day.grey";
let _locateMe = null;         // id when locate is active
let _htmlItem = null;             //the html item on which to put the map


function coordO2A(obj) {
    return [obj.lat, obj.lng];
}

function coordA2O(arr) {
    return { lat: arr[0], lng: arr[1] };
}


/**
 * create a map area within the specified item
  * @alias hm:map

 * @param htmlItem {string}  - identifier of html div item on which to insert map
 * @param opt {object}  - options
 * @param [opt.zoom=10] {number}  - zoom factor
 * @param [opt.center=[48.86, 2.3]] {Coord}  - Coord of the center
 * @param [opt.scheme=normal.day.grey] {string}  - any scheme defined by HERE, plus "japan", "korea", "black", "white", "transparent". For japan/korea, one needs special credentials as APP_[ID|CODE]_JAPAN APP_[ID|CODE]_KOREA
 * @param [opt.click=null] {function()}  - callback on mouse click: callback(coord,button,key)
 * @param [opt.dbClick=null] {function()}  - callback on mouse double click: callback(coord,button,key)
 * @param [opt.clickLeft=null] {function}  - callback on mouse click left: callback(coord,button,key)
 * @param [opt.clickRight=null] {function()}  - callback on mouse click right.: callback(coord,button,key)
 * @param [opt.keyDown=null] {function}  - callback on key down : callback(key)
 * @param [opt.viewChange=null] {function}  - callback if map is panned or zoomed : callback(zoom,coordCenter)
 * @param [opt.loadTile=null] {function}  - callback when a tile is loaded : callback(z,x,y,url)
 *
 * @example
 * ```js
 * const hm = window.heremap;
 * 
 * hm.config({
 *    app_id: "YOUR APP_ID",
 *    app_code: "YOUR APP_CODE",
 * });
 *
 * hm.map("map", {
 *    zoom:5,
 *    center: [48.8,2.3],
 *    click: function(coord,button,key) {console.log("clicked on",coord,"with button",button);}
 * });
*  ```
*/
function map(htmlItem, opt) {

    _htmlItem = htmlItem;

    let settings = {
        zoom: 10,
        center: [48.86, 2.3],
        clickLeft: null,
        clickRight: null,
        keyDown: null,  // keyboard event
        click: null,
        dbClick: null,
        viewChange: null, // (zoom,coord)
        loadTile: null // quand une tile est affiche
    };

    let mps = 1;

    let app_id = cm.getAppId();
    let app_code = cm.getAppCode();

    if (!app_id || !app_code) {
        // console.log("app_id/app_code not initialised");
        document.getElementById(htmlItem).innerHTML = "app_id/app_code not initialised";
        return;
    }

    _platform = new H.service.Platform({
        app_id: app_id,
        app_code: app_code,
        useCIT: cm.getCIT(),
        useHTTPS: cm.useHTTPS()
    });

    Object.assign(settings, opt);
    if (settings.scheme) _scheme = settings.scheme; // store scheme if defined

    _defaultLayers = _platform.createDefaultLayers();

    // http://heremaps.github.io/examples/explorer.html#map-tiles__base-map-styles-and-modes
    _provider = new H.map.provider.ImageTileProvider({
        label: "Base Provider",
        descr: "",
        min: 0,
        max: 20,
        crossOrigin: "anonymous",
        getURL: function (col, row, level) {
            mps++; if (mps > 4) mps = 1;
            let url = [cm.getProtocol(), "//", mps, ".base.maps" + cm.getCIT() + ".api.here.com/maptile/", "2.1",
                "/", "maptile", "/", "newest", "/",
                _scheme, "/", level, "/", col, "/", row, "/", "256",
                "/", "png", "?lg=", "FRE",
                "&app_code=", app_code, "&app_id=",
                app_id].join("");

            if (_scheme == "japan")
                url = [cm.getProtocol(), "//", "m.lbs" + cm.getCIT() + ".api.heremaps.jp/v1/map?app_id=",
                    APP_ID_JAPAN,
                    "&app_code=",
                    APP_CODE_JAPAN,
                    "&tilematrix=EPSG:900913:",
                    level,
                    "&tilecol=",
                    col,
                    "&tilerow=",
                    row].join("");

            else if (_scheme == "korea")
                url = [cm.getProtocol(), "//", "3.base.maps" + cm.getCIT() + ".api.heremaps.kr/maptile/2.1/maptile/34439348c3/normal.day/",
                    "/", level, "/", col, "/", row, "/", "256",
                    "/", "png", "?lg=", "FRE",
                    "&app_code=", APP_CODE_KOREA, "&app_id=",
                    APP_ID_KOREA].join("");

            else if (_scheme == "black")
                url = cm.getHome() + "png/black.png";
            else if (_scheme == "white")
                url = cm.getHome() + "png/white.png";
            else if (_scheme == "transparent")
                url = cm.getHome() + "png/transparent.png";


            if (settings.loadTile)
                settings.loadTile(level, col, row, url);

            return url;
        }


    });

    let __layer = new H.map.layer.TileLayer(_provider);

    //console.log("normal map");
    //Step 2: initialize a HEREMap 
    _map = new H.Map(document.getElementById(htmlItem),
        __layer, {
            center: coordA2O(settings.center),
            zoom: settings.zoom
        });

    _behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(_map));

    // Create the default UI components
    _ui = H.ui.UI.createDefault(_map, _defaultLayers);

    // create default layer
    layerCreate("default");

    // if callback on zoom Change
    if (settings.viewChange) {
        _map.addEventListener("mapviewchangeend", function () {
            let bound = _map.getViewBounds();
            let lat = (bound.ka + bound.ja) / 2;
            let lng = (bound.ga + bound.ha) / 2;

            //console.log("viewChange center " + lat + " " + lng);
            settings.viewChange(_map.getZoom(), [lat, lng]);
        });
    }

    /***********************           to handle keyboard while mouse in map        ***********************/
    let kup = function () {
        _key.ctrl = false;
        _key.shift = false;
        _key.alt = false;
        _key.key = "";
    };

    let kdown = function (e) {
        _key.ctrl = ((e.key == "Control") || (e.keyIdentifier == "Control") || (e.ctrlKey == true));
        _key.shift = ((e.key == "Shift") || (e.keyIdentifier == "Shift") || (e.shiftKey == true));
        _key.alt = ((e.key == "Alt") || (e.keyIdentifier == "Alt") || (e.shiftKey == true));
        _key.key = e.key;
        if (settings.keyDown) settings.keyDown(_key);
    };

    _map.addEventListener("mouseenter", function () {
        // console.log("map mouse enter");
        document.addEventListener("keydown", kdown);
        document.addEventListener("keyup", kup);
    });

    _map.addEventListener("pointerenter", function () {
        //console.log("map pointer enter");
        document.addEventListener("keydown", kdown);
        document.addEventListener("keyup", kup);
    });
    _map.addEventListener("mouseleave", function () {
        // console.log("map mouse leave");
        document.removeEventListener("keydown", kdown);
        document.removeEventListener("keyup", kup);
    });

    /***********************           to handle double click         ***********************/
    _map.addEventListener("dbltap", function (ev) {
        let target = ev.target;
        if (target instanceof H.map.Marker) return; // don't do anything if click on marker

        let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
        let button = ev.currentPointer.button;
        if (settings.dbClick != "") {
            switch (button) {
                case 0: settings.dbClick(coordO2A(coord), "left", _key);
                    break;
                case 2: settings.dbClick(coordO2A(coord), "right", _key);
                    break;
            }
        }
    });

    /***********************           to handle simple click         ***********************/
    _map.addEventListener("tap", function (ev) {
        let target = ev.target;

        if (target instanceof H.map.Marker) return;

        let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
        let button = ev.currentPointer.button;

        if ((button == 0) && (settings.clickLeft))
            settings.clickLeft(coordO2A(coord), "left", _key);
        if ((button == 2) && (settings.clickRight))
            settings.clickRight(coordO2A(coord), "right", _key);
        if (settings.click) {
            switch (button) {
                case 0: settings.click(coordO2A(coord), "left", _key);
                    break;
                case 2: settings.click(coordO2A(coord), "right", _key);
                    break;
            }
        }
    });

    /*********  disable the default draggability of the underlying map when starting to drag a marker object *****************/
    _map.addEventListener("dragstart", function (ev) {
        let target = ev.target;
        if (target instanceof H.map.Marker) {
            _behavior.disable();
        }
    }, false);

    /************   re - enable the default draggability of the underlying map when dragging has completed ***********************/
    _map.addEventListener("dragend", function (ev) {
        let target = ev.target;
        if (target instanceof mapsjs.map.Marker) {
            _behavior.enable();
            if (typeof target.dragged !== "undefined") {
                let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
                (target.dragged)(target, coordO2A(coord));
            }
        }
    }, false);

    /***********************  Listen to the drag event and move the position of the marker as necessary *******************/
    _map.addEventListener("drag", function (ev) {
        let target = ev.target,
            pointer = ev.currentPointer;
        if (target instanceof mapsjs.map.Marker) {
            target.setPosition(_map.screenToGeo(pointer.viewportX, pointer.viewportY));
        }
    }, false);


    /****************  detect map resize and adjust accoridngly ******************************/
    window.addEventListener("resize", function () {
        _map.getViewPort().resize();

    });
}

/**
 * list of all available map styles normal.day, night.... 
 * @alias hm:getAvailableMapStyle
 * @return {json} list of map styles as json
 */
function getAvailableMapStyle() {
    // https://1.base.maps.api.here.com/maptile/2.1/info?xnlp=CL_JSMv3.0.17.0&app_id=nOSh21214JFMSEPQkqno&app_code=rX_l7YvALtNkqU2bx5FWEA&output=json

    const settings = cm.addCredentials({
        output: "json"
    });

    const url = cm.buildUrl("1.base.maps", "api.here.com/maptile/2.1/info");
    return cm.hereRest(url, settings)
        .then(res => {
            return res.body.response;
        });
}

/**
 * define the scheme. List of scheme can be obtained from {hm.getAvailableMapStyle()}
 * @alias hm:setScheme
 * @param {string} scheme scheme name
 */
function setScheme(scheme) {
    _scheme = scheme;
}

/**
 * create a layer
 * @alias hm:layerCreate
 * @param {string} name  - name of layer
 * @param {boolean} visible  - initial status
 * @example
 * ```js
 * hm.layerCreate("layer1");
 *  ```
 */
function layerCreate(name, visible) {
    group = new H.map.Group();
    group.name = name;
    _map.addObject(group);

    // push into list of layers
    _layers.push(group);

    // can be visible or hidden
    if (typeof visible != "undefined")
        group.setVisibility(visible);

    return group;
}

/**
 * delete a layer
 * @alias hm:layerDelete
 * @param {String} name name of layer
 */
function layerDelete(name) {
    let layer = layerFind(name);
    if (!layer)
        return;

    // remove group from map
    _map.removeObject(layer);
    //remove form list of layers
    _layers = _layers.filter(item => { return item.name !== name; });
}

/**
 * Empty a layer,
 * @alias hm:layerEmpty
 * @param {string} layer 
 */
function layerEmpty(name) {
    let layer = layerFind(name);
    if (!layer)
        return;
    layer.removeAll();
}


/**
 * find layer by its name or return null 
 * @alias hm:layerFind
 * @param {string} name 
 */
function layerFind(name) {
    let l = _layers.find(layer => {
        return layer.name == name;
    });
    if (typeof l == "undefined") return null;
    return l;
}


/**
 * set center of the map
* @alias hm:setCenter
 * @param {Array} - coord as [lat,lng]
 * * @example
 * ```js
 * hm.setCenter([48.8,2.3]);
 *  ```
 */
function setCenter(coord) {
    _map.setCenter(coordA2O(coord));
}

/**
 * return coordinate of the center of the map
 * @alias hm:getCenter
 * @returns {coord} coord of the center as \[lat,lng\]
 */
function getCenter() {
    let bound = _map.getViewBounds();
    //_HM.log("viewbound",bound);

    let lng = (bound.ga + bound.ha) / 2;
    let lat = (bound.ka + bound.ja) / 2;
    return [lat, lng];

}

/**
 * return bounding box of visible part of map
 * @alias hm:getViewBB
 * @returns {Object} bouding box of visible part of the map, as \[latm,latM,longm,lngM\]
 */
function getViewBB() {
    let bb = _map.getViewBounds();

    let bb2 = {
        latm: bb.ja,
        latM: bb.ka,
        lngm: bb.ga,
        lngM: bb.ha
    };
    return bb2;
}

/**
 * sets bouding box to be displayed
 * @alias hm:setViewBB
 * @param opt {Object| string}  either an object specifying how to set bounding box, or  a String being the name of a layer
 * @param [opt.layer] {string} bouding box aroud all objects of the layer
 * @param [opt.pois] {array} bouding box aroud all coords defined as \[coord,coord...\]
 * @example
 * ```js
  * hm.setViewBB("layer1");
 *
 * hm.setViewBB({
    *    pois: coords
    * });
 *  ```
 */
function setViewBB(opt) {

    if (typeof opt == "string")
        opt = { layer: opt };

    let settings = {
        layer: null,
        pois: null // array of [lat,lng]
    };
    Object.assign(settings, opt);

    let bbox;

    //set BB based on layer
    if (settings.layer) {
        let layer = layerFind(settings.layer);
        if (!layer) return;

        // get view bound and add a bit around, like 1/5
        let bb = layer.getBounds();
        if (!bb) // as if nothing in layer
            return;
        bb.latm = bb.ja;
        bb.latM = bb.ka;
        bb.lngm = bb.ga;
        bb.lngM = bb.ha;
        let dx = bb.lngM - bb.lngm;
        let dy = bb.latM - bb.latm;
        dx = dx / 5;
        dy = dy / 5;
        bb.latM += dy;
        bb.lngm -= dx;
        bb.latm -= dy;
        bb.lngM += dx;
        bbox = new H.geo.Rect(bb.latM, bb.lngm, bb.latm, bb.lngM);
        _map.setViewBounds(bbox, true);

    }

    else if (settings.pois) {
        let bb = {
            latM: 0,
            lngm: 180,
            latm: 90,
            lngM: -180,
        };
        let arr = settings.pois;
        arr.forEach((poi) => {
            if (poi[0] > bb.latM) bb.latM = poi[0];
            if (poi[1] > bb.lngM) bb.lngM = poi[1];
            if (poi[0] < bb.latm) bb.latm = poi[0];
            if (poi[1] < bb.lngm) bb.lngm = poi[1];
        });
        bbox = new H.geo.Rect(bb.latM, bb.lngm, bb.latm, bb.lngM);
        _map.setViewBounds(bbox, true);
    }
}


/**
 * return zoom value
 * @alias hm:getZoom
 * @returns {number} zoom level
 */
function getZoom() {
    return _map.getZoom();
}

/**
 * set zoom level
 * @alias hm:setZoom
 * @param {number} zoom 
 */
function setZoom(zoom) {
    _map.setZoom(zoom);
}



/**
 * create an icon, to be used for a marker
 * @async
 * @alias hm:buildIcon
 * @param opt {object} options to specify the icon
 * @param [opt.img] {string}  use a png/jpg image. Specify the url 
 * @param [opt.svg] {string}  url a svg. This can be an inline svg, a url, or a svg from heremap
 * @param [opt.opt] {object}   style object
 * @param [opt.opt.size] {number|string}   size of icon, as 24 or 24x32
 * @param [opt.opt.ratio] {number}   for svg files, ratio of size. 0.5 = half
 * @param [opt.opt.anchor] {number|string}   anchor of icon, as 24 or "24x32" or "center". By default, bottom-center
 * @param [opt.opt.tag] {string}   for svg, any tag like{tag}. will be replaced by associated value
 * @return {H.map.Icon} the created icon
 * @example 
 * ```js
 * hm.buildIcon({
 *    img: "http://whatever.com/image.png",
 *    opt: {size:24}
 * });
 * 
 * hm.buildIcon({
 *    svg: "http://whatever.com/image.svg",
 *    opt: {
 *       ratio:0.5,
 *       anchor:24x32
 *    }
 * });
 *  
 * hm.buildIcon({
 *    svg: "svg/cluster.svg",
 *    opt: {
 *       size:24,
 *       color:"red"
 *    }
 * });
 * 
 * const svg = `<svg width="16" height="16" xmlns="http://www.w3.org/2000/svg"> <ellipse stroke="null" ry="8" rx="7.618896" id="svg_1" cy="8" cx="7.837427" fill="{color}" fill-opacity="0.9"/></svg>`;
 * hm.buildIcon({
 *    svg: svg,
 *    opt: {
 *       size:24,
 *       color:"red"
 *    } 
 * });
 *  ```
 */
async function buildIcon(opt) {
    let settings = {
        img: null,             //   png, jpg. if not http in the beginning, look locally
        svg: null,             // svg file:  is a url or a string
        opt: null,              // size, color, anchor, text...s
    };

    Object.assign(settings, opt);

    if (!settings.img && !settings.svg) {
        return null;
    }

    let icon, iconSrc;

    if (settings.img) {
        // console.log("settings.img", settings.img);

        if (settings.img.substr(0, 4) == "http") // url
            iconSrc = settings.img;
        else
            iconSrc = cm.getHome() + settings.img; // local file

    }
    else if (settings.svg) {

        let url = null;
        iconSrc = settings.svg;
        if (settings.svg.substr(0, 4) == "http") // url
            url = settings.svg;
        else if (settings.svg.substr(0, 4) == "<svg") // url
            url = null;
        else
            url = cm.getHome() + settings.svg; //missing protocol, not an embedded string, look in local heremap module

        if (url) // an url to download
            iconSrc = await fetch(url)
                .then(res => {
                    if (res.status != 200)
                        return null;
                    return res.text();
                });
    }

    let iconOpt = { crossOrigin: true }; // to avoid issued with capture
    if (settings.opt && settings.opt.size) {
        let w, h;
        if (typeof settings.opt.size == "number")
            w = h = settings.opt.size;
        else
            [w, h] = settings.opt.size.split("x");

        iconOpt.size = { w: w, h: h };
    }

    function _getsizeSvg(iconSrc) {
        let w = null, h = null, match;
        let r = /width="(\d+)"/;
        match = iconSrc.match(r);
        if (match) w = match[1];

        r = /height="(\d+)"/;
        match = iconSrc.match(r);
        if (match) h = match[1];
        return [w, h];
    }

    if (settings.svg && settings.opt && settings.opt.ratio) {
        let w = null, h = null;
        [w, h] = _getsizeSvg(iconSrc);

        iconOpt.size = { w: Math.floor(w * settings.opt.ratio), h: Math.floor(h * settings.opt.ratio) };
    }

    if (settings.opt && settings.opt.anchor) {
        let w = null, h = null;
        if (typeof settings.opt.anchor == "number")
            w = h = settings.opt.anchor;
        else if (settings.opt.anchor == "center" && settings.svg) {  // for svg file only center: get size of split in 2
            [w, h] = _getsizeSvg(iconSrc);
            w /= 2; h /= 2;
        }
        else
            [w, h] = settings.opt.anchor.split("x");

        if (!w || !h) {
            let e = new Error("BuildIcon: incorrect anchor"); // e.message
            throw (e);
        }
        iconOpt.anchor = new H.math.Point(w, h);
    }

    // all other fields are treated as graphic enhanceent
    if (settings.opt) {
        for (let name in settings.opt) {
            if (name == "file" || name == "size" || name == "anchor") continue;
            let re = new RegExp("{" + name + "}", "g");
            iconSrc = iconSrc.replace(re, settings.opt[name]);
        }
    }

    // console.log("iconSrc", iconSrc);
    // console.log("iconOpt", iconOpt);
    icon = new H.map.Icon(iconSrc, iconOpt);

    return icon;

} //end of icon





/**
 * add a marker in a layer
 * svg files can be created with https://editor.method.ac/ 
 * @async
 * @alias hm:marker
 * @param opt {object} options to create the marker, can be a coord directly
 * @param [opt.layer] {string}   layer name
 * @param [opt.coord] {coord}   coord of the marker as \[lat,lng\]
 * @param [opt.icon] {string}   created from hm.buildIcon
 * @param [opt.svg] {string}   see hm.buildIcon
 * @param [opt.opt] {Object}   see hm.buildIcon
 * @param {function} opt.pointerenter  if enter, callback(target,coord,ev)
 * @param {function} opt.pointerClick  if click, callback(target,coord,ev)
 * @param {string} opt.data  optional data
 * @param {boolean} opt.bubble  if true, show buble on click with data
 * @param {boolean} opt.draggable  draggable marker
 * @param {function} opt.dragged  if dragged, callback(target,coord)
 * @example 
 * ```js
 * hm.marker([48.8,2.3]);
 *
 * hm.marker({
 *    coord: [48.8,2.3],
 * });
 * 
 * hm.marker({
    *   svg: "svg/marker.svg",
    *   color:"red",
    *   ratio:0.5
    * });
    * 
 * hm.marker({
 *    img: "http://whatever.com/image.png",
 *    coord: [48.8,2.3]
 * });
 * 
 * hm.marker({
 *    coord: [48.8,2.3],
 *    data:"Hello world",
 *    bubble: true
 * });
 * 
 * hm.marker({
 *    coord: [48.8,2.3],
 *    draggable:true,
 *    dragged: function(target,coord) {console.log("dragged to",coord);}
 * });
*  ```
 */
async function marker(opt) {
    let settings = {
        layer: "default",       //  layer in which to add marker
        coord: null,            //  coord of the marker
        img: null,             //  image can be url, png, jpg..
        svg: null,             // svg file
        icon: null,              // icon previously created
        opt: {},               // opt for icon
        pointerEnter: null,     //  callback(target,coord,ev)
        pointerClick: null,     //  callback(target,coord,ev)
        data: null,             //  user data
        bubble: false,          //  show a bubble with user data
        draggable: false,       //  icon is draggalbe
        dragged: null           //  callback(target,coord)
    };

    // can pass directly only the coord
    if (Array.isArray(opt))
        opt.coord = opt;

    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    settings.coord = { lat: settings.coord[0], lng: settings.coord[1] };

    // these parameters can be in opt.opt or directly in opt
    if (settings.color) settings.opt.color = settings.color;
    if (settings.size) settings.opt.size = settings.size;
    if (settings.ratio) settings.opt.ratio = settings.ratio;
    if (settings.anchor) settings.opt.anchor = settings.anchor;

    let markerOpt = null;
    if (settings.img || settings.svg) {
        let icon = await buildIcon(settings);
        markerOpt = { icon: icon };
    }
    else if (settings.icon) {
        markerOpt = { icon: settings.icon };
    }

    //console.log("marker settings.coord", settings.coord);
    let marker = new H.map.Marker(settings.coord, markerOpt);

    marker.draggable = settings.draggable;

    if (settings.dragged) marker.dragged = settings.dragged;

    if (settings.data) {
        let data = settings.data;
        if (settings.data == "__OPT__") {
            data = settings;
            delete data.coord;
            for (let p in data)
                if (!data[p]) delete data[p];
            data = JSON.stringify(data, null, 2).replace(/\n/g, "<br/>");
        }
        marker.setData(data);
    }

    // get click from mouse
    if (settings.pointerEnter) {
        marker.addEventListener("pointerenter", function (ev) {

            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, coordO2A(coord), ev);

        });
    }

    /************  callback when click on marker *****************************/
    if (settings.pointerClick) {
        marker.addEventListener("tap", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, coordO2A(coord), ev);

        });
    }

    /************  show a bubble when clicking on marker *****************************/
    if (settings.bubble) {
        marker.addEventListener("tap", function (ev) {

            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);

            bubbleUnique(coordO2A(coord), data);
        });
    }

    layer.addObject(marker);
    return marker;

} //end of marker

/**
 * display a unique bubble. Associated CSS style is .H_ib_body
 * @alias hm:bubbleUnique
 * @param {Array} coord of the bubble
 * @param {String} txt html text to display
 */
function bubbleUnique(coord, txt) {

    if (!_bubbleMarker) {
        _bubbleMarker = new H.ui.InfoBubble(
            coordA2O(coord), {
                content: txt
            });

        _ui.addBubble(_bubbleMarker);
        _bubbleMarker.addClass("bubbleUnique");

    } else {
        _bubbleMarker.setPosition(coordA2O(coord));
        _bubbleMarker.setContent(txt);
        _bubbleMarker.open();
    }

}


/**
 * hide a unique bubble
 * @alias hm:bubbleUniqueHide
 */
function bubbleUniqueHide() {
    if (!_bubbleMarker)
        return;
    _bubbleMarker.close();
}




/**
 * Draw a polyline. 
 * @alias hm:polyline
 * @param opt {object}   options to draw polyline
 * @param [opt.layer] {String} optional layer to use 
 * @param [opt.coords] {array} array of coords, as \[\[48.8,2.3\],\[48.85,2.4\],... \]
 * @param [opt.style] {object} optional graphic style
 * @param [opt.lineWidth=4] {number} line width
 * @param [opt.style.strokeColor=rgba(0, 128, 255, 0.7)] {string} line color
 * @param [opt.arrows] {object} optional arrow
 * @param [opt.data] {String} optional user data
 * @param [opt.pointerClick] {function} optional callback if click on line. format callback(target,coord,event)
 * @param [opt.pointerenter] {function} optional callback if mouse enters on line. format callback(target,coord,event)
 * @param [opt.pointerLeave] {function} optional callback if mouse leaves the line. format callback(target,coord,event)
 * @param [opt.z] {number} optional z level
* ```js
* hm.polyline({
    *    coords: [[48.8,2.3],[48.85,2.4],[48.9,2.6]],
    *    layer:"layer1"
    * });
    * 
    * hm.polyline({
    *    coords: coords,
    *    style: {
    *        lineWidth: 4,
    *        strokeColor: "red"
    *    },
    * });
    * 
    * hm.polyline({
        *    coords: coords,
        *    data:"Hello World",
        * });
    *  ```
 */
function polyline(opt) {
    let settings = {
        layer: "default",
        coords: null, // coords is list of array of [lat,lng] or array of object with {lat:,lng:}
        style: {
            lineWidth: 4,
            strokeColor: "rgba(0, 128, 255, 0.7)"
        },
        arrows: null,
        data: null,         // optional user data 
        z: null,
        pointerClick: null, // click
        pointerEnter: null, // call back
        pointerLeave: null // call back
    };

    if (Array.isArray(opt)) // directement les coord
        opt = { coords: opt };

    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    if (!settings.coords) {
        let e = new Error("Polyline: coords not found:"); // e.message
        throw (e);
    }

    let strip = new H.geo.Strip();

    settings.coords.forEach(function (point) {
        strip.pushLatLngAlt(point[0], point[1]);
    });

    let polyline = new H.map.Polyline(strip, {
        style: settings.style,
        data: settings.data,
        arrows: settings.arrows
    });

    // Z index
    if (settings.z) polyline.setZIndex(settings.z);
    // user data
    if (settings.data) polyline.setData(settings.data);

    if (settings.pointerEnter)
        polyline.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, coordO2A(coord), ev);
        });
    if (settings.pointerLeave)
        polyline.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerLeave(target, coordO2A(coord), ev);
        });
    if (settings.pointerClick)
        polyline.addEventListener("tap", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, coordO2A(coord), ev);
        });

    layer.addObject(polyline);

    return polyline;
}


/**
 * Draw a polygon
 * @alias hm:polygon
 * @param {Object} opt  options to draw a polygon. Same options as hm.polyline
 */
function polygon(opt) {
    let settings = {
        layer: "default",
        coords: "", // coords is array of [lat,lng] or array of {lat:,lng:}
        style: {
            lineWidth: 4,
            strokeColor: "rgba(0, 128, 255, 0.7)",
            fillColor: "rgba(0, 128, 255, 0.7)"
        },
        styleHover: null, // style si mouse over
        arrows: null,
        data: null, // additional data to carry
        z: null,
        pointerClick: null, // click
        pointerEnter: null, // call back
        pointerLeave: null // call back
    };
    if (Array.isArray(opt)) // directement les coord
        opt = { coords: opt };
    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    if (!settings.coords) {
        let e = new Error("Polyline: coords not found:"); // e.message
        throw (e);
    }

    let strip = new H.geo.Strip();
    settings.coords.forEach(function (point) {
        strip.pushLatLngAlt(point[0], point[1]);
    });

    let polygon = new H.map.Polygon(strip, {
        style: settings.style,
        data: settings.data,
        arrows: settings.arrows
    });

    if (settings.data) polygon.setData(settings.data);
    // Z index
    if (settings.z) polyline.setZIndex(settings.z);

    // si un style de hover
    if (settings.styleHover) {
        polygon.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            target.setStyle(settings.styleHover);
        });
        polygon.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            target.setStyle(settings.style);
        });
    }

    if (settings.pointerEnter)
        polygon.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, coordO2A(coord), ev, data);
        });
    if (settings.pointerLeave)
        polygon.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerLeave(target, coordO2A(coord), ev, data);
        });
    if (settings.pointerClick)
        polygon.addEventListener("tap", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, coordO2A(coord), ev, data);
        });

    layer.addObject(polygon);

    return polygon;
} // end of polygon

/**
 * draw a circle
 * @alias hm:circle
 * @param opt {*}   option for circle
 * @param [opt.layer] {String} optional layer to use 
 * @param [opt.coord] {array} center of the circle, as \[48.8,2.3\]
 * @param [opt.radius] {number} radius in meter
 * @param [opt.style] {object} optional graphic style
 * @param [opt.style.strokeColor] {string} color of perimeter
 * @param [opt.style.lineWidth] {number} line width
 * @param [opt.style.fillColor] {string} fill color
 */
function circle(opt) {
    let settings = {
        layer: "default",
        coord: null,
        radius: 100, // meters
        style: {
            strokeColor: "rgba(55, 85, 170, 0.2)", // Color of the perimeter
            lineWidth: 2,
            fillColor: "rgba(0, 128, 0, 0.1)"  // Color of the circle
        }

    };
    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }
    let circle = new H.map.Circle(
        // The central point of the circle
        coordA2O(settings.coord),
        // The radius of the circle in meters
        settings.radius,
        {
            style: settings.style
        }
    );

    layer.addObject(circle);
    return circle;
}




/**
 * watch position on HTML5 position. requires HTTPS
 * @async
 * @alias hm:locateMe
 * @param callback {function}  callback when coord changes. Format: callback(coord,accuracy) 
 * @param opt {Object} optional graphic options
 * @param [opt.position] {object}  graphic options for center. See buildIcon
 * @param [opt.position.svg] {string}  svg file
 * @param [opt.position.color] {string}  color for  {color} tag
 * @param [opt.position.size] {number}  size of icon
 * @param [opt.position.anchor] {number}  anchor of icon
 * @param [opt.accuracy] {object}  graphic options for accuracy representation
 * @param [opt.accuracy.strokeColor] {String}  color of circle line representing accuracy area
 * @param [opt.accuracy.lineWidth] {number}  width of line of circle
 * @param [opt.accuracy.fillColor] {String}  fill color of circle representing accuracy area
 */
async function locateMe(callback, opt) {

    // if no callback, remove the watch
    if (navigator.geolocation) {
        if (!callback && _locateMe) {
            navigator.geolocation.clearWatch(_locateMe);
            _locateMe = null;
            return;
        }

        let settings = {
            position: {
                svg: "svg/target.svg",
                color: "black",
                anchor: "center"
            },
            accuracy: {
                strokeColor: "rgba(0, 128, 0, 0.8)", // Color of the perimeter
                lineWidth: 2,
                fillColor: "rgba(0, 128, 0, 0.4)"  // Color of the circle
            }
        };
        Object.assign(settings, opt);

        let iconCrossHair = await buildIcon({
            svg: settings.position.svg,
            img: settings.position.img,
            opt: settings.position
        });


        //navigator.geolocation.getCurrentPosition(function pos(position) {
        _locateMe = navigator.geolocation.watchPosition((position) => {
            let gps = [position.coords.latitude, position.coords.longitude];

            layerEmpty("_gps");

            /* circle showing the accuracy radius*/
            circle({
                layer: "_gps",
                coord: gps,
                radius: position.coords.accuracy,
                style: settings.accuracy
            });

            marker({
                layer: "_gps",
                coord: gps,
                icon: iconCrossHair
            });

            callback(gps, position.coords.accuracy);
        }, (error) => {
            let msg = "";
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    msg += "User denied the request for Geolocation.";
                    break;
                case error.POSITION_UNAVAILABLE:
                    msg += "Location information is unavailable.";
                    break;
                case error.TIMEOUT:
                    msg += "timed out.";
                    break;
                case error.UNKNOWN_ERROR:
                    msg += "An unknown error occurred.";
                    break;
            }
            let e = new Error("HTML5 location error:" + msg); // e.message
            throw (e);
        }, { enableHighAccuracy: true }
        );
    }
    else {
        let e = new Error("no HTML5 geolocation capabilities"); // e.message
        throw (e);
    }
}


/**
 * perform a screenshot of the map and returns a promise with the data
 * @async
 * @alias hm:screenshot
 * @param opt {object} options for screenshot
 * @param [opt.name] {string} filename for download
 * @param [opt.ui] {boolean} true to ui (scale, etc..) in screenshot
 * @param opt {object} options for screenshot
 * 
 * @returns {data} binary data of image
 * 
 */
function screenshot(opt) {
    let para = null;
    if (opt && opt.ui)
        para = [_ui];
    return new Promise(
        (resolve, reject) => {
            _map.capture(function (canvas) {
                if (!canvas)
                    return reject("Map screenshot not supported");

                let dataURL = canvas.toDataURL();
                if (opt && opt.name) {
                    let a = document.createElement("a");
                    a.href = dataURL;
                    a.target = "_blank";
                    a.download = opt.name;
                    document.body.appendChild(a);
                    a.click();
                }
                resolve(dataURL);
            }, para);
        });
}


function getMapHtmlItem() {
    return _htmlItem;
}

function getMap() {
    return _map;
}
function getBehavior() {
    return _behavior;
}


function getUI() {
    return _ui;
}

module.exports = {
    coordO2A: coordO2A,
    coordA2O: coordA2O,
    getMap: getMap,
    getUI: getUI,
    getBehavior: getBehavior,
    getMapHtmlItem: getMapHtmlItem,
    map: map,
    getAvailableMapStyle: getAvailableMapStyle,
    setScheme: setScheme,
    layerCreate: layerCreate,
    layerFind: layerFind,
    layerDelete: layerDelete,
    layerEmpty: layerEmpty,
    buildIcon: buildIcon,
    bubbleUnique: bubbleUnique,
    bubbleUniqueHide: bubbleUniqueHide,
    marker: marker,
    circle: circle,
    polyline: polyline,
    polygon: polygon,
    getCenter: getCenter,
    setCenter: setCenter,
    getZoom: getZoom,
    setZoom: setZoom,
    getviewBB: getViewBB,
    setViewBB: setViewBB,
    locateMe: locateMe,
    screenshot: screenshot

};






},{"./common.js":12}],15:[function(require,module,exports){
"use strict";
const cm = require("./common.js");

/**
 * compute a route with optional waypooints. [See more info on optional parameters](http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
 *  @async
 * @alias hm:route
 * @param {object} source - source as \[lat,lng\]. Can be array of \[lat,lng\] to define waypoints
 * @param {object} dest - dest as \[lat,lng\]. Can be array of \[lat,lng\] to define waypoints
 * @param opt {object} route options 
 * @param [opt.mode=fastest;car;traffic:disabled] {string}  routing mode
 * @param [opt.routeattributes=waypoints,summary,shape] {string}  route attributes
 * @param [opt.maneuverattributes=direction,action] {string}  manoeuver attributes
 * @returns {object} returns { summary: object, coords:array,route: object, body:object}. coords is array of coord, to be used with hm.polyline. 
 *
 * @example
  * ```js
  * const res = await hm.route([48.8,2.3],[48.7,2.5]);
  * console.log (res.summary);
  * 
  * const res = await hm.route([[48.8,2.3],[48.9,2.7]], [49.3,2.5]);
  * console.log (res.route); 
  * 
  * const res = await hm.route([48.8,2.3], [[48.9,2.7], [49.3,2.5]]);
  * console.log (res.summary); 
  * ```
 */
async function route(source, dest, opt) {

    const settings = {
        mode: "fastest;car;traffic:disabled",
        representation: "linkPaging",
        routeattributes: "waypoints,summary,shape",
        maneuverattributes: "direction,action"
    };

    const params = cm.addCredentials(settings, opt);

    // 1 seul source ou array de source ?
    let id = 0;
    if (Array.isArray(source[0]))
        for (var i = 0; i < source.length; i++) {
            let coord = source[i];
            params["waypoint" + id++] = coord[0] + "," + coord[1];
        }
    else
        params["waypoint" + id++] = source[0] + "," + source[1];

    if (Array.isArray(dest[0]))

        for (let i = 0; i < dest.length; i++) {
            let coord = dest[i];
            params["waypoint" + id++] = coord[0] + "," + coord[1];
        }
    else
        params["waypoint" + id++] = dest[0] + "," + dest[1];

    const url = cm.buildUrl("route", "api.here.com/routing/7.2/calculateroute.json");
    return cm.hereRest(url, params, "post")
        .then(res => {

            const route = res.body.response.route[0];
            const summary = route.summary;
            const coords = route.shape.map((latlng => latlng.split(",")));

            return { summary: summary, coords: coords, route: route, body: res.body };

        });

}


/**
 * compute an isoline. [See more info on optional parameters](http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
 * @async
 * @alias hm:isoline
 * @param opt {object} option for isoline
 * @param [opt.start] {coord} coord for starting point of isoline
 * @param [opt.destination] {coord} coord for destination point of isoline
 * @param [opt.rangeType="time"] {string} time or distance
 * @param [opt.range] {number} range in seconds or in meters
 * @param [opt.mode="fastest;car;traffic:disabled"] {String} routing mode
 * @param [opt.linkattributes=sh] {String} attributes to be returned
 * 
 * @returns {object}  returns { poly:array, body:object }. Poly is array of coords, body is full answer
 */
async function isoline(opt) {

    const settings = {
        start: null,                            // for direct isoline
        destination: null,                      // for reverse isoline
        rangeType: "time",                      // time or distance
        range: null,                            // in seconds or meters
        linkattributes: "sh",                   // to get the shape
        mode: "fastest;car;traffic:disabled",   //shortest;car;traffic:disabled 
    };
    const params = cm.addCredentials(settings, opt);

    if (params.start)
        params.start = "geo!" + params.start[0] + "," + params.start[1];
    if (params.destination)
        params.destination = "geo!" + params.destination[0] + "," + params.destination[1];

    if (!params.start && !params.destination) {
        let e = new Error("Isoline routing : missing start or destination"); // e.message
        throw (e);
    }
    if (!params.range) {
        let e = new Error("Isoline routing : missing range"); // e.message
        throw (e);
    }

    const url = cm.buildUrl("isoline.route", "api.here.com/routing/7.2/calculateisoline.json");
    return cm.hereRest(url, params, "post")
        .then(res => {

            // array of lat,lng, to be transformed into array of [lat,lng]
            const shape = res.body.response.isoline[0].component[0].shape;
            const poly = shape.map(point => point.split(","));

            return { poly: poly, body: res.body };
        });

}


/**
 * compute a matrix. [See more info on optional parameters](http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
 * 
 * Matrix size is limited to 1x100, 100x1 or 15xN
 *  @async
 * @alias hm:matrix
 * @param source {object} source as \[lat,lng\]. Can be array of \[lat,lng\]
 * @param dest {object} dest as \[lat,lng\]. Can be array of \[lat,lng\]
 * @param opt {object} additional optional parameters like  mode, summaryAttributes
 * @param [opt.mode="fastest;car;traffic:enabled"] {string} routing mode to compute matrix
 * @param [opt.summaryAttributes="tt,di"] {string} attributes in the answer
 * 
 * @returns {object} { entries: object, body:object }. entries is the array of {start,stop} information. body is full json answer
 * @example
 * ```js
 * const res = await hm.matrix({
 *      source:[48.8,2.3]
 *      dest:[[48.7,2.5],[48.1,2.0],[44.2,2.3]]
 * });
 * console.log (res.entries); 
 * ```
 */

async function matrix(source, dest, opt) {

    var settings = {
        mode: "fastest;car;traffic:enabled",
        summaryAttributes: "tt,di"
    };
    const params = cm.addCredentials(settings, opt);

    if (!Array.isArray(source[0])) // if only one coord
        source = [source];
    source.forEach((coord, i) => {
        params["start" + i] = coord[0] + "," + coord[1];
    });

    if (!Array.isArray(dest[0])) // if only one coord
        dest = [dest];
    dest.forEach((coord, i) => {
        params["destination" + i] = coord[0] + "," + coord[1];
    });

    const url = cm.buildUrl("matrix.route", "api.here.com/routing/7.2/calculatematrix.json");
    return cm.hereRest(url, params, "post")
        .then(res => {
            return { entries: res.body.response.matrixEntry, body: res.body };
        });


}



/**
 * Compute the detour for each waypoint provided, compared to normal route from A to B
 * 
 * @async
 * @alias hm:detour
 * @param start {coord}  starting point for route
 * @param stop {coord}   destination point of route
 * @param waypoints {array}  list of watypoints to test 
 * @returns {object} returns {reference,waypoints:[ {coord,distA,timeA,distB,timeB}]}
 */
async function detour(start, stop, waypoints) {
    // eslint-disable-next-line   no-undef
    return new Promise(
        async (resolve, reject) => {
            //let tStart = new Date();

            if (!start) return reject("missing start point");
            if (!stop) return reject("missing stop point");
            if (!waypoints) return reject("missing waypoints");
            if (!Array.isArray) return reject("waypoints should be an array");


            // initialise le resultat 
            let res = {
                reference: {},
                waypoints: []
            };

            // calcul les coords nonPostGres, creer l'array de coord des waypoints.
            let dest = [stop]; // so we have a distance/time reference, not same as from routing 1:1
            waypoints.forEach(waypoint => {
                dest.push(waypoint);
                res.waypoints.push(
                    { coord: waypoint }
                );
            });
            // inspect(dest, "dest from detour")

            // compute start to all waypoint, 1st waypoint is stop to get a reference
            let p1 = matrix(start, dest, { mode: "fastest;car;traffic:disabled" });

            // compute from all waypoint to stop, 1st waypoint is start to get another reference
            dest[0] = start;
            let p2 = matrix(dest, stop, { mode: "fastest;car;traffic:disabled" });
            // wait for both matrix to complete

            // eslint-disable-next-line   no-undef
            const result = await Promise.all([p1, p2]);

            // process first part: start => N waypoints
            let entries = result[0].entries;
            // first entry is start stop
            let dist = entries[0].summary.distance;
            let time = entries[0].summary.travelTime;
            res.reference.start = start;
            res.reference.stop = stop;
            res.reference.distance = dist;
            res.reference.time = time; // the reference sans waypoint

            entries.forEach((entry, i) => {
                if (i == 0) return; // skip the first which is start stop

                if (entry.status == "failed") {
                    //console.log(entry, "error on matrixA" + i);
                    //console.log(start, "associated start");
                    //console.log(dest[i], "associated dest" + i);
                    return;
                }

                let id = entry.destinationIndex;
                let dist = entry.summary.distance;
                let time = entry.summary.travelTime;
                res.waypoints[id - 1].distA = dist;
                res.waypoints[id - 1].timeA = time;
            });


            // process second part: N waypoints => stop
            entries = result[1].entries;
            //inspect(entries[0], "matrixB0");

            res.reference.distance2 = entries[0].summary.distance;
            res.reference.time2 = entries[0].summary.travelTime;

            entries.forEach((entry, i) => {
                if (i == 0) return; // skip the first which is start stop

                if (entry.status == "failed") {
                    //console.log(entry, "error on matrixB" + i);
                    //console.log(entry, "associated start" + i);
                    //console.log(stop, "associated stop");
                    return;
                }
                let id = entry.startIndex;
                let dist = entry.summary.distance;
                let time = entry.summary.travelTime;
                res.waypoints[id - 1].distB = dist;
                res.waypoints[id - 1].timeB = time;
            });
            return resolve(res);
        });

}


module.exports = {
    matrix: matrix,
    route: route,
    isoline: isoline,
    detour: detour
};


},{"./common.js":12}],16:[function(require,module,exports){
/* global document,H */
"use strict";
const hm = require("./map.js");
const simplify = require("simplify-js");


let _touchOffset = null;
let _touchCoords = null;
let _touchPolyline = null;
let _touchLayer = null;
let _touchCallback = null;
let _map = null;
let _behavior = null;

let _behaviorEnable = true;
function behaviorEnable(onoff) {
    if (_behaviorEnable && !onoff) {
        _behavior.disable();
        //console.log("behavior disabled");
        _behaviorEnable = false;
    }
    if (!_behaviorEnable && onoff) {
        _behavior.enable();
        //console.log("behavior enabled");
        _behaviorEnable = true;
    }
}
/**
 * activate touch, allowing hand drawing, with embedded simplification of the line
 * @alias hm:touch
 * @param onoff {boolean}  activate or deactivate
 * @param options {object} options  to control the touch behaviour
 * @param [options.callback] {function} calling callback(coords) when touch ends
 * @param [options.layer] {string} layer where to put the drawing
 * @param [options.style] {object} drawing style for the line
 * @param [options.arrow] {object} arrow style for the line
 * @param [options.tolerance=4] {number} tolerance for simplification
 * @param [options.keep=false] {boolean} keep graphic or not when calling callback
 */
function touch(onoff, options) {

    _map = hm.getMap();
    _behavior = hm.getBehavior();
    let elmt = document.getElementById(hm.getMapHtmlItem());

    _touchOffset = { left: elmt.offsetLeft, top: elmt.offsetTop }; // offset of window to browser


    const settings = {
        callback: null,
        layer: "_touch",
        keep: false,
        style: { lineWidth: 5, strokeColor: "rgba(255, 0, 0, 0.7)" },
        arrows: { fillColor: "white", frequency: 5, width: 1, length: 2 },
        tolerance: 4, // level of simplification
    };

    Object.assign(settings, options);

    _touchLayer = hm.layerFind(settings.layer);
    if (!_touchLayer) {
        hm.layerEmpty(settings.layer);
        _touchLayer = hm.layerFind(settings.layer);
    }

    // callback des event Listener
    // defini seulement sur onoff, pour ne pas creer une autre fois la fonction
    if (onoff)
        _touchCallback = function (e) {

            let touchobj = e.changedTouches[0]; // reference first touch point (ie: first finger)

            // if ((e.touches.length >= 2 && e.targetTouches.length >= 2)) {
            if ((e.touches.length >= 2)) {
                //    console.log("touch.length", e.touches.length);
                behaviorEnable(true);
                return;
            }

            if (e.type == "touchmove")
                behaviorEnable(false);

            // e.preventDefault();
            //console.log("e.type", e.type);
            let simplified;

            switch (e.type) {
                case "touchstart":
                    _touchCoords = []; // coords
                    break;

                case "touchmove":
                    //  e.preventDefault();

                    _touchCoords.push({
                        x: touchobj.clientX - _touchOffset.left,
                        y: touchobj.clientY - _touchOffset.top
                    });

                    if (_touchCoords.length < 2)
                        return;

                    var lineString = new H.geo.LineString;

                    for (var i = 0; i < _touchCoords.length; i++) {
                        var coord = _map.screenToGeo(_touchCoords[i].x, _touchCoords[i].y);
                        lineString.pushLatLngAlt(coord.lat, coord.lng, 0);
                    }

                    // create lpolyline if not exists
                    if (!_touchPolyline) {
                        _touchPolyline = new H.map.Polyline(lineString, {
                            style: settings.style,
                            arrows: settings.arrows
                        });
                        _touchLayer.addObject(_touchPolyline);
                    } else  // modif geometry
                        _touchPolyline.setGeometry(lineString);
                    break;

                case "touchend": // c'est la fin, on simplifie et appelle le callback
                    if (_touchCoords.length < 2) // not enough points
                        return;

                    simplified = _touchCoords; //as {x,y}
                    if (settings.callback) {

                        // simplify the result
                        if (settings.tolerance > 0) {
                            let coordsxy = _touchCoords.map(coord => { return { x: coord[1], y: coord[0] }; });
                            simplified = simplify(coordsxy, settings.tolerance, false);
                        }

                        if (simplified.length < 1) // not enough points
                            return;

                        // convert back to [lat,lng]
                        let coords = simplified.map(coord => {
                            let latlng = _map.screenToGeo(coord.x, coord.y);
                            return [latlng.lat, latlng.lng];
                        });

                        //up to callback to redraw
                        if (_touchPolyline && !settings.keep)
                            _touchLayer.removeObject(_touchPolyline);
                        _touchPolyline = null;

                        behaviorEnable(true);
                        // run callback
                        settings.callback(coords);
                    }
                    break;
            }

        }; // of _touch



    if (onoff) {
        elmt.addEventListener("touchstart", _touchCallback);
        elmt.addEventListener("touchmove", _touchCallback);
        elmt.addEventListener("touchend", _touchCallback);
        //        behaviorEnable(false);

    } else {
        elmt.removeEventListener("touchstart", _touchCallback);
        elmt.removeEventListener("touchmove", _touchCallback);
        elmt.removeEventListener("touchend", _touchCallback);

        if (_touchPolyline)
            _touchLayer.removeObject(_touchPolyline);

        _touchLayer = null;
        _touchPolyline = null;
        _touchCoords = null;
        behaviorEnable(true);
    }


} // of touch


module.exports = {
    touch: touch

};
},{"./map.js":14,"simplify-js":2}],"heremap.js":[function(require,module,exports){
(function (process){
"use strict";

/*
 * @module HEREMAP
 * @typicalname hm
 */

let modules = {};
Object.assign(modules, require("./common.js"));
Object.assign(modules, require("./routing.js"));
Object.assign(modules, require("./geocoding.js"));
Object.assign(modules, require("./autocomplete.js"));

if (process.browser) {
    Object.assign(modules, require("./map.js"));
    Object.assign(modules, require("./cluster.js"));
    Object.assign(modules, require("./touch.js"));
}
// export all the above
module.exports = modules;

}).call(this,require('_process'))

},{"./autocomplete.js":10,"./cluster.js":11,"./common.js":12,"./geocoding.js":13,"./map.js":14,"./routing.js":15,"./touch.js":16,"_process":1}]},{},[12,14,15,13,11,16,10])("heremap.js")
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3NpbXBsaWZ5LWpzL3NpbXBsaWZ5LmpzIiwiLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvYWdlbnQtYmFzZS5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2lzLW9iamVjdC5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3JlcXVlc3QtYmFzZS5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3Jlc3BvbnNlLWJhc2UuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi91dGlscy5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwiYXV0b2NvbXBsZXRlLmpzIiwiY2x1c3Rlci5qcyIsImNvbW1vbi5qcyIsImdlb2NvZGluZy5qcyIsIm1hcC5qcyIsInJvdXRpbmcuanMiLCJ0b3VjaC5qcyIsImhlcmVtYXAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLypcbiAoYykgMjAxNywgVmxhZGltaXIgQWdhZm9ua2luXG4gU2ltcGxpZnkuanMsIGEgaGlnaC1wZXJmb3JtYW5jZSBKUyBwb2x5bGluZSBzaW1wbGlmaWNhdGlvbiBsaWJyYXJ5XG4gbW91cm5lci5naXRodWIuaW8vc2ltcGxpZnktanNcbiovXG5cbihmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gdG8gc3VpdCB5b3VyIHBvaW50IGZvcm1hdCwgcnVuIHNlYXJjaC9yZXBsYWNlIGZvciAnLngnIGFuZCAnLnknO1xuLy8gZm9yIDNEIHZlcnNpb24sIHNlZSAzZCBicmFuY2ggKGNvbmZpZ3VyYWJpbGl0eSB3b3VsZCBkcmF3IHNpZ25pZmljYW50IHBlcmZvcm1hbmNlIG92ZXJoZWFkKVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50c1xuZnVuY3Rpb24gZ2V0U3FEaXN0KHAxLCBwMikge1xuXG4gICAgdmFyIGR4ID0gcDEueCAtIHAyLngsXG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50XG5mdW5jdGlvbiBnZXRTcVNlZ0Rpc3QocCwgcDEsIHAyKSB7XG5cbiAgICB2YXIgeCA9IHAxLngsXG4gICAgICAgIHkgPSBwMS55LFxuICAgICAgICBkeCA9IHAyLnggLSB4LFxuICAgICAgICBkeSA9IHAyLnkgLSB5O1xuXG4gICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG5cbiAgICAgICAgdmFyIHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IHAyLng7XG4gICAgICAgICAgICB5ID0gcDIueTtcblxuICAgICAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICB4ICs9IGR4ICogdDtcbiAgICAgICAgICAgIHkgKz0gZHkgKiB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHggPSBwLnggLSB4O1xuICAgIGR5ID0gcC55IC0geTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbi8vIHJlc3Qgb2YgdGhlIGNvZGUgZG9lc24ndCBjYXJlIGFib3V0IHBvaW50IGZvcm1hdFxuXG4vLyBiYXNpYyBkaXN0YW5jZS1iYXNlZCBzaW1wbGlmaWNhdGlvblxuZnVuY3Rpb24gc2ltcGxpZnlSYWRpYWxEaXN0KHBvaW50cywgc3FUb2xlcmFuY2UpIHtcblxuICAgIHZhciBwcmV2UG9pbnQgPSBwb2ludHNbMF0sXG4gICAgICAgIG5ld1BvaW50cyA9IFtwcmV2UG9pbnRdLFxuICAgICAgICBwb2ludDtcblxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgaWYgKGdldFNxRGlzdChwb2ludCwgcHJldlBvaW50KSA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBuZXdQb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2UG9pbnQgIT09IHBvaW50KSBuZXdQb2ludHMucHVzaChwb2ludCk7XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeURQU3RlcChwb2ludHMsIGZpcnN0LCBsYXN0LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCkge1xuICAgIHZhciBtYXhTcURpc3QgPSBzcVRvbGVyYW5jZSxcbiAgICAgICAgaW5kZXg7XG5cbiAgICBmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgIHZhciBzcURpc3QgPSBnZXRTcVNlZ0Rpc3QocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0pO1xuXG4gICAgICAgIGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIG1heFNxRGlzdCA9IHNxRGlzdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICBpZiAoaW5kZXggLSBmaXJzdCA+IDEpIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgZmlyc3QsIGluZGV4LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gICAgICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbaW5kZXhdKTtcbiAgICAgICAgaWYgKGxhc3QgLSBpbmRleCA+IDEpIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgaW5kZXgsIGxhc3QsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICB9XG59XG5cbi8vIHNpbXBsaWZpY2F0aW9uIHVzaW5nIFJhbWVyLURvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1cbmZ1bmN0aW9uIHNpbXBsaWZ5RG91Z2xhc1BldWNrZXIocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xuICAgIHZhciBsYXN0ID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICB2YXIgc2ltcGxpZmllZCA9IFtwb2ludHNbMF1dO1xuICAgIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgMCwgbGFzdCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbbGFzdF0pO1xuXG4gICAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59XG5cbi8vIGJvdGggYWxnb3JpdGhtcyBjb21iaW5lZCBmb3IgYXdlc29tZSBwZXJmb3JtYW5jZVxuZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UsIGhpZ2hlc3RRdWFsaXR5KSB7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8PSAyKSByZXR1cm4gcG9pbnRzO1xuXG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICE9PSB1bmRlZmluZWQgPyB0b2xlcmFuY2UgKiB0b2xlcmFuY2UgOiAxO1xuXG4gICAgcG9pbnRzID0gaGlnaGVzdFF1YWxpdHkgPyBwb2ludHMgOiBzaW1wbGlmeVJhZGlhbERpc3QocG9pbnRzLCBzcVRvbGVyYW5jZSk7XG4gICAgcG9pbnRzID0gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcihwb2ludHMsIHNxVG9sZXJhbmNlKTtcblxuICAgIHJldHVybiBwb2ludHM7XG59XG5cbi8vIGV4cG9ydCBhcyBBTUQgbW9kdWxlIC8gTm9kZSBtb2R1bGUgLyBicm93c2VyIG9yIHdvcmtlciB2YXJpYWJsZVxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2ltcGxpZnk7IH0pO1xuZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNpbXBsaWZ5O1xuICAgIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBzaW1wbGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBzZWxmLnNpbXBsaWZ5ID0gc2ltcGxpZnk7XG5lbHNlIHdpbmRvdy5zaW1wbGlmeSA9IHNpbXBsaWZ5O1xuXG59KSgpO1xuIiwiZnVuY3Rpb24gQWdlbnQoKSB7XG4gIHRoaXMuX2RlZmF1bHRzID0gW107XG59XG5cbltcInVzZVwiLCBcIm9uXCIsIFwib25jZVwiLCBcInNldFwiLCBcInF1ZXJ5XCIsIFwidHlwZVwiLCBcImFjY2VwdFwiLCBcImF1dGhcIiwgXCJ3aXRoQ3JlZGVudGlhbHNcIiwgXCJzb3J0UXVlcnlcIiwgXCJyZXRyeVwiLCBcIm9rXCIsIFwicmVkaXJlY3RzXCIsXG4gXCJ0aW1lb3V0XCIsIFwiYnVmZmVyXCIsIFwic2VyaWFsaXplXCIsIFwicGFyc2VcIiwgXCJjYVwiLCBcImtleVwiLCBcInBmeFwiLCBcImNlcnRcIl0uZm9yRWFjaChmbiA9PiB7XG4gIC8qKiBEZWZhdWx0IHNldHRpbmcgZm9yIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgYWdlbnQgKi9cbiAgQWdlbnQucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9kZWZhdWx0cy5wdXNoKHtmbiwgYXJnc30pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuQWdlbnQucHJvdG90eXBlLl9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uKHJlcSkge1xuICAgIHRoaXMuX2RlZmF1bHRzLmZvckVhY2goZGVmID0+IHtcbiAgICAgIHJlcVtkZWYuZm5dLmFwcGx5KHJlcSwgZGVmLmFyZ3MpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudDtcbiIsIi8qKlxuICogUm9vdCByZWZlcmVuY2UgZm9yIGlmcmFtZXMuXG4gKi9cblxubGV0IHJvb3Q7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gQnJvd3NlciB3aW5kb3dcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IC8vIFdlYiBXb3JrZXJcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgeyAvLyBPdGhlciBlbnZpcm9ubWVudHNcbiAgY29uc29sZS53YXJuKFwiVXNpbmcgYnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcbiAgcm9vdCA9IHRoaXM7XG59XG5cbmNvbnN0IEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuY29uc3QgUmVxdWVzdEJhc2UgPSByZXF1aXJlKCcuL3JlcXVlc3QtYmFzZScpO1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuY29uc3QgUmVzcG9uc2VCYXNlID0gcmVxdWlyZSgnLi9yZXNwb25zZS1iYXNlJyk7XG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQtYmFzZScpO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe307XG5cbi8qKlxuICogRXhwb3NlIGByZXF1ZXN0YC5cbiAqL1xuXG5jb25zdCByZXF1ZXN0ID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0aG9kLCB1cmwpIHtcbiAgLy8gY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHVybCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpLmVuZCh1cmwpO1xuICB9XG5cbiAgLy8gdXJsIGZpcnN0XG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdCgnR0VUJywgbWV0aG9kKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbn07XG5cbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5yZXF1ZXN0LmdldFhIUiA9ICgpID0+IHtcbiAgaWYgKHJvb3QuWE1MSHR0cFJlcXVlc3RcbiAgICAgICYmICghcm9vdC5sb2NhdGlvbiB8fCAnZmlsZTonICE9IHJvb3QubG9jYXRpb24ucHJvdG9jb2xcbiAgICAgICAgICB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICB0aHJvdyBFcnJvcihcIkJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSXCIpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IHRyaW0gPSAnJy50cmltXG4gID8gcyA9PiBzLnRyaW0oKVxuICA6IHMgPT4gcy5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csICcnKTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShvYmopIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICBjb25zdCBwYWlycyA9IFtdO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCBvYmpba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBIZWxwcyAnc2VyaWFsaXplJyB3aXRoIHNlcmlhbGl6aW5nIGFycmF5cy5cbiAqIE11dGF0ZXMgdGhlIHBhaXJzIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2YWwpIHtcbiAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFsLmZvckVhY2godiA9PiB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBmb3IoY29uc3Qgc3Via2V5IGluIHZhbCkge1xuICAgICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywgYCR7a2V5fVske3N1YmtleX1dYCwgdmFsW3N1YmtleV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgICAgICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cbiAqL1xuXG5yZXF1ZXN0LnNlcmlhbGl6ZU9iamVjdCA9IHNlcmlhbGl6ZTtcblxuLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xuICBjb25zdCBvYmogPSB7fTtcbiAgY29uc3QgcGFpcnMgPSBzdHIuc3BsaXQoJyYnKTtcbiAgbGV0IHBhaXI7XG4gIGxldCBwb3M7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBvcyA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpcildID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZSgwLCBwb3MpKV0gPVxuICAgICAgICBkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZShwb3MgKyAxKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFeHBvc2UgcGFyc2VyLlxuICovXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcblxuLyoqXG4gKiBEZWZhdWx0IE1JTUUgdHlwZSBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICovXG5cbnJlcXVlc3QudHlwZXMgPSB7XG4gIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gIHhtbDogJ3RleHQveG1sJyxcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG59O1xuXG4vKipcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXG4gICpcbiAgKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAgKiAgICAgfTtcbiAgKlxuICAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIGBzdHJgIGludG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKHN0cikge1xuICBjb25zdCBsaW5lcyA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pO1xuICBjb25zdCBmaWVsZHMgPSB7fTtcbiAgbGV0IGluZGV4O1xuICBsZXQgbGluZTtcbiAgbGV0IGZpZWxkO1xuICBsZXQgdmFsO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHsgLy8gY291bGQgYmUgZW1wdHkgbGluZSwganVzdCBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGluZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHRyaW0obGluZS5zbGljZShpbmRleCArIDEpKTtcbiAgICBmaWVsZHNbZmllbGRdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNKU09OKG1pbWUpIHtcbiAgLy8gc2hvdWxkIG1hdGNoIC9qc29uIG9yICtqc29uXG4gIC8vIGJ1dCBub3QgL2pzb24tc2VxXG4gIHJldHVybiAvW1xcLytdanNvbigkfFteLVxcd10pLy50ZXN0KG1pbWUpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZShyZXEpIHtcbiAgdGhpcy5yZXEgPSByZXE7XG4gIHRoaXMueGhyID0gdGhpcy5yZXEueGhyO1xuICAvLyByZXNwb25zZVRleHQgaXMgYWNjZXNzaWJsZSBvbmx5IGlmIHJlc3BvbnNlVHlwZSBpcyAnJyBvciAndGV4dCcgYW5kIG9uIG9sZGVyIGJyb3dzZXJzXG4gIHRoaXMudGV4dCA9ICgodGhpcy5yZXEubWV0aG9kICE9J0hFQUQnICYmICh0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICcnIHx8IHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSkgfHwgdHlwZW9mIHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgID8gdGhpcy54aHIucmVzcG9uc2VUZXh0XG4gICAgIDogbnVsbDtcbiAgdGhpcy5zdGF0dXNUZXh0ID0gdGhpcy5yZXEueGhyLnN0YXR1c1RleHQ7XG4gIGxldCBzdGF0dXMgPSB0aGlzLnhoci5zdGF0dXM7XG4gIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgIHN0YXR1cyA9IDIwNDtcbiAgfVxuICB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5fc2V0SGVhZGVyUHJvcGVydGllcyh0aGlzLmhlYWRlcik7XG5cbiAgaWYgKG51bGwgPT09IHRoaXMudGV4dCAmJiByZXEuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHRoaXMuYm9keSA9IHRoaXMueGhyLnJlc3BvbnNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYm9keSA9IHRoaXMucmVxLm1ldGhvZCAhPSAnSEVBRCdcbiAgICAgID8gdGhpcy5fcGFyc2VCb2R5KHRoaXMudGV4dCA/IHRoaXMudGV4dCA6IHRoaXMueGhyLnJlc3BvbnNlKVxuICAgICAgOiBudWxsO1xuICB9XG59XG5cblJlc3BvbnNlQmFzZShSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLl9wYXJzZUJvZHkgPSBmdW5jdGlvbihzdHIpIHtcbiAgbGV0IHBhcnNlID0gcmVxdWVzdC5wYXJzZVt0aGlzLnR5cGVdO1xuICBpZiAodGhpcy5yZXEuX3BhcnNlcikge1xuICAgIHJldHVybiB0aGlzLnJlcS5fcGFyc2VyKHRoaXMsIHN0cik7XG4gIH1cbiAgaWYgKCFwYXJzZSAmJiBpc0pTT04odGhpcy50eXBlKSkge1xuICAgIHBhcnNlID0gcmVxdWVzdC5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICB9XG4gIHJldHVybiBwYXJzZSAmJiBzdHIgJiYgKHN0ci5sZW5ndGggfHwgc3RyIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgID8gcGFyc2Uoc3RyKVxuICAgIDogbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbigpe1xuICBjb25zdCByZXEgPSB0aGlzLnJlcTtcbiAgY29uc3QgbWV0aG9kID0gcmVxLm1ldGhvZDtcbiAgY29uc3QgdXJsID0gcmVxLnVybDtcblxuICBjb25zdCBtc2cgPSBgY2Fubm90ICR7bWV0aG9kfSAke3VybH0gKCR7dGhpcy5zdGF0dXN9KWA7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSBtZXRob2Q7XG4gIGVyci51cmwgPSB1cmw7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBSZXNwb25zZWAuXG4gKi9cblxucmVxdWVzdC5SZXNwb25zZSA9IFJlc3BvbnNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlcXVlc3RgIHdpdGggdGhlIGdpdmVuIGBtZXRob2RgIGFuZCBgdXJsYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5oZWFkZXIgPSB7fTsgLy8gcHJlc2VydmVzIGhlYWRlciBuYW1lIGNhc2VcbiAgdGhpcy5faGVhZGVyID0ge307IC8vIGNvZXJjZXMgaGVhZGVyIG5hbWVzIHRvIGxvd2VyY2FzZVxuICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgbGV0IGVyciA9IG51bGw7XG4gICAgbGV0IHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICAgIC8vIGllOSBkb2Vzbid0IGhhdmUgJ3Jlc3BvbnNlJyBwcm9wZXJ0eVxuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPSB0eXBlb2Ygc2VsZi54aHIucmVzcG9uc2VUeXBlID09ICd1bmRlZmluZWQnID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogc2VsZi54aHIucmVzcG9uc2U7XG4gICAgICAgIC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgICBlcnIuc3RhdHVzID0gc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1c0NvZGUgPSBlcnIuc3RhdHVzOyAvLyBiYWNrd2FyZHMtY29tcGF0IG9ubHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGVyci5zdGF0dXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5jYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuXG4gICAgbGV0IG5ld19lcnI7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2VsZi5faXNSZXNwb25zZU9LKHJlcykpIHtcbiAgICAgICAgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGN1c3RvbV9lcnIpIHtcbiAgICAgIG5ld19lcnIgPSBjdXN0b21fZXJyOyAvLyBvaygpIGNhbGxiYWNrIGNhbiB0aHJvd1xuICAgIH1cblxuICAgIC8vICMxMDAwIGRvbid0IGNhdGNoIGVycm9ycyBmcm9tIHRoZSBjYWxsYmFjayB0byBhdm9pZCBkb3VibGUgY2FsbGluZyBpdFxuICAgIGlmIChuZXdfZXJyKSB7XG4gICAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICAgIG5ld19lcnIuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3X2VyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWl4aW4gYEVtaXR0ZXJgIGFuZCBgUmVxdWVzdEJhc2VgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuUmVxdWVzdEJhc2UoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldCBDb250ZW50LVR5cGUgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGFzc10gb3B0aW9uYWwgaW4gY2FzZSBvZiB1c2luZyAnYmVhcmVyJyBhcyB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycsICdiYXNpYycgb3IgJ2JlYXJlcicgKGRlZmF1bHQgJ2Jhc2ljJylcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucyl7XG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSBwYXNzID0gJyc7XG4gIGlmICh0eXBlb2YgcGFzcyA9PT0gJ29iamVjdCcgJiYgcGFzcyAhPT0gbnVsbCkgeyAvLyBwYXNzIGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHBhc3M7XG4gICAgcGFzcyA9ICcnO1xuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiAnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSA/ICdiYXNpYycgOiAnYXV0bycsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGVuY29kZXIgPSBzdHJpbmcgPT4ge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSkge1xuICAgICAgcmV0dXJuIGJ0b2Eoc3RyaW5nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGJhc2ljIGF1dGgsIGJ0b2EgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfTtcblxuICByZXR1cm4gdGhpcy5fYXV0aCh1c2VyLCBwYXNzLCBvcHRpb25zLCBlbmNvZGVyKTtcbn07XG5cbi8qKlxuICogQWRkIHF1ZXJ5LXN0cmluZyBgdmFsYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuICogICAgIC5xdWVyeSgnc2l6ZT0xMCcpXG4gKiAgICAgLnF1ZXJ5KHsgY29sb3I6ICdibHVlJyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2YWwpe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHZhbCkgdmFsID0gc2VyaWFsaXplKHZhbCk7XG4gIGlmICh2YWwpIHRoaXMuX3F1ZXJ5LnB1c2godmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBvcHRpb25zYCAob3IgZmlsZW5hbWUpLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmF0dGFjaCgnY29udGVudCcsIG5ldyBCbG9iKFsnPGEgaWQ9XCJhXCI+PGIgaWQ9XCJiXCI+aGV5ITwvYj48L2E+J10sIHsgdHlwZTogXCJ0ZXh0L2h0bWxcIn0pKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKGZpZWxkLCBmaWxlLCBvcHRpb25zKXtcbiAgaWYgKGZpbGUpIHtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJzdXBlcmFnZW50IGNhbid0IG1peCAuc2VuZCgpIGFuZCAuYXR0YWNoKClcIik7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIG9wdGlvbnMgfHwgZmlsZS5uYW1lKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9nZXRGb3JtRGF0YSA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aGlzLl9mb3JtRGF0YSA9IG5ldyByb290LkZvcm1EYXRhKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Zvcm1EYXRhO1xufTtcblxuLyoqXG4gKiBJbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYGVycmAgYW5kIGByZXNgXG4gKiBhbmQgaGFuZGxlIGFyaXR5IGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgcmVzKXtcbiAgaWYgKHRoaXMuX3Nob3VsZFJldHJ5KGVyciwgcmVzKSkge1xuICAgIHJldHVybiB0aGlzLl9yZXRyeSgpO1xuICB9XG5cbiAgY29uc3QgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICBpZiAoZXJyKSB7XG4gICAgaWYgKHRoaXMuX21heFJldHJpZXMpIGVyci5yZXRyaWVzID0gdGhpcy5fcmV0cmllcyAtIDE7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBmbihlcnIsIHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbigpe1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgaGFzIGJlZW4gdGVybWluYXRlZFxcblBvc3NpYmxlIGNhdXNlczogdGhlIG5ldHdvcmsgaXMgb2ZmbGluZSwgT3JpZ2luIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiwgdGhlIHBhZ2UgaXMgYmVpbmcgdW5sb2FkZWQsIGV0Yy4nKTtcbiAgZXJyLmNyb3NzRG9tYWluID0gdHJ1ZTtcblxuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSB0aGlzLm1ldGhvZDtcbiAgZXJyLnVybCA9IHRoaXMudXJsO1xuXG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8vIFRoaXMgb25seSB3YXJucywgYmVjYXVzZSB0aGUgcmVxdWVzdCBpcyBzdGlsbCBsaWtlbHkgdG8gd29ya1xuUmVxdWVzdC5wcm90b3R5cGUuYnVmZmVyID0gUmVxdWVzdC5wcm90b3R5cGUuY2EgPSBSZXF1ZXN0LnByb3RvdHlwZS5hZ2VudCA9IGZ1bmN0aW9uKCl7XG4gIGNvbnNvbGUud2FybihcIlRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudFwiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBUaGlzIHRocm93cywgYmVjYXVzZSBpdCBjYW4ndCBzZW5kL3JlY2VpdmUgZGF0YSBhcyBleHBlY3RlZFxuUmVxdWVzdC5wcm90b3R5cGUucGlwZSA9IFJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gKCkgPT4ge1xuICB0aHJvdyBFcnJvcihcIlN0cmVhbWluZyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblJlcXVlc3QucHJvdG90eXBlLl9pc0hvc3QgPSBmdW5jdGlvbiBfaXNIb3N0KG9iaikge1xuICAvLyBOYXRpdmUgb2JqZWN0cyBzdHJpbmdpZnkgdG8gW29iamVjdCBGaWxlXSwgW29iamVjdCBCbG9iXSwgW29iamVjdCBGb3JtRGF0YV0sIGV0Yy5cbiAgcmV0dXJuIG9iaiAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9iaiAmJiAhQXJyYXkuaXNBcnJheShvYmopICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgY29uc29sZS53YXJuKFwiV2FybmluZzogLmVuZCgpIHdhcyBjYWxsZWQgdHdpY2UuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBzdXBlcmFnZW50XCIpO1xuICB9XG4gIHRoaXMuX2VuZENhbGxlZCA9IHRydWU7XG5cbiAgLy8gc3RvcmUgY2FsbGJhY2tcbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wO1xuXG4gIC8vIHF1ZXJ5c3RyaW5nXG4gIHRoaXMuX2ZpbmFsaXplUXVlcnlTdHJpbmcoKTtcblxuICB0aGlzLl9lbmQoKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHJldHVybiB0aGlzLmNhbGxiYWNrKEVycm9yKFwiVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCBldmVuIGJlZm9yZSAuZW5kKCkgd2FzIGNhbGxlZFwiKSk7XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGNvbnN0IHhociA9ICh0aGlzLnhociA9IHJlcXVlc3QuZ2V0WEhSKCkpO1xuICBsZXQgZGF0YSA9IHRoaXMuX2Zvcm1EYXRhIHx8IHRoaXMuX2RhdGE7XG5cbiAgdGhpcy5fc2V0VGltZW91dHMoKTtcblxuICAvLyBzdGF0ZSBjaGFuZ2VcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMiAmJiBzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgICB9XG4gICAgaWYgKDQgIT0gcmVhZHlTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluIElFOSwgcmVhZHMgdG8gYW55IHByb3BlcnR5IChlLmcuIHN0YXR1cykgb2ZmIG9mIGFuIGFib3J0ZWQgWEhSIHdpbGxcbiAgICAvLyByZXN1bHQgaW4gdGhlIGVycm9yIFwiQ291bGQgbm90IGNvbXBsZXRlIHRoZSBvcGVyYXRpb24gZHVlIHRvIGVycm9yIGMwMGMwMjNmXCJcbiAgICBsZXQgc3RhdHVzO1xuICAgIHRyeSB7IHN0YXR1cyA9IHhoci5zdGF0dXMgfSBjYXRjaChlKSB7IHN0YXR1cyA9IDA7IH1cblxuICAgIGlmICghc3RhdHVzKSB7XG4gICAgICBpZiAoc2VsZi50aW1lZG91dCB8fCBzZWxmLl9hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gIH07XG5cbiAgLy8gcHJvZ3Jlc3NcbiAgY29uc3QgaGFuZGxlUHJvZ3Jlc3MgPSAoZGlyZWN0aW9uLCBlKSA9PiB7XG4gICAgaWYgKGUudG90YWwgPiAwKSB7XG4gICAgICBlLnBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDA7XG4gICAgfVxuICAgIGUuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBlKTtcbiAgfTtcbiAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKCdwcm9ncmVzcycpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHhoci5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAnZG93bmxvYWQnKTtcbiAgICAgIGlmICh4aHIudXBsb2FkKSB7XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ3VwbG9hZCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgLy8gQWNjZXNzaW5nIHhoci51cGxvYWQgZmFpbHMgaW4gSUUgZnJvbSBhIHdlYiB3b3JrZXIsIHNvIGp1c3QgcHJldGVuZCBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgLy8gUmVwb3J0ZWQgaGVyZTpcbiAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvODM3MjQ1L3htbGh0dHByZXF1ZXN0LXVwbG9hZC10aHJvd3MtaW52YWxpZC1hcmd1bWVudC13aGVuLXVzZWQtZnJvbS13ZWItd29ya2VyLWNvbnRleHRcbiAgICB9XG4gIH1cblxuICAvLyBpbml0aWF0ZSByZXF1ZXN0XG4gIHRyeSB7XG4gICAgaWYgKHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHNlZSAjMTE0OVxuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKGVycik7XG4gIH1cblxuICAvLyBDT1JTXG4gIGlmICh0aGlzLl93aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXG4gIC8vIGJvZHlcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSAmJiAnR0VUJyAhPSB0aGlzLm1ldGhvZCAmJiAnSEVBRCcgIT0gdGhpcy5tZXRob2QgJiYgJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgJiYgIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIC8vIHNlcmlhbGl6ZSBzdHVmZlxuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBsZXQgc2VyaWFsaXplID0gdGhpcy5fc2VyaWFsaXplciB8fCByZXF1ZXN0LnNlcmlhbGl6ZVtjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0gOiAnJ107XG4gICAgaWYgKCFzZXJpYWxpemUgJiYgaXNKU09OKGNvbnRlbnRUeXBlKSkge1xuICAgICAgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6ZSkgZGF0YSA9IHNlcmlhbGl6ZShkYXRhKTtcbiAgfVxuXG4gIC8vIHNldCBoZWFkZXIgZmllbGRzXG4gIGZvciAoY29uc3QgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuXG4gICAgaWYgKHRoaXMuaGVhZGVyLmhhc093blByb3BlcnR5KGZpZWxkKSlcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHN0dWZmXG4gIHRoaXMuZW1pdCgncmVxdWVzdCcsIHRoaXMpO1xuXG4gIC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gIHhoci5zZW5kKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgOiBudWxsKTtcbn07XG5cbnJlcXVlc3QuYWdlbnQgPSAoKSA9PiBuZXcgQWdlbnQoKTtcblxuW1wiR0VUXCIsIFwiUE9TVFwiLCBcIk9QVElPTlNcIiwgXCJQQVRDSFwiLCBcIlBVVFwiLCBcIkRFTEVURVwiXS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gIEFnZW50LnByb3RvdHlwZVttZXRob2QudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbih1cmwsIGZuKSB7XG4gICAgY29uc3QgcmVxID0gbmV3IHJlcXVlc3QuUmVxdWVzdChtZXRob2QsIHVybCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdHMocmVxKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJlcS5lbmQoZm4pO1xuICAgIH1cbiAgICByZXR1cm4gcmVxO1xuICB9O1xufSk7XG5cbkFnZW50LnByb3RvdHlwZS5kZWwgPSBBZ2VudC5wcm90b3R5cGVbJ2RlbGV0ZSddO1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBIRUFEIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5oZWFkID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogT1BUSU9OUyBxdWVyeSB0byBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3Qub3B0aW9ucyA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ09QVElPTlMnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWwodXJsLCBkYXRhLCBmbikge1xuICBjb25zdCByZXEgPSByZXF1ZXN0KCdERUxFVEUnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn1cblxucmVxdWVzdFsnZGVsJ10gPSBkZWw7XG5yZXF1ZXN0WydkZWxldGUnXSA9IGRlbDtcblxuLyoqXG4gKiBQQVRDSCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wYXRjaCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBPU1QgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucG9zdCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUFVUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnB1dCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gbnVsbCAhPT0gb2JqICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBvZiBtaXhlZC1pbiBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gbm9kZSBhbmQgY2xpZW50IGNvZGVcbiAqL1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVxdWVzdEJhc2VgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdEJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdEJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdEJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gUmVxdWVzdEJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIENsZWFyIHByZXZpb3VzIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCl7XG4gIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIGNsZWFyVGltZW91dCh0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gIGRlbGV0ZSB0aGlzLl90aW1lcjtcbiAgZGVsZXRlIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXNwb25zZSBib2R5IHBhcnNlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBpbmNvbWluZyBkYXRhIGludG8gcmVxdWVzdC5ib2R5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZm4pe1xuICB0aGlzLl9wYXJzZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBmb3JtYXQgb2YgYmluYXJ5IHJlc3BvbnNlIGJvZHkuXG4gKiBJbiBicm93c2VyIHZhbGlkIGZvcm1hdHMgYXJlICdibG9iJyBhbmQgJ2FycmF5YnVmZmVyJyxcbiAqIHdoaWNoIHJldHVybiBCbG9iIGFuZCBBcnJheUJ1ZmZlciwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEluIE5vZGUgYWxsIHZhbHVlcyByZXN1bHQgaW4gQnVmZmVyLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWwpe1xuICB0aGlzLl9yZXNwb25zZVR5cGUgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlcXVlc3QgYm9keSBzZXJpYWxpemVyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGRhdGEgc2V0IHZpYSAuc2VuZCBvciAuYXR0YWNoIGludG8gcGF5bG9hZCB0byBzZW5kXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShmbil7XG4gIHRoaXMuX3NlcmlhbGl6ZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aW1lb3V0cy5cbiAqXG4gKiAtIHJlc3BvbnNlIHRpbWVvdXQgaXMgdGltZSBiZXR3ZWVuIHNlbmRpbmcgcmVxdWVzdCBhbmQgcmVjZWl2aW5nIHRoZSBmaXJzdCBieXRlIG9mIHRoZSByZXNwb25zZS4gSW5jbHVkZXMgRE5TIGFuZCBjb25uZWN0aW9uIHRpbWUuXG4gKiAtIGRlYWRsaW5lIGlzIHRoZSB0aW1lIGZyb20gc3RhcnQgb2YgdGhlIHJlcXVlc3QgdG8gcmVjZWl2aW5nIHJlc3BvbnNlIGJvZHkgaW4gZnVsbC4gSWYgdGhlIGRlYWRsaW5lIGlzIHRvbyBzaG9ydCBsYXJnZSBmaWxlcyBtYXkgbm90IGxvYWQgYXQgYWxsIG9uIHNsb3cgY29ubmVjdGlvbnMuXG4gKlxuICogVmFsdWUgb2YgMCBvciBmYWxzZSBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gbXMgb3Ige3Jlc3BvbnNlLCBkZWFkbGluZX1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIHRpbWVvdXQob3B0aW9ucyl7XG4gIGlmICghb3B0aW9ucyB8fCAnb2JqZWN0JyAhPT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucztcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZm9yKGNvbnN0IG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgc3dpdGNoKG9wdGlvbikge1xuICAgICAgY2FzZSAnZGVhZGxpbmUnOlxuICAgICAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucy5kZWFkbGluZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZXNwb25zZSc6XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biB0aW1lb3V0IG9wdGlvblwiLCBvcHRpb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBvbiBlcnJvci5cbiAqXG4gKiBGYWlsZWQgcmVxdWVzdHMgd2lsbCBiZSByZXRyaWVkICdjb3VudCcgdGltZXMgaWYgdGltZW91dCBvciBlcnIuY29kZSA+PSA1MDAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24gcmV0cnkoY291bnQsIGZuKXtcbiAgLy8gRGVmYXVsdCB0byAxIGlmIG5vIGNvdW50IHBhc3NlZCBvciB0cnVlXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IGNvdW50ID09PSB0cnVlKSBjb3VudCA9IDE7XG4gIGlmIChjb3VudCA8PSAwKSBjb3VudCA9IDA7XG4gIHRoaXMuX21heFJldHJpZXMgPSBjb3VudDtcbiAgdGhpcy5fcmV0cmllcyA9IDA7XG4gIHRoaXMuX3JldHJ5Q2FsbGJhY2sgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5jb25zdCBFUlJPUl9DT0RFUyA9IFtcbiAgJ0VDT05OUkVTRVQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VBRERSSU5GTycsXG4gICdFU09DS0VUVElNRURPVVQnXG5dO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWQuXG4gKiAoQm9ycm93ZWQgZnJvbSBzZWdtZW50aW8vc3VwZXJhZ2VudC1yZXRyeSlcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IFtyZXNdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9zaG91bGRSZXRyeSA9IGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gIGlmICghdGhpcy5fbWF4UmV0cmllcyB8fCB0aGlzLl9yZXRyaWVzKysgPj0gdGhpcy5fbWF4UmV0cmllcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5fcmV0cnlDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdmVycmlkZSA9IHRoaXMuX3JldHJ5Q2FsbGJhY2soZXJyLCByZXMpO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIHVuZGVmaW5lZCBmYWxscyBiYWNrIHRvIGRlZmF1bHRzXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBpZiAocmVzICYmIHJlcy5zdGF0dXMgJiYgcmVzLnN0YXR1cyA+PSA1MDAgJiYgcmVzLnN0YXR1cyAhPSA1MDEpIHJldHVybiB0cnVlO1xuICBpZiAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICYmIH5FUlJPUl9DT0RFUy5pbmRleE9mKGVyci5jb2RlKSkgcmV0dXJuIHRydWU7XG4gICAgLy8gU3VwZXJhZ2VudCB0aW1lb3V0XG4gICAgaWYgKGVyci50aW1lb3V0ICYmIGVyci5jb2RlID09ICdFQ09OTkFCT1JURUQnKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyLmNyb3NzRG9tYWluKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHJ5IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fcmV0cnkgPSBmdW5jdGlvbigpIHtcblxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIC8vIG5vZGVcbiAgaWYgKHRoaXMucmVxKSB7XG4gICAgdGhpcy5yZXEgPSBudWxsO1xuICAgIHRoaXMucmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIH1cblxuICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7XG4gIHRoaXMudGltZWRvdXQgPSBmYWxzZTtcblxuICByZXR1cm4gdGhpcy5fZW5kKCk7XG59O1xuXG4vKipcbiAqIFByb21pc2Ugc3VwcG9ydFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihyZXNvbHZlLCByZWplY3QpIHtcbiAgaWYgKCF0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IHN1cGVyYWdlbnQgcmVxdWVzdCB3YXMgc2VudCB0d2ljZSwgYmVjYXVzZSBib3RoIC5lbmQoKSBhbmQgLnRoZW4oKSB3ZXJlIGNhbGxlZC4gTmV2ZXIgY2FsbCAuZW5kKCkgaWYgeW91IHVzZSBwcm9taXNlc1wiKTtcbiAgICB9XG4gICAgdGhpcy5fZnVsbGZpbGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoaW5uZXJSZXNvbHZlLCBpbm5lclJlamVjdCkgPT4ge1xuICAgICAgc2VsZi5vbignZXJyb3InLCBpbm5lclJlamVjdCk7XG4gICAgICBzZWxmLmVuZCgoZXJyLCByZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikgaW5uZXJSZWplY3QoZXJyKTtcbiAgICAgICAgZWxzZSBpbm5lclJlc29sdmUocmVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbihjYikge1xuICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgY2IpO1xufTtcblxuLyoqXG4gKiBBbGxvdyBmb3IgZXh0ZW5zaW9uXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmbikge1xuICBmbih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUub2sgPSBmdW5jdGlvbihjYikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNiKSB0aHJvdyBFcnJvcihcIkNhbGxiYWNrIHJlcXVpcmVkXCIpO1xuICB0aGlzLl9va0NhbGxiYWNrID0gY2I7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9pc1Jlc3BvbnNlT0sgPSBmdW5jdGlvbihyZXMpIHtcbiAgaWYgKCFyZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fb2tDYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9va0NhbGxiYWNrKHJlcyk7XG4gIH1cblxuICByZXR1cm4gcmVzLnN0YXR1cyA+PSAyMDAgJiYgcmVzLnN0YXR1cyA8IDMwMDtcbn07XG5cbi8qKlxuICogR2V0IHJlcXVlc3QgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXRIZWFkZXIgPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgYGZpZWxkYCB0byBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLnNldCgnWC1BUEktS2V5JywgJ2Zvb2JhcicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsICdYLUFQSS1LZXknOiAnZm9vYmFyJyB9KVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oZmllbGQsIHZhbCl7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmaWVsZCkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAudW5zZXQoJ1VzZXItQWdlbnQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIGRlbGV0ZSB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG4gIGRlbGV0ZSB0aGlzLmhlYWRlcltmaWVsZF07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZSB0aGUgZmllbGQgYG5hbWVgIGFuZCBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdFxuICogZm9yIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIHJlcXVlc3QgYm9kaWVzLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKCdmb28nLCAnYmFyJylcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKHsgZm9vOiAnYmFyJywgYmF6OiAncXV4JyB9KVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd8QmxvYnxGaWxlfEJ1ZmZlcnxmcy5SZWFkU3RyZWFtfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmZpZWxkID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gIC8vIG5hbWUgc2hvdWxkIGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBvYmplY3QuXG4gIGlmIChudWxsID09PSBuYW1lIHx8IHVuZGVmaW5lZCA9PT0gbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgbmFtZSBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIi5maWVsZCgpIGNhbid0IGJlIHVzZWQgaWYgLnNlbmQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCIpO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZSkge1xuICAgICAgdGhpcy5maWVsZChrZXksIG5hbWVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGZvciAoY29uc3QgaSBpbiB2YWwpIHtcbiAgICAgIHRoaXMuZmllbGQobmFtZSwgdmFsW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB2YWwgc2hvdWxkIGJlIGRlZmluZWQgbm93XG4gIGlmIChudWxsID09PSB2YWwgfHwgdW5kZWZpbmVkID09PSB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIHZhbCBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cbiAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHZhbCkge1xuICAgIHZhbCA9ICcnICsgdmFsO1xuICB9XG4gIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKG5hbWUsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYm9ydCB0aGUgcmVxdWVzdCwgYW5kIGNsZWFyIHBvdGVudGlhbCB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xuICB0aGlzLnhociAmJiB0aGlzLnhoci5hYm9ydCgpOyAvLyBicm93c2VyXG4gIHRoaXMucmVxICYmIHRoaXMucmVxLmFib3J0KCk7IC8vIG5vZGVcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXV0aCA9IGZ1bmN0aW9uKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGJhc2U2NEVuY29kZXIpIHtcbiAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICBjYXNlICdiYXNpYyc6XG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCYXNpYyAke2Jhc2U2NEVuY29kZXIoYCR7dXNlcn06JHtwYXNzfWApfWApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdXRvJzpcbiAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VyO1xuICAgICAgdGhpcy5wYXNzd29yZCA9IHBhc3M7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JlYXJlcic6IC8vIHVzYWdlIHdvdWxkIGJlIC5hdXRoKGFjY2Vzc1Rva2VuLCB7IHR5cGU6ICdiZWFyZXInIH0pXG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHt1c2VyfWApO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHMgPSBmdW5jdGlvbihvbikge1xuICAvLyBUaGlzIGlzIGJyb3dzZXItb25seSBmdW5jdGlvbmFsaXR5LiBOb2RlIHNpZGUgaXMgbm8tb3AuXG4gIGlmIChvbiA9PSB1bmRlZmluZWQpIG9uID0gdHJ1ZTtcbiAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCByZWRpcmVjdHMgdG8gYG5gLiBEb2VzIG5vdGluZyBpbiBicm93c2VyIFhIUiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZWRpcmVjdHMgPSBmdW5jdGlvbihuKXtcbiAgdGhpcy5fbWF4UmVkaXJlY3RzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1heGltdW0gc2l6ZSBvZiBidWZmZXJlZCByZXNwb25zZSBib2R5LCBpbiBieXRlcy4gQ291bnRzIHVuY29tcHJlc3NlZCBzaXplLlxuICogRGVmYXVsdCAyMDBNQi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5tYXhSZXNwb25zZVNpemUgPSBmdW5jdGlvbihuKXtcbiAgaWYgKCdudW1iZXInICE9PSB0eXBlb2Ygbikge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG4gIH1cbiAgdGhpcy5fbWF4UmVzcG9uc2VTaXplID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdG8gYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCAobm90IEpTT04gc3RyaW5nKSBvZiBzY2FsYXIgcHJvcGVydGllcy5cbiAqIE5vdGUgYXMgdGhpcyBtZXRob2QgaXMgZGVzaWduZWQgdG8gcmV0dXJuIGEgdXNlZnVsIG5vbi10aGlzIHZhbHVlLFxuICogaXQgY2Fubm90IGJlIGNoYWluZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZXNjcmliaW5nIG1ldGhvZCwgdXJsLCBhbmQgZGF0YSBvZiB0aGlzIHJlcXVlc3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgdXJsOiB0aGlzLnVybCxcbiAgICBkYXRhOiB0aGlzLl9kYXRhLFxuICAgIGhlYWRlcnM6IHRoaXMuX2hlYWRlcixcbiAgfTtcbn07XG5cbi8qKlxuICogU2VuZCBgZGF0YWAgYXMgdGhlIHJlcXVlc3QgYm9keSwgZGVmYXVsdGluZyB0aGUgYC50eXBlKClgIHRvIFwianNvblwiIHdoZW5cbiAqIGFuIG9iamVjdCBpcyBnaXZlbi5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBtYW51YWwganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdqc29uJylcbiAqICAgICAgICAgLnNlbmQoJ3tcIm5hbWVcIjpcInRqXCJ9JylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtYW51YWwgeC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCgnbmFtZT10aicpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGRlZmF1bHRzIHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAqICAgICAgICAuc2VuZCgnc3BlY2llcz1mZXJyZXQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKXtcbiAgY29uc3QgaXNPYmogPSBpc09iamVjdChkYXRhKTtcbiAgbGV0IHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gIGlmICh0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIi5zZW5kKCkgY2FuJ3QgYmUgdXNlZCBpZiAuYXR0YWNoKCkgb3IgLmZpZWxkKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iaiAmJiAhdGhpcy5fZGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgfSBlbHNlIGlmICghdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEgJiYgdGhpcy5fZGF0YSAmJiB0aGlzLl9pc0hvc3QodGhpcy5fZGF0YSkpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbid0IG1lcmdlIHRoZXNlIHNlbmQgY2FsbHNcIik7XG4gIH1cblxuICAvLyBtZXJnZVxuICBpZiAoaXNPYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgLy8gZGVmYXVsdCB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnZm9ybScpO1xuICAgIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIGlmICgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyA9PSB0eXBlKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YVxuICAgICAgICA/IGAke3RoaXMuX2RhdGF9JiR7ZGF0YX1gXG4gICAgICAgIDogZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGF0YSA9ICh0aGlzLl9kYXRhIHx8ICcnKSArIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG5cbiAgaWYgKCFpc09iaiB8fCB0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdG8ganNvblxuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU29ydCBgcXVlcnlzdHJpbmdgIGJ5IHRoZSBzb3J0IGZ1bmN0aW9uXG4gKlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIGRlZmF1bHQgb3JkZXJcbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KClcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBjdXN0b21pemVkIHNvcnQgZnVuY3Rpb25cbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KGZ1bmN0aW9uKGEsIGIpe1xuICogICAgICAgICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICogICAgICAgICB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNvcnRRdWVyeSA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgLy8gX3NvcnQgZGVmYXVsdCB0byB0cnVlIGJ1dCBvdGhlcndpc2UgY2FuIGJlIGEgZnVuY3Rpb24gb3IgYm9vbGVhblxuICB0aGlzLl9zb3J0ID0gdHlwZW9mIHNvcnQgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IHNvcnQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb21wb3NlIHF1ZXJ5c3RyaW5nIHRvIGFwcGVuZCB0byByZXEudXJsXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fZmluYWxpemVRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIGNvbnN0IHF1ZXJ5ID0gdGhpcy5fcXVlcnkuam9pbignJicpO1xuICBpZiAocXVlcnkpIHtcbiAgICB0aGlzLnVybCArPSAodGhpcy51cmwuaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPycpICsgcXVlcnk7XG4gIH1cbiAgdGhpcy5fcXVlcnkubGVuZ3RoID0gMDsgLy8gTWFrZXMgdGhlIGNhbGwgaWRlbXBvdGVudFxuXG4gIGlmICh0aGlzLl9zb3J0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IHF1ZXJ5QXJyID0gdGhpcy51cmwuc3Vic3RyaW5nKGluZGV4ICsgMSkuc3BsaXQoJyYnKTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5fc29ydCkge1xuICAgICAgICBxdWVyeUFyci5zb3J0KHRoaXMuX3NvcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlBcnIuc29ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgJz8nICsgcXVlcnlBcnIuam9pbignJicpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQgb25seVxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9hcHBlbmRRdWVyeVN0cmluZyA9ICgpID0+IHtjb25zb2xlLnRyYWNlKFwiVW5zdXBwb3J0ZWRcIik7fVxuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHRpbWVvdXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbihyZWFzb24sIHRpbWVvdXQsIGVycm5vKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKGAke3JlYXNvbiArIHRpbWVvdXR9bXMgZXhjZWVkZWRgKTtcbiAgZXJyLnRpbWVvdXQgPSB0aW1lb3V0O1xuICBlcnIuY29kZSA9ICdFQ09OTkFCT1JURUQnO1xuICBlcnIuZXJybm8gPSBlcnJubztcbiAgdGhpcy50aW1lZG91dCA9IHRydWU7XG4gIHRoaXMuYWJvcnQoKTtcbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9zZXRUaW1lb3V0cyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcblxuICAvLyBkZWFkbGluZVxuICBpZiAodGhpcy5fdGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdUaW1lb3V0IG9mICcsIHNlbGYuX3RpbWVvdXQsICdFVElNRScpO1xuICAgIH0sIHRoaXMuX3RpbWVvdXQpO1xuICB9XG4gIC8vIHJlc3BvbnNlIHRpbWVvdXRcbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVGltZW91dCAmJiAhdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdSZXNwb25zZSB0aW1lb3V0IG9mICcsIHNlbGYuX3Jlc3BvbnNlVGltZW91dCwgJ0VUSU1FRE9VVCcpO1xuICAgIH0sIHRoaXMuX3Jlc3BvbnNlVGltZW91dCk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlQmFzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZXNwb25zZUJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VCYXNlYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlQmFzZShvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKGNvbnN0IGtleSBpbiBSZXNwb25zZUJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXNwb25zZUJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiB0aGlzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogU2V0IGhlYWRlciByZWxhdGVkIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGAudHlwZWAgdGhlIGNvbnRlbnQgdHlwZSB3aXRob3V0IHBhcmFtc1xuICpcbiAqIEEgcmVzcG9uc2Ugb2YgXCJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICogd2lsbCBwcm92aWRlIHlvdSB3aXRoIGEgYC50eXBlYCBvZiBcInRleHQvcGxhaW5cIi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRIZWFkZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24oaGVhZGVyKXtcbiAgICAvLyBUT0RPOiBtb2FyIVxuICAgIC8vIFRPRE86IG1ha2UgdGhpcyBhIHV0aWxcblxuICAgIC8vIGNvbnRlbnQtdHlwZVxuICAgIGNvbnN0IGN0ID0gaGVhZGVyWydjb250ZW50LXR5cGUnXSB8fCAnJztcbiAgICB0aGlzLnR5cGUgPSB1dGlscy50eXBlKGN0KTtcblxuICAgIC8vIHBhcmFtc1xuICAgIGNvbnN0IHBhcmFtcyA9IHV0aWxzLnBhcmFtcyhjdCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB0aGlzW2tleV0gPSBwYXJhbXNba2V5XTtcblxuICAgIHRoaXMubGlua3MgPSB7fTtcblxuICAgIC8vIGxpbmtzXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGhlYWRlci5saW5rKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtzID0gdXRpbHMucGFyc2VMaW5rcyhoZWFkZXIubGluayk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgZmxhZ3Mgc3VjaCBhcyBgLm9rYCBiYXNlZCBvbiBgc3RhdHVzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBhIDJ4eCByZXNwb25zZSB3aWxsIGdpdmUgeW91IGEgYC5va2Agb2YgX190cnVlX19cbiAqIHdoZXJlYXMgNXh4IHdpbGwgYmUgX19mYWxzZV9fIGFuZCBgLmVycm9yYCB3aWxsIGJlIF9fdHJ1ZV9fLiBUaGVcbiAqIGAuY2xpZW50RXJyb3JgIGFuZCBgLnNlcnZlckVycm9yYCBhcmUgYWxzbyBhdmFpbGFibGUgdG8gYmUgbW9yZVxuICogc3BlY2lmaWMsIGFuZCBgLnN0YXR1c1R5cGVgIGlzIHRoZSBjbGFzcyBvZiBlcnJvciByYW5naW5nIGZyb20gMS4uNVxuICogc29tZXRpbWVzIHVzZWZ1bCBmb3IgbWFwcGluZyByZXNwb25kIGNvbG9ycyBldGMuXG4gKlxuICogXCJzdWdhclwiIHByb3BlcnRpZXMgYXJlIGFsc28gZGVmaW5lZCBmb3IgY29tbW9uIGNhc2VzLiBDdXJyZW50bHkgcHJvdmlkaW5nOlxuICpcbiAqICAgLSAubm9Db250ZW50XG4gKiAgIC0gLmJhZFJlcXVlc3RcbiAqICAgLSAudW5hdXRob3JpemVkXG4gKiAgIC0gLm5vdEFjY2VwdGFibGVcbiAqICAgLSAubm90Rm91bmRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRTdGF0dXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24oc3RhdHVzKXtcbiAgICBjb25zdCB0eXBlID0gc3RhdHVzIC8gMTAwIHwgMDtcblxuICAgIC8vIHN0YXR1cyAvIGNsYXNzXG4gICAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0dXNUeXBlID0gdHlwZTtcblxuICAgIC8vIGJhc2ljc1xuICAgIHRoaXMuaW5mbyA9IDEgPT0gdHlwZTtcbiAgICB0aGlzLm9rID0gMiA9PSB0eXBlO1xuICAgIHRoaXMucmVkaXJlY3QgPSAzID09IHR5cGU7XG4gICAgdGhpcy5jbGllbnRFcnJvciA9IDQgPT0gdHlwZTtcbiAgICB0aGlzLnNlcnZlckVycm9yID0gNSA9PSB0eXBlO1xuICAgIHRoaXMuZXJyb3IgPSAoNCA9PSB0eXBlIHx8IDUgPT0gdHlwZSlcbiAgICAgICAgPyB0aGlzLnRvRXJyb3IoKVxuICAgICAgICA6IGZhbHNlO1xuXG4gICAgLy8gc3VnYXJcbiAgICB0aGlzLmNyZWF0ZWQgPSAyMDEgPT0gc3RhdHVzO1xuICAgIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICAgIHRoaXMubm9Db250ZW50ID0gMjA0ID09IHN0YXR1cztcbiAgICB0aGlzLmJhZFJlcXVlc3QgPSA0MDAgPT0gc3RhdHVzO1xuICAgIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEFjY2VwdGFibGUgPSA0MDYgPT0gc3RhdHVzO1xuICAgIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEZvdW5kID0gNDA0ID09IHN0YXR1cztcbiAgICB0aGlzLnVucHJvY2Vzc2FibGVFbnRpdHkgPSA0MjIgPT0gc3RhdHVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudHlwZSA9IHN0ciA9PiBzdHIuc3BsaXQoLyAqOyAqLykuc2hpZnQoKTtcblxuLyoqXG4gKiBSZXR1cm4gaGVhZGVyIGZpZWxkIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJhbXMgPSBzdHIgPT4gc3RyLnNwbGl0KC8gKjsgKi8pLnJlZHVjZSgob2JqLCBzdHIpID0+IHtcbiAgY29uc3QgcGFydHMgPSBzdHIuc3BsaXQoLyAqPSAqLyk7XG4gIGNvbnN0IGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gIGNvbnN0IHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgaWYgKGtleSAmJiB2YWwpIG9ialtrZXldID0gdmFsO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIFBhcnNlIExpbmsgaGVhZGVyIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcnNlTGlua3MgPSBzdHIgPT4gc3RyLnNwbGl0KC8gKiwgKi8pLnJlZHVjZSgob2JqLCBzdHIpID0+IHtcbiAgY29uc3QgcGFydHMgPSBzdHIuc3BsaXQoLyAqOyAqLyk7XG4gIGNvbnN0IHVybCA9IHBhcnRzWzBdLnNsaWNlKDEsIC0xKTtcbiAgY29uc3QgcmVsID0gcGFydHNbMV0uc3BsaXQoLyAqPSAqLylbMV0uc2xpY2UoMSwgLTEpO1xuICBvYmpbcmVsXSA9IHVybDtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBTdHJpcCBjb250ZW50IHJlbGF0ZWQgZmllbGRzIGZyb20gYGhlYWRlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuY2xlYW5IZWFkZXIgPSAoaGVhZGVyLCBjaGFuZ2VzT3JpZ2luKSA9PiB7XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LWxlbmd0aCddO1xuICBkZWxldGUgaGVhZGVyWyd0cmFuc2Zlci1lbmNvZGluZyddO1xuICBkZWxldGUgaGVhZGVyWydob3N0J107XG4gIC8vIHNlY3VpcnR5XG4gIGlmIChjaGFuZ2VzT3JpZ2luKSB7XG4gICAgZGVsZXRlIGhlYWRlclsnYXV0aG9yaXphdGlvbiddO1xuICAgIGRlbGV0ZSBoZWFkZXJbJ2Nvb2tpZSddO1xuICB9XG4gIHJldHVybiBoZWFkZXI7XG59O1xuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmNvbnN0IGNtID0gcmVxdWlyZShcImNvbW1vblwiKTtcclxuY29uc3QgbSA9IHJlcXVpcmUoXCJtYXBcIik7XHJcblxyXG5cclxuLyoqXHJcbiAqICBQbGFjZSBhdXRvY29tcGxldGUgZm9yIHVzZSB3aXRoIEpRdWVyeVxyXG4gKiBAYWxpYXMgaG06cGxhY2VBQ1xyXG4gKiBAcGFyYW0gW3F1ZXJ5LnRlcm1dIHtvYmplY3R9IHF1ZXJ5LnRlcm0gY29udGFpbnMgdGhlIHNlYXJjaFxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsZWQgYXMgY2FsbGJhY2soe3RpdGxlLHZhbHVlLGNvb3JkLGpzb259KVxyXG4gKi9cclxuZnVuY3Rpb24gcGxhY2VBQ0pRKHF1ZXJ5LCBjYWxsYmFjaykge1xyXG4gICAgY29uc3QgY2VudGVyID0gbS5nZXRDZW50ZXIoKTtcclxuICAgIGNvbnN0IHBhcmFtcyA9IGNtLmFkZENyZWRlbnRpYWxzKHtcclxuICAgICAgICBhdDogY2VudGVyWzBdICsgXCIsXCIgKyBjZW50ZXJbMV0sXHJcbiAgICAgICAgcTogcXVlcnkudGVybVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXJsID0gY20uYnVpbGRVcmwoXCJwbGFjZXNcIiwgXCJhcGkuaGVyZS5jb20vcGxhY2VzL3YxL2F1dG9zdWdnZXN0XCIpO1xyXG4gICAgY20uaGVyZVJlc3QodXJsLCBwYXJhbXMsIFwiZ2V0XCIsIGZhbHNlKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICAgIHZhciBwbGFjZXMgPSByZXMuYm9keS5yZXN1bHRzLmZpbHRlcihwbGFjZSA9PiBwbGFjZS52aWNpbml0eSk7XHJcblxyXG4gICAgICAgICAgICBwbGFjZXMgPSBwbGFjZXMubWFwKHBsYWNlID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHBsYWNlLnRpdGxlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vdmFsdWU6IHBsYWNlLnRpdGxlICsgJywgJyArIHBsYWNlLnZpY2luaXR5LnJlcGxhY2UoLzxiclxcLz4vZywgXCIsIFwiKSArICcgKCcgKyBwbGFjZS5jYXRlZ29yeSArICcpJyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGxhY2UudGl0bGUgKyAnLCAnICsgcGxhY2UudmljaW5pdHkucmVwbGFjZSgvPGJyXFwvPi9nLCBcIiwgXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkOiBwbGFjZS5wb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICByZXM6IEpTT04uc3RyaW5naWZ5KHBsYWNlKSxcclxuXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2FsbGJhY2socGxhY2VzKTtcclxuICAgICAgICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBwbGFjZUFDSlE6IHBsYWNlQUNKUVxyXG59O1xyXG4iLCIvKiBnbG9iYWwgSCwgZmV0Y2ggKi9cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmNvbnN0IG0gPSByZXF1aXJlKFwibWFwXCIpO1xyXG5cclxubGV0IG1hcCA9IG51bGw7XHJcblxyXG5sZXQgY2x1c3RlckxheWVyID0gbnVsbDtcclxuXHJcblxyXG4vKipcclxuICogY3JlYXRlcyBhIGNsdXN0ZXIgb2YgcG9pbnRzXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06Y2x1c3RlclxyXG4gKiBAcGFyYW0gY29vcmRzIHtBcnJheX0gIGFycmF5IG9mIFxcW2xhdCxsbmcscGF5bG9hZFxcXVxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9IG9wdGlvbnMgZm9yIGNsdXN0ZXJcclxuICogQHBhcmFtIFtvcHQubWluWm9vbV0ge251bWJlcn0gbWluIHpvb20gZm9yIGNsdXN0ZXIgdG8gYmUgdmlzaWJsZVxyXG4gKiBAcGFyYW0gW29wdC5tYXhab29tXSB7bnVtYmVyfSBtYXggem9vbSBmb3IgY2x1c3RlciB0byBiZSB2aXNpYmxlXHJcbiAqIEBwYXJhbSBbb3B0Lm5vaXNlXSB7YXJyYXl9IGdyYXBoaWMgdG8gcmVwcmVzZW50IHN0YW5kLWFsb25lIHBvaW50LiBmb3JtYXQ6IFt1cmwsc2l6ZV0uIEFuY2hvciB3aWxsIGJlIGJvdHRvbS1jZW50ZXJcclxuICogQHBhcmFtIFtvcHQuY2x1c3Rlckljb25dIHtzdHJpbmd9IHVybCBvZiBzdmcgZmlsZSByZXByZXNlbnRpbmcgYSBjbHVzdGVyLiBBbmNob3Igd2lsbCBiZSBtaWRkbGUgb2YgaWNvblxyXG4gKiBAcGFyYW0gW29wdC5zdHlsZV0ge29iamVjdH0gZGVmaW5lIGZvciBlYWNoIG1pbml1bSBhZ2dyZWdhdGlvbiBsZXZlbCB0aGUgY29sb3IgYW5kIHNpemUgb2YgdGhlIGljb24uIFNlZSBleGFtcGxlXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBpZiBjbGljayBvbiBpdGVtLiBGb3JtYXQgY2IoZXZlbnQsIGNvb3JkLCBwYXlsb2FkLCB3ZWlndGgpLiBcclxuICogYGNvb3JkYCBpcyBjb29yZCBvZiBpY29uXHJcbiAqIGBwYXlsb2FkYCBpcyBwYXlsb2FkIGFzc29jaWF0ZWQgdG8gcG9pbnQuIFxyXG4gKiBgd2VpZ2h0YCBpcyBudW1iZXIgb2YgcG9pbnRzIGFnZ3JlZ2F0ZWQsIHdoZW4gY2xpY2tpbmcgb24gYSBjbHVzdGVyIGljb24sIDEgaWYgc2luZ2xlIHBvaW50XHJcbiAqIFxyXG4gKiBAcmV0dXJuIHtILm1hcC5sYXllci5PYmplY3RMYXllcn0gIGxheWVyIGNyZWF0ZWRcclxuICogXHJcbiAgKiBAZXhhbXBsZVxyXG4gICogYGBganNcclxuICAqIGxldCBwb2lzID0gW1s0OC44LDIuMyxcIkhlbGxvIHdvcmxkXCJdLFs0OC41LDIuNCxcIkhvdyBhcmUgeW91XCJdLFs0NS4yLDIuOTMsXCJWZXJ5IHdlbGxcIl1dO1xyXG4gICogXHJcbiAgKiBobS5jbHVzdGVyKHBvaXMpO1xyXG4gICogXHJcbiAgKiAvLyB3aXRoIG1vcmUgZ3JhcGhpYyBvcHRpb25zIGFuZCBjYWxsYmFjayBkZWZpbmVkXHJcbiAqICBobS5jbHVzdGVyKHBvaXMsIHtcclxuICogICAgICAgICAgIG5vaXNlOiBbXCJtY2RvLnBuZ1wiLCAyNF0sXHJcbiAqICAgICAgICAgICBjbHVzdGVySWNvbjogJy4uL3N2Zy9jbHVzdGVyMi5zdmcnLCAgICAvLyAgaWNvbiBmb3IgY2x1c3RlclxyXG4gKiAgICAgICAgICAgc3R5bGU6IHtcclxuICogICAgICAgICAgICAgICAyMDA6IHsgY29sb3I6IFwiI0I1MDAxNVwiLCBzaXplOiA2NCB9ICAvLyBmb3IgMjAwIG9yIG1vcmUgcG9pbnRzIGFnZ3JyZWdhdGVkLCBkcmFnIHJlZCBiaWcgaWNvblxyXG4gKiAgICAgICAgICAgICAgIDc1OiB7IGNvbG9yOiBcIiNGRjY5MDBcIiwgc2l6ZTogNTggfSwgIC8vIGZvciA3NSBvciBtb3JlIHBvaW50cyBhZ2dyZWdhdGVkLiBvcmFuZ2UgbWlkZGxlIHNpemUgaWNvblxyXG4gKiAgICAgICAgICAgICAgIDI6IHsgY29sb3I6IFwiIzdCRDMwQVwiLCBzaXplOiA0NiB9LCAgIC8vIGZvciAyIG9yIG1vcmUgcG9pbnRzIGFnZ3JlZ2F0ZWQuIGdyZWVuIHNtYWxsIGljb25cclxuICogICAgICAgICAgIH1cclxuICogICAgICAgfSxcclxuICogICAgICAgICAgIChldmVudCwgY29vcmRpbmF0ZSwgZGF0YSwgd2VpZ2h0KSA9PiB7XHJcbiAqICAgICAgICAgICAgICAgaWYgKGRhdGEpXHJcbiAqICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2xpY2sgb24gcG9pbnQgXCIsIGRhdGEpO1xyXG4gKiAgICAgICAgICAgICAgIGVsc2VcclxuICogICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjbGljayBvbiBjbHVzdGVyIHdpdGggd2VpZ2h0XCIsIHdlaWdodCk7XHJcbiAqICAgICAgICAgICB9KTtcclxuKiBgYGBcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNsdXN0ZXIoY29vcmRzLCBvcHQsIGNiID0gbnVsbCkge1xyXG5cclxuICAgIGxldCBkYXRhUG9pbnRzID0gW107XHJcbiAgICBtYXAgPSBtLmdldE1hcCgpO1xyXG5cclxuICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBtaW5ab29tOiAxLCAgICAgLy8gbWluIHpvb21cclxuICAgICAgICBtYXhab29tOiAyNCwgICAgLy8gbWF4IHpvb21cclxuICAgICAgICBub2lzZTogW1wiaHR0cDpzdmcvYmx1ZWRvdC5zdmdcIiwgMTZdLCAgLy8gIGljb24rc2l6ZSBmb3Igbm9pc2UsIGNhbiBiZSBzdmcgb3IgaW1hZ2VcclxuICAgICAgICBjbHVzdGVySWNvbjogXCJodHRwOnN2Zy9jbHVzdGVyLnN2Z1wiLCAgICAvLyAgaWNvbiBmb3IgY2x1c3RlclxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIDc1OiB7IGNvbG9yOiBcIiNGRjY5MDBcIiwgc2l6ZTogMzYgfSxcclxuICAgICAgICAgICAgMzogeyBjb2xvcjogXCIjN0JEMzBBXCIsIHNpemU6IDMyIH0sXHJcbiAgICAgICAgICAgIDIwMDogeyBjb2xvcjogXCIjQjUwMDE1XCIsIHNpemU6IDQ4IH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKG9wdClcclxuICAgICAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuXHJcbiAgICBjb29yZHMuZm9yRWFjaChjb29yZCA9PiB7XHJcbiAgICAgICAgLy8gdXNlIG9wX3dlaWdodCBvZiAxIGZvciBlYWNoIGNvb3JkXHJcbiAgICAgICAgLy8gcHJvdmlkZXMgYWxsIGNvb3JkIGFzIGRhdGFcclxuICAgICAgICBsZXQgZHAgPSBuZXcgSC5jbHVzdGVyaW5nLkRhdGFQb2ludChjb29yZFswXSwgY29vcmRbMV0sIDEsIGNvb3JkKTtcclxuICAgICAgICBkYXRhUG9pbnRzLnB1c2goZHApO1xyXG5cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICAvLyBub2lzZSBpY29uIDogaWYgU1ZHLCBuZWVkcyB0byBmZXRjaCBpdFxyXG4gICAgbGV0IG5vaXNlSWNvbiA9IHNldHRpbmdzLm5vaXNlWzBdO1xyXG4gICAgbGV0IG5vaXNlU2l6ZSA9IHNldHRpbmdzLm5vaXNlWzFdO1xyXG5cclxuICAgIGlmIChub2lzZUljb24uc3Vic3RyKC0zKSA9PSBcInN2Z1wiKSB7XHJcbiAgICAgICAgbm9pc2VJY29uID0gYXdhaXQgZmV0Y2gobm9pc2VJY29uKVxyXG4gICAgICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT0gMjAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW5vaXNlSWNvbikgcmV0dXJuOyAvLyBpZiBubyByZXN1bHQsIGxldCdzIHF1aXRcclxuXHJcbiAgICAvLyB0byBzcGVlZCB1cCwgY3JlYXRlIG9ubHkgb25jZSB0aGUgaWNvbiBmb3Igbm9pc2VcclxuICAgIGNvbnN0IGljb25Ob2lzZSA9IG5ldyBILm1hcC5JY29uKG5vaXNlSWNvbiwgeyBzaXplOiB7IHc6IG5vaXNlU2l6ZSwgaDogbm9pc2VTaXplIH0gfSk7XHJcblxyXG4gICAgLy8gbGV0J3Mgbm93IGZldGNoIGNsdXN0ZXIgaWNvblxyXG4gICAgbGV0IHN2Z0NsdXN0ZXIgPSBhd2FpdCBmZXRjaChzZXR0aW5ncy5jbHVzdGVySWNvbilcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1cyAhPSAyMDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgaWYgKCFzdmdDbHVzdGVyKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcblxyXG4gICAgLy8gdG8gc3BlZWQgZGlzcGxheSBkaXNwbGF5LCB3ZSB3aWxsIGNhY2hlIHRoZSB2YXJpb3VzIGNsdXN0ZXIgaWNvbnNcclxuICAgIC8vIGZyb20gdGhlIGJhc2Ugc3ZnLCB3ZSB3aWxsIGNyZWF0ZSBkaWZmZXJlbnQgaWNvbnMgd2l0aCBkaWZmZXJlbnQgc2l6ZS9jb2xvci90ZXh0XHJcbiAgICBsZXQgY2FjaGVJY29uID0ge307IC8vIGNhY2hlIG9mIGljb25zXHJcblxyXG4gICAgLy8gb3JkZXIgc3R5bGUgYnkgc2l6ZSBkZXNjZW5kaW5nXHJcbiAgICBsZXQgc3R5bGVTaXplID0gT2JqZWN0LmtleXMoc2V0dGluZ3Muc3R5bGUpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIgLSBhOyB9KTtcclxuXHJcbiAgICAvLyB0aGlzIGZ1bmN0aW9uICBjcmV0YWVzIHRoZSBpY29uIGZvciBhIGNsdXN0ZXJcclxuICAgIGZ1bmN0aW9uIGdldENsdXN0ZXJQcmVzZW50YXRpb24oY2x1c3Rlcikge1xyXG5cclxuICAgICAgICAvLyBidWlsZGluZyBkYXRhIG9iamVjdCB3aGljaCB3aWxsIGJlIHJldHVybmVkIHdoZW4gY2xpY2tpbmcgb24gdGhlIGljb25cclxuICAgICAgICB2YXIgZGF0YSA9IHt9O1xyXG4gICAgICAgIGRhdGEuaXNDbHVzdGVyID0gKCkgPT4geyByZXR1cm4gdHJ1ZTsgfTsgIC8vIHNvIHdlIGtub3cgaXQgaXMgYSBjbHVzdGVyXHJcbiAgICAgICAgbGV0IHdlaWdodCA9IGNsdXN0ZXIuZ2V0V2VpZ2h0KCk7XHJcbiAgICAgICAgZGF0YS5nZXRXZWlnaHQgPSAoKSA9PiB7IHJldHVybiB3ZWlnaHQ7IH07IC8vIG51bWJlciBvZiBpbmRpdmlkdWFsIGl0ZW0gY2x1c3RlcmVkIHRvZ2V0aGVyXHJcblxyXG4gICAgICAgIC8vIGxldCdzIGZpbmQgdGhlIHJlbGV2YW50IGNvbG9yIGFuZCBzaXplXHJcbiAgICAgICAgbGV0IGVudHJ5ID0gc3R5bGVTaXplLmZpbmQoZWx0ID0+ICh3ZWlnaHQgPj0gZWx0KSk7XHJcbiAgICAgICAgbGV0IGNvbG9yID0gc2V0dGluZ3Muc3R5bGVbZW50cnldLmNvbG9yO1xyXG4gICAgICAgIGxldCBzaXplID0gc2V0dGluZ3Muc3R5bGVbZW50cnldLnNpemU7XHJcblxyXG4gICAgICAgIC8vIGxldCdzIGNyZWF0ZSBhbmQgY2FjaGUgdGhlIG5lZWRlZCBpY29uc1xyXG4gICAgICAgIGxldCBrZXkgPSBjb2xvciArIFwiLVwiICsgd2VpZ2h0ICsgXCItXCIgKyBzaXplO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FjaGVJY29uW2tleV0gPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICBsZXQgc3ZnID0gc3ZnQ2x1c3Rlci5yZXBsYWNlKFwie3RleHR9XCIsIHdlaWdodCkucmVwbGFjZSgve2NvbG9yfS9nLCBjb2xvcik7XHJcbiAgICAgICAgICAgIGNhY2hlSWNvbltrZXldID0gbmV3IEgubWFwLkljb24oc3ZnLCB7IHNpemU6IHsgdzogc2l6ZSwgaDogc2l6ZSB9LCBhbmNob3I6IHsgdzogc2l6ZSAvIDIsIGg6IHNpemUgLyAyIH0gfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjcmVhdGUgYSBtYXJrZXIgZm9yIHRoZSBDbHVzdGVyXHJcbiAgICAgICAgdmFyIGNsdXN0ZXJNYXJrZXIgPSBuZXcgSC5tYXAuTWFya2VyKGNsdXN0ZXIuZ2V0UG9zaXRpb24oKSwge1xyXG4gICAgICAgICAgICAvLyBVc2UgbWluIHpvb20gZnJvbSBhIG5vaXNlIHBvaW50XHJcbiAgICAgICAgICAgIC8vIHRvIHNob3cgaXQgY29ycmVjdGx5IGF0IGNlcnRhaW4gem9vbSBsZXZlbHM6XHJcbiAgICAgICAgICAgIG1pbjogY2x1c3Rlci5nZXRNaW5ab29tKCksXHJcbiAgICAgICAgICAgIG1heDogY2x1c3Rlci5nZXRNYXhab29tKCksXHJcbiAgICAgICAgICAgIGljb246IGNhY2hlSWNvbltrZXldLFxyXG5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gTGluayBkYXRhIGZyb20gdGhlIGZyb20gdGhlIGNsdXN0ZXIgdG8gdGhlIG1hcmtlcixcclxuICAgICAgICAvLyB0byBtYWtlIGl0IGFjY2Vzc2libGUgb24gY2FsbGJhY2tcclxuICAgICAgICBjbHVzdGVyTWFya2VyLnNldERhdGEoZGF0YSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjbHVzdGVyTWFya2VyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZ1bmN0aW9uIHRvIHJlcHJlc2VudCBhIHNpbmdsZSBpdGVtXHJcbiAgICBmdW5jdGlvbiBnZXROb2lzZVByZXNlbnRhdGlvbihub2lzZVBvaW50KSB7XHJcblxyXG4gICAgICAgIC8vIGRhdGEgdG8gYmUgc2VudCBvbiBjYWxsYmFja1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgICAgIGdldERhdGE6ICgpID0+IHsgcmV0dXJuIG5vaXNlUG9pbnQuZ2V0RGF0YSgpOyB9LFxyXG4gICAgICAgICAgICBpc0NsdXN0ZXI6ICgpID0+IHsgcmV0dXJuIGZhbHNlOyB9LFxyXG4gICAgICAgICAgICBnZXRXZWlnaHQ6ICgpID0+IHsgcmV0dXJuIDE7IH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYSBtYXJrZXIgZm9yIHRoZSBub2lzZVBvaW50XHJcbiAgICAgICAgdmFyIG5vaXNlTWFya2VyID0gbmV3IEgubWFwLk1hcmtlcihub2lzZVBvaW50LmdldFBvc2l0aW9uKCksIHtcclxuICAgICAgICAgICAgLy8gVXNlIG1pbiB6b29tIGZyb20gYSBub2lzZSBwb2ludFxyXG4gICAgICAgICAgICAvLyB0byBzaG93IGl0IGNvcnJlY3RseSBhdCBjZXJ0YWluIHpvb20gbGV2ZWxzOlxyXG4gICAgICAgICAgICBtaW46IG5vaXNlUG9pbnQuZ2V0TWluWm9vbSgpLFxyXG4gICAgICAgICAgICBpY29uOiBpY29uTm9pc2VcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIC8vIExpbmsgYSBkYXRhIGZyb20gdGhlIHBvaW50IHRvIHRoZSBtYXJrZXJcclxuICAgICAgICAvLyB0byBtYWtlIGl0IGFjY2Vzc2libGUgb24gY2FsbGJhY2tcclxuICAgICAgICBub2lzZU1hcmtlci5zZXREYXRhKGRhdGEpO1xyXG5cclxuICAgICAgICByZXR1cm4gbm9pc2VNYXJrZXI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIGNyZWF0ZSBjbHVzdGVyIHByb3ZpZGVyXHJcbiAgICBsZXQgY2x1c3RlcmVkRGF0YVByb3ZpZGVyID0gbmV3IEguY2x1c3RlcmluZy5Qcm92aWRlcihkYXRhUG9pbnRzLCB7XHJcbiAgICAgICAgY2x1c3RlcmluZ09wdGlvbnM6IHtcclxuICAgICAgICAgICAgLy8gTWF4aW11bSByYWRpdXMgb2YgdGhlIG5laWdoYm9yaG9vZFxyXG4gICAgICAgICAgICBlcHM6IDY0LFxyXG4gICAgICAgICAgICAvLyBtaW5pbXVtIHdlaWdodCBvZiBwb2ludHMgcmVxdWlyZWQgdG8gZm9ybSBhIGNsdXN0ZXJcclxuICAgICAgICAgICAgbWluV2VpZ2h0OiBzdHlsZVNpemVbc3R5bGVTaXplLmxlbmd0aCAtIDFdIC8vIG1pbmltdW0gY2x1c3RlcmluZyBpcyBkZWZpbmVkIGJ5IG1pbnNpemUgaW4gU3R5bGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1pbjogc2V0dGluZ3MubWluWm9vbSwgLy8gbWluIHpvb21cclxuICAgICAgICBtYXg6IHNldHRpbmdzLm1heFpvb20sIC8vIG1heCB6b29tXHJcbiAgICAgICAgdGhlbWU6IHsgZ2V0Q2x1c3RlclByZXNlbnRhdGlvbjogZ2V0Q2x1c3RlclByZXNlbnRhdGlvbiwgZ2V0Tm9pc2VQcmVzZW50YXRpb246IGdldE5vaXNlUHJlc2VudGF0aW9uIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIGxheWVyIHRoYXQgaW5jbHVkZXMgdGhlIGRhdGEgcHJvdmlkZXIgYW5kIGl0cyBkYXRhIHBvaW50czpcclxuICAgIGxldCBsYXllciA9IG5ldyBILm1hcC5sYXllci5PYmplY3RMYXllcihjbHVzdGVyZWREYXRhUHJvdmlkZXIpO1xyXG4gICAgLy8gQWRkIHRoZSBsYXllciB0byB0aGUgbWFwOlxyXG4gICAgbWFwLmFkZExheWVyKGxheWVyKTtcclxuXHJcbiAgICAvLyBpZiBhIGNhbGxiYWNrIGlzIGRlZmluZWQsIGFkZCBldmVudCBsaXN0ZW5lclxyXG4gICAgaWYgKGNiKSB7XHJcbiAgICAgICAgY2x1c3RlcmVkRGF0YVByb3ZpZGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0YXBcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIC8vIExvZyBkYXRhIGJvdW5kIHRvIHRoZSBtYXJrZXIgdGhhdCBoYXMgYmVlbiB0YXBwZWQ6XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gZXYudGFyZ2V0LmdldERhdGEoKTtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgbGV0IGlzQ2x1c3RlciA9IGRhdGEuaXNDbHVzdGVyKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNDbHVzdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgd2VpZ3RoID0gZGF0YS5nZXRXZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIGNiKGV2LCBtLmNvb3JkTzJBKGNvb3JkKSwgbnVsbCwgd2VpZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdXNlckRhdGEgPSBkYXRhLmdldERhdGEoKTsgLy8gbGF0LGxuZywgcGF5bG9hZFxyXG4gICAgICAgICAgICAgICAgY2IoZXYsIG0uY29vcmRPMkEoY29vcmQpLCB1c2VyRGF0YVsyXSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGF5ZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhpZGUoKSB7XHJcbiAgICBjbHVzdGVyTGF5ZXIuc2V0TWF4KDApO1xyXG4gICAgY2x1c3RlckxheWVyLnNldE1pbigwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2hvdygpIHtcclxuICAgIGNsdXN0ZXJMYXllci5zZXRNYXgoMjQpO1xyXG4gICAgY2x1c3RlckxheWVyLnNldE1pbigwKTtcclxuXHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGNsdXN0ZXI6IGNsdXN0ZXIsXHJcbiAgICBjbHVzdGVyU2hvdzogc2hvdyxcclxuICAgIGNsdXN0ZXJIaWRlOiBoaWRlXHJcbn07XHJcblxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuLyogZ2xvYmFsIGRvY3VtZW50ICovXHJcblxyXG4vKipcclxuICogQGZpbGUgZ2VuZXJpYyBmdW5jdGlvbiBvZiBoZXJlbWFwXHJcbiAqIEBhdXRob3IgZGV2YmFiXHJcbiAqL1xyXG5cclxuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoXCJzdXBlcmFnZW50XCIpO1xyXG5cclxuLy8gYnkgZGVmYXVsdCwgdW5sZXNzIHNwZWNpZmllZCBmYnkgY2FsbGluZyBjb25maWdcclxuLy8gZW52aXJvbm1lbnQgdXNhYmxlIHdpdGggbm9kZVxyXG5sZXQgQVBQX0lEID0gcHJvY2Vzcy5lbnYuQVBQX0lEO1xyXG5sZXQgQVBQX0NPREUgPSBwcm9jZXNzLmVudi5BUFBfQ09ERTtcclxubGV0IENJVCA9IFwiXCI7IC8vIHByb2R1Y3Rpb24gYnkgZGVmYXVsdFxyXG5sZXQgUFJPVE9DT0wgPSBcImh0dHBzOlwiOyAvLyBieSBkZWZhdWx0XHJcbmxldCBfdXNlSFRUUFMgPSB0cnVlOyAvLyBieSBkZWZhdWx0XHJcbmxldCBfaG9tZSA9IFwiLlwiO1xyXG5cclxuXHJcbi8vIGZpbmQgb3V0IHdoZXJlIHdlIGFyZSBhbmQgcmVsYXRpdmUgcG9zaXRpb24gZm9yIHBuZy9zdmcgZmlsZXNcclxuLy8gcGF5IGF0dGVudGlvbiBpZiBsaWJyYXJ5IGlzIGJ1aWxkIGluIC4vZGlzdFxyXG5pZiAocHJvY2Vzcy5icm93c2VyKSB7XHJcbiAgICBsZXQgX3NjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xyXG4gICAgbGV0IF9maWxlID0gX3NjcmlwdFtfc2NyaXB0Lmxlbmd0aCAtIDFdLnNyYztcclxuICAgIGxldCBfcGF0aCA9IF9maWxlLnN1YnN0cmluZygwLCBfZmlsZS5sYXN0SW5kZXhPZihcIi9cIikpO1xyXG5cclxuICAgIF9ob21lID0gX3BhdGggKyBcIi8uLi9cIjsgLy8gYSBiaXQgZGlydHkgYnV0IC4uLlxyXG59XHJcblxyXG4vKipcclxuICogVG8gY29uZmlndXJlIGFwcF9pZCwgYXBwX2NvZGUgYW5kIG9wdGlvbmFsbHkgdXNlIENJVCBhbmQgaHR0cFxyXG4gKiBAYWxpYXMgaG06Y29uZmlnXHJcbiAqXHJcbiAqIEBwYXJhbSBvcHQge09iamVjdH0gIC0gYG9wdGAgd2l0aCBwYXJhbWV0ZXJzLlxyXG4gKiBAcGFyYW0gW29wdC5hcHBfaWRdIHtzdHJpbmd9IC0gdGhlIGFwcF9pZCBmcm9tIGRldmVsb3Blci5oZXJlLmNvbVxyXG4gKiBAcGFyYW0gW29wdC5hcHBfY29kZV0ge3N0cmluZ30gLSB0aGUgYXBwX2NvZGUgZnJvbSBkZXZlbG9wZXIuaGVyZS5jb21cclxuICogQHBhcmFtIFtvcHQudXNlQ0lUPWZhbHNlXSB7Ym9vbGVhbn0gLSB0cnVlIHRvIHVzZSBDSVQgZW52aXJvbm1lbnQuIFxyXG4gKiBAcGFyYW0gW29wdC51c2VIVFRQPWZhbHNlXSB7c3RyaW5nfSAtIHRydWUgdG8gdXNlIEhUVFAuIFxyXG4gKiBAcGFyYW0gW29wdC51c2VIVFRQUz10cnVlXSB7c3RyaW5nfSAtIHRydWUgdG8gdXNlIEhUVFBTLiBcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogIGhtLmNvbmZpZyh7XHJcbiAqICAgICAgYXBwX2lkOiBcIllPVVIgQVBQX0lEXCIsXHJcbiAqICAgICAgYXBwX2NvZGU6IFwiWU9VUiBBUFBfQ09ERVwiLFxyXG4qICAgfSk7XHJcbiogIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gY29uZmlnKG9wdCkge1xyXG4gICAgaWYgKG9wdC5hcHBfaWQpIEFQUF9JRCA9IG9wdC5hcHBfaWQ7XHJcbiAgICBpZiAob3B0LmFwcF9jb2RlKSBBUFBfQ09ERSA9IG9wdC5hcHBfY29kZTtcclxuICAgIGlmIChvcHQudXNlQ0lUKSBDSVQgPSBcIi5jaXRcIjtcclxuICAgIGlmIChvcHQudXNlSFRUUCkge1xyXG4gICAgICAgIFBST1RPQ09MID0gXCJodHRwOlwiO1xyXG4gICAgICAgIF91c2VIVFRQUyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdC51c2VIVFRQUykge1xyXG4gICAgICAgIFBST1RPQ09MID0gXCJodHRwczpcIjtcclxuICAgICAgICBfdXNlSFRUUFMgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogcmV0dXJuIFVSTCBvZiBtb2R1bGUgaG9tZSBkaXJlY3RvcnlcclxuICogQGlnbm9yZVxyXG4gKiAgQGFsaWFzIGhtOmdldEhvbWVcclxuICogQHJldHVybiB7c3RyaW5nfSB1cmwgb2YgaG9tZSBkaXJlY3RvcnkgaW5jbHVkaW5nIGh0dHAgb3IgaHR0cHNcclxuICovXHJcbmZ1bmN0aW9uIGdldEhvbWUoKSB7XHJcbiAgICByZXR1cm4gX2hvbWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm5zIGFwcF9pZFxyXG4gKiBAaWdub3JlXHJcbiAqICBAYWxpYXMgaG06Z2V0QXBwSWRcclxuICogQHJldHVybiB7c3RyaW5nfSBhcHBfaWRcclxuKi9cclxuZnVuY3Rpb24gZ2V0QXBwSWQoKSB7XHJcbiAgICByZXR1cm4gQVBQX0lEO1xyXG59XHJcblxyXG4vKipcclxuICogcmV0dXJuIGFwcF9jb2RlXHJcbiAqICBAaWdub3JlXHJcbiAqICBAYWxpYXMgaG06Z2V0SG9tZVxyXG4gKiAgQGFsaWFzIGhtOmdldEFwcENvZGVcclxuICAqIEByZXR1cm4ge3N0cmluZ30gYXBwX2NvZGVcclxuKi9cclxuZnVuY3Rpb24gZ2V0QXBwQ29kZSgpIHtcclxuICAgIHJldHVybiBBUFBfQ09ERTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHJldHVybiB0cnVlIGlmIHVzaW5nIENJVFxyXG4gKiBAaWdub3JlXHJcbiAqIEBhbGlhcyBobTpnZXRDSVRcclxuICogQHJldHVybiB7Ym9vb2xlYW59IHRydWUgaWYgdXNpbmcgQ0lUXHJcbiovXHJcbmZ1bmN0aW9uIGdldENJVCgpIHtcclxuICAgIHJldHVybiBDSVQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gcHJvdG9jb2wgdXNlZCwgaHR0cDovLyBvciBodHRwczovL1xyXG4gKiBAaWdub3JlXHJcbiAqIEBhbGlhcyBobTpnZXRQcm90b2NvbFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gcHJvdG9jb2xcclxuKi9cclxuZnVuY3Rpb24gZ2V0UHJvdG9jb2woKSB7XHJcbiAgICByZXR1cm4gUFJPVE9DT0w7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gdHJ1ZSBpcyBodHRwcyBpcyB1c2VkXHJcbiAqIEBpZ25vcmVcclxuICogIEBhbGlhcyBobTp1c2VIVFRQU1xyXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIHRydWUgaWYgaHR0cHMgaXMgdXNlZFxyXG4qL1xyXG5mdW5jdGlvbiB1c2VIVFRQUygpIHtcclxuICAgIHJldHVybiBfdXNlSFRUUFM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBhZGQgY3JlZGVudGlhbHMgdG8gb2JqZWN0IHByb3ZpZGVkXHJcbiAgKiBAaWdub3JlXHJcbiAqICBAYWxpYXMgaG06YWRkQ3JlZGVudGlhbHNcclxuICogQHBhcmFtICB7Li4ub2JqZWN0c30gbGlzdCBvZiBgb2JqZWN0c2AgXHJcbiAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0IHdpdGggYWxsIGlucHV0IG9iamVjdGNvbmNhdGVuYXRlZCwgYW5kIGFwcF9pZC9hcHBfY29kZSBpbnNlcnRlZFxyXG4gKi9cclxuZnVuY3Rpb24gYWRkQ3JlZGVudGlhbHMoLi4ub2JqKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgYXBwX2lkOiBBUFBfSUQsXHJcbiAgICAgICAgYXBwX2NvZGU6IEFQUF9DT0RFXHJcbiAgICB9LCAuLi5vYmopO1xyXG59XHJcblxyXG4vKipcclxuICogYnVpbGQgSEVSRSBSRVNUIGZ1bGwgdXJsLCB0YWtpbmcgaW4gYWNjb3VudCBwcm90b2NvbCBhbmQgY2l0LiBmb3IgaW5zdGFuY2UgIGNtLmJ1aWxkVXJsKFwiZ2VvY29kZXJcIiwgXCJhcGkuaGVyZS5jb20vNi4yL2dlb2NvZGUuanNvblwiXHJcbiAqIEBpZ25vcmVcclxuICogQGFsaWFzIGhtOmJ1aWxkVXJsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIC0gYmFzZSBuYW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIGVuZCBwb2ludFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGZ1bGwgdXJsXHJcbiAqL1xyXG5mdW5jdGlvbiBidWlsZFVybChiYXNlLCBlbmRwb2ludCkge1xyXG4gICAgcmV0dXJuIFBST1RPQ09MICsgXCIvL1wiICsgYmFzZSArIENJVCArIFwiLlwiICsgZW5kcG9pbnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBkb2VzIGdldC9wb3N0IHJlcXVlc3QgdG8gSEVSRSBSRVNEVCBiYWNrZW5kIGFuZCBtYW5hZ2UgbWFpbiBlcnJvcnNcclxuICogQGlnbm9yZVxyXG4gKiBAYWxpYXMgaG06aGVyZVJlc3RcclxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAgLSB1cmwgdG8gY2FsbCAsIGZvciBpbnN0YW5jZSBmcm9tIGJ1aWxkVXJsXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyAtIHNldHRpbmdzIHRvIGFkZCBpbiByZXF1ZXN0XHJcbiAqIEBwYXJhbSAge3N0cmluZ30gbW9kZT1nZXQgLSBtb2RlIFwiZ2V0XCIgb3IgXCJwb3N0XCJcclxuICogQHJldHVybiB7cHJvbWlzZX0gLSBwcm9taXNlIHRvIHJlc29sdmUvcmVqZWN0XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBoZXJlUmVzdCh1cmwsIHNldHRpbmdzLCBtb2RlID0gXCJnZXRcIiwgbmVlZHJlc3AgPSBcInRydWVcIikge1xyXG5cclxuICAgIGxldCBwID0gcmVxdWVzdC5nZXQodXJsKTtcclxuICAgIGlmIChtb2RlID09IFwicG9zdFwiKVxyXG4gICAgICAgIHAgPSByZXF1ZXN0LnBvc3QodXJsKTtcclxuXHJcbiAgICByZXR1cm4gcFxyXG4gICAgICAgIC5xdWVyeShzZXR0aW5ncylcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICAvLyByZXMuYm9keSwgcmVzLmhlYWRlcnMsIHJlcy5zdGF0dXNcclxuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT0gXCIyMDBcIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJFcnJvciBcIiArIHJlcy5zdGF0dXMgKyBcIjpcIiArIHJlcy5ib2R5KTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChuZWVkcmVzcCAmJiAhcmVzLmJvZHkuUmVzcG9uc2UgJiYgIXJlcy5ib2R5LnJlc3BvbnNlKSB7IC8vIG9uZSBvZiB0aGUgdHdvIHNob3VsZCBiZSBpbiB0aGUgYW5zd2VyXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcy5ib2R5KTtcclxuICAgICAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiUXVlcnkgZXJyb3I6XCIgKyByZXMuYm9keSk7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzLmJvZHkucmVzcG9uc2UgJiYgcmVzLmJvZHkucmVzcG9uc2UudHlwZSA9PSBcIkFwcGxpY2F0aW9uRXJyb3JcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMuYm9keSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIkVycm9yXCIgKyByZXMuYm9keS5yZXNwb25zZS5kZXRhaWxzKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY29uZmlnOiBjb25maWcsXHJcbiAgICBidWlsZFVybDogYnVpbGRVcmwsXHJcbiAgICBnZXRBcHBJZDogZ2V0QXBwSWQsXHJcbiAgICBnZXRBcHBDb2RlOiBnZXRBcHBDb2RlLFxyXG4gICAgZ2V0Q0lUOiBnZXRDSVQsXHJcbiAgICBnZXRQcm90b2NvbDogZ2V0UHJvdG9jb2wsXHJcbiAgICBnZXRIb21lOiBnZXRIb21lLFxyXG4gICAgdXNlSFRUUFM6IHVzZUhUVFBTLFxyXG4gICAgYWRkQ3JlZGVudGlhbHM6IGFkZENyZWRlbnRpYWxzLFxyXG4gICAgaGVyZVJlc3Q6IGhlcmVSZXN0XHJcbn07IiwiLyoqXHJcbiAqIEBmaWxlIEdlb2NvZGluZyBmdW5jdGlvbnMgOiBhZGRyZXNzZXMgPC0tPiBbbGF0LGxuZ11cclxuICogQGF1dGhvciBEZXZiYWIgXHJcbiAqL1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmNvbnN0IGNtID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIGdlb2NvZGUgYW4gYWRkcmVzc1xyXG4gKiBAYWxpYXMgaG06Z2VvY29kZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIGFkZHJlc3MgYXMgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IHJldHVybnMgIHtjb29yZCxib2R5fS4gY29vcmQgaXMgZ2VvY29kZSBhcyBcXFtsYXQsbG5nXFxdLiBib2R5IGlzIGZ1bGwganNvbiBhbnN3ZXJcclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IHJlcyA9IGF3YWl0IGhtLmdlb2NvZGUoXCJhdmVudWUgZGVzIGNoYXBzIGVseXNlZXMsIHBhcmlzXCIpO1xyXG4gKiBjb25zb2xlLmxvZyAocmVzLmNvb3JkKTtcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW9jb2RlKGFkZHJlc3MpIHtcclxuXHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IGNtLmFkZENyZWRlbnRpYWxzKHtcclxuICAgICAgICBzZWFyY2hUZXh0OiBhZGRyZXNzXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1cmwgPSBjbS5idWlsZFVybChcImdlb2NvZGVyXCIsIFwiYXBpLmhlcmUuY29tLzYuMi9nZW9jb2RlLmpzb25cIik7XHJcbiAgICByZXR1cm4gY20uaGVyZVJlc3QodXJsLCBzZXR0aW5ncylcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlcy5ib2R5LlJlc3BvbnNlLlZpZXcubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiR2VvY29kZSBBZGRyZXNzIG5vdCBmb3VuZDogXCIgKyBhZGRyZXNzKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHJlcy5ib2R5LlJlc3BvbnNlLlZpZXdbMF0uUmVzdWx0WzBdLkxvY2F0aW9uO1xyXG4gICAgICAgICAgICB2YXIgY29vcmQgPSBbbG9jYXRpb24uTmF2aWdhdGlvblBvc2l0aW9uWzBdLkxhdGl0dWRlLCBsb2NhdGlvbi5OYXZpZ2F0aW9uUG9zaXRpb25bMF0uTG9uZ2l0dWRlXTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgY29vcmQ6IGNvb3JkLCBib2R5OiByZXMuYm9keSB9O1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIHJldmVyc2UgZ2VvY29kZSBhIGNvb3JkaW5hdGVcclxuICogQGFsaWFzIGhtOnJldmVyc2VHZW9jb2RlXHJcbiAqIEBwYXJhbSB7Q29vcmR9IGNvb3JkIC0gY29vcmQgXFxbbGF0LGxuZ1xcXSB0byByZXZlcnNlIGdlb2NvZGVcclxuICogQHJldHVybnMge29iamVjdH0gcmV0dXJucyB7IGxvY2F0aW9uOm9iamVjdCwgYWRkcmVzczpvYmplY3QsIGJvZHk6b2JqZWN0fS4gXHJcbiAqL1xyXG5mdW5jdGlvbiByZXZlcnNlR2VvY29kZShjb29yZCkge1xyXG5cclxuICAgIGNvbnN0IHNldHRpbmdzID0gY20uYWRkQ3JlZGVudGlhbHMoe1xyXG4gICAgICAgIG1vZGU6IFwicmV0cmlldmVBZGRyZXNzZXNcIixcclxuICAgICAgICBwcm94OiBjb29yZFswXSArIFwiLFwiICsgY29vcmRbMV1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwicmV2ZXJzZS5nZW9jb2RlclwiLCBcImFwaS5oZXJlLmNvbS82LjIvcmV2ZXJzZWdlb2NvZGUuanNvblwiKTtcclxuXHJcbiAgICByZXR1cm4gY20uaGVyZVJlc3QodXJsLCBzZXR0aW5ncylcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICAvLyByZXMuYm9keSwgcmVzLmhlYWRlcnMsIHJlcy5zdGF0dXNcclxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmJvZHkuUmVzcG9uc2UuVmlld1swXS5SZXN1bHRbMF0uTG9jYXRpb247XHJcbiAgICAgICAgICAgIHJldHVybiAoeyBsb2NhdGlvbjogbG9jYXRpb24sIGFkZHJlc3M6IGxvY2F0aW9uLkFkZHJlc3MsIGJvZHk6IHJlcy5ib2R5IH0pO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBnZW9jb2RlOiBnZW9jb2RlLFxyXG4gICAgcmV2ZXJzZUdlb2NvZGU6IHJldmVyc2VHZW9jb2RlXHJcbn07XHJcblxyXG4iLCIvKiBnbG9iYWwgSCwgZmV0Y2gsIGRvY3VtZW50LCBuYXZpZ2F0b3IsIG1hcHNqcywgd2luZG93IEFQUF9JRF9KQVBBTixBUFBfQ09ERV9KQVBBTixBUFBfSURfS09SRUEsQVBQX0NPREVfS09SRUEqL1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIG1hbmFnZXMgbWFwIGRpc3BsYXkgb24gYSB3ZWIgY2FudmFzXHJcbiAqIEBhdXRob3IgZGV2YmFiXHJcbiAqL1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmNvbnN0IGNtID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xyXG5cclxubGV0IF9wbGF0Zm9ybSA9IG51bGw7XHJcbmxldCBfcHJvdmlkZXIgPSBudWxsO1xyXG5sZXQgX2RlZmF1bHRMYXllcnMgPSBudWxsO1xyXG5sZXQgX3VpID0gbnVsbDtcclxubGV0IF9tYXAgPSBudWxsO1xyXG5sZXQgX2JlaGF2aW9yID0gbnVsbDtcclxubGV0IGdyb3VwID0gbnVsbDtcclxubGV0IF9sYXllcnMgPSBbXTsgLy8gbGlzdCBhbGwgbGF5ZXJzXHJcbmxldCBfa2V5ID0ge307ICAgICAvLyBrZXlzICBcclxubGV0IF9idWJibGVNYXJrZXIgPSBudWxsOyAgICAgLy8gYnViYmxlIGRlIG1hbXJrZXJcclxubGV0IF9zY2hlbWUgPSBcIm5vcm1hbC5kYXkuZ3JleVwiO1xyXG5sZXQgX2xvY2F0ZU1lID0gbnVsbDsgICAgICAgICAvLyBpZCB3aGVuIGxvY2F0ZSBpcyBhY3RpdmVcclxubGV0IF9odG1sSXRlbSA9IG51bGw7ICAgICAgICAgICAgIC8vdGhlIGh0bWwgaXRlbSBvbiB3aGljaCB0byBwdXQgdGhlIG1hcFxyXG5cclxuXHJcbmZ1bmN0aW9uIGNvb3JkTzJBKG9iaikge1xyXG4gICAgcmV0dXJuIFtvYmoubGF0LCBvYmoubG5nXTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29vcmRBMk8oYXJyKSB7XHJcbiAgICByZXR1cm4geyBsYXQ6IGFyclswXSwgbG5nOiBhcnJbMV0gfTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgYSBtYXAgYXJlYSB3aXRoaW4gdGhlIHNwZWNpZmllZCBpdGVtXHJcbiAgKiBAYWxpYXMgaG06bWFwXHJcblxyXG4gKiBAcGFyYW0gaHRtbEl0ZW0ge3N0cmluZ30gIC0gaWRlbnRpZmllciBvZiBodG1sIGRpdiBpdGVtIG9uIHdoaWNoIHRvIGluc2VydCBtYXBcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSAgLSBvcHRpb25zXHJcbiAqIEBwYXJhbSBbb3B0Lnpvb209MTBdIHtudW1iZXJ9ICAtIHpvb20gZmFjdG9yXHJcbiAqIEBwYXJhbSBbb3B0LmNlbnRlcj1bNDguODYsIDIuM11dIHtDb29yZH0gIC0gQ29vcmQgb2YgdGhlIGNlbnRlclxyXG4gKiBAcGFyYW0gW29wdC5zY2hlbWU9bm9ybWFsLmRheS5ncmV5XSB7c3RyaW5nfSAgLSBhbnkgc2NoZW1lIGRlZmluZWQgYnkgSEVSRSwgcGx1cyBcImphcGFuXCIsIFwia29yZWFcIiwgXCJibGFja1wiLCBcIndoaXRlXCIsIFwidHJhbnNwYXJlbnRcIi4gRm9yIGphcGFuL2tvcmVhLCBvbmUgbmVlZHMgc3BlY2lhbCBjcmVkZW50aWFscyBhcyBBUFBfW0lEfENPREVdX0pBUEFOIEFQUF9bSUR8Q09ERV1fS09SRUFcclxuICogQHBhcmFtIFtvcHQuY2xpY2s9bnVsbF0ge2Z1bmN0aW9uKCl9ICAtIGNhbGxiYWNrIG9uIG1vdXNlIGNsaWNrOiBjYWxsYmFjayhjb29yZCxidXR0b24sa2V5KVxyXG4gKiBAcGFyYW0gW29wdC5kYkNsaWNrPW51bGxdIHtmdW5jdGlvbigpfSAgLSBjYWxsYmFjayBvbiBtb3VzZSBkb3VibGUgY2xpY2s6IGNhbGxiYWNrKGNvb3JkLGJ1dHRvbixrZXkpXHJcbiAqIEBwYXJhbSBbb3B0LmNsaWNrTGVmdD1udWxsXSB7ZnVuY3Rpb259ICAtIGNhbGxiYWNrIG9uIG1vdXNlIGNsaWNrIGxlZnQ6IGNhbGxiYWNrKGNvb3JkLGJ1dHRvbixrZXkpXHJcbiAqIEBwYXJhbSBbb3B0LmNsaWNrUmlnaHQ9bnVsbF0ge2Z1bmN0aW9uKCl9ICAtIGNhbGxiYWNrIG9uIG1vdXNlIGNsaWNrIHJpZ2h0LjogY2FsbGJhY2soY29vcmQsYnV0dG9uLGtleSlcclxuICogQHBhcmFtIFtvcHQua2V5RG93bj1udWxsXSB7ZnVuY3Rpb259ICAtIGNhbGxiYWNrIG9uIGtleSBkb3duIDogY2FsbGJhY2soa2V5KVxyXG4gKiBAcGFyYW0gW29wdC52aWV3Q2hhbmdlPW51bGxdIHtmdW5jdGlvbn0gIC0gY2FsbGJhY2sgaWYgbWFwIGlzIHBhbm5lZCBvciB6b29tZWQgOiBjYWxsYmFjayh6b29tLGNvb3JkQ2VudGVyKVxyXG4gKiBAcGFyYW0gW29wdC5sb2FkVGlsZT1udWxsXSB7ZnVuY3Rpb259ICAtIGNhbGxiYWNrIHdoZW4gYSB0aWxlIGlzIGxvYWRlZCA6IGNhbGxiYWNrKHoseCx5LHVybClcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogY29uc3QgaG0gPSB3aW5kb3cuaGVyZW1hcDtcclxuICogXHJcbiAqIGhtLmNvbmZpZyh7XHJcbiAqICAgIGFwcF9pZDogXCJZT1VSIEFQUF9JRFwiLFxyXG4gKiAgICBhcHBfY29kZTogXCJZT1VSIEFQUF9DT0RFXCIsXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBobS5tYXAoXCJtYXBcIiwge1xyXG4gKiAgICB6b29tOjUsXHJcbiAqICAgIGNlbnRlcjogWzQ4LjgsMi4zXSxcclxuICogICAgY2xpY2s6IGZ1bmN0aW9uKGNvb3JkLGJ1dHRvbixrZXkpIHtjb25zb2xlLmxvZyhcImNsaWNrZWQgb25cIixjb29yZCxcIndpdGggYnV0dG9uXCIsYnV0dG9uKTt9XHJcbiAqIH0pO1xyXG4qICBgYGBcclxuKi9cclxuZnVuY3Rpb24gbWFwKGh0bWxJdGVtLCBvcHQpIHtcclxuXHJcbiAgICBfaHRtbEl0ZW0gPSBodG1sSXRlbTtcclxuXHJcbiAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgem9vbTogMTAsXHJcbiAgICAgICAgY2VudGVyOiBbNDguODYsIDIuM10sXHJcbiAgICAgICAgY2xpY2tMZWZ0OiBudWxsLFxyXG4gICAgICAgIGNsaWNrUmlnaHQ6IG51bGwsXHJcbiAgICAgICAga2V5RG93bjogbnVsbCwgIC8vIGtleWJvYXJkIGV2ZW50XHJcbiAgICAgICAgY2xpY2s6IG51bGwsXHJcbiAgICAgICAgZGJDbGljazogbnVsbCxcclxuICAgICAgICB2aWV3Q2hhbmdlOiBudWxsLCAvLyAoem9vbSxjb29yZClcclxuICAgICAgICBsb2FkVGlsZTogbnVsbCAvLyBxdWFuZCB1bmUgdGlsZSBlc3QgYWZmaWNow6llXHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBtcHMgPSAxO1xyXG5cclxuICAgIGxldCBhcHBfaWQgPSBjbS5nZXRBcHBJZCgpO1xyXG4gICAgbGV0IGFwcF9jb2RlID0gY20uZ2V0QXBwQ29kZSgpO1xyXG5cclxuICAgIGlmICghYXBwX2lkIHx8ICFhcHBfY29kZSkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiYXBwX2lkL2FwcF9jb2RlIG5vdCBpbml0aWFsaXNlZFwiKTtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sSXRlbSkuaW5uZXJIVE1MID0gXCJhcHBfaWQvYXBwX2NvZGUgbm90IGluaXRpYWxpc2VkXCI7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIF9wbGF0Zm9ybSA9IG5ldyBILnNlcnZpY2UuUGxhdGZvcm0oe1xyXG4gICAgICAgIGFwcF9pZDogYXBwX2lkLFxyXG4gICAgICAgIGFwcF9jb2RlOiBhcHBfY29kZSxcclxuICAgICAgICB1c2VDSVQ6IGNtLmdldENJVCgpLFxyXG4gICAgICAgIHVzZUhUVFBTOiBjbS51c2VIVFRQUygpXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG4gICAgaWYgKHNldHRpbmdzLnNjaGVtZSkgX3NjaGVtZSA9IHNldHRpbmdzLnNjaGVtZTsgLy8gc3RvcmUgc2NoZW1lIGlmIGRlZmluZWRcclxuXHJcbiAgICBfZGVmYXVsdExheWVycyA9IF9wbGF0Zm9ybS5jcmVhdGVEZWZhdWx0TGF5ZXJzKCk7XHJcblxyXG4gICAgLy8gaHR0cDovL2hlcmVtYXBzLmdpdGh1Yi5pby9leGFtcGxlcy9leHBsb3Jlci5odG1sI21hcC10aWxlc19fYmFzZS1tYXAtc3R5bGVzLWFuZC1tb2Rlc1xyXG4gICAgX3Byb3ZpZGVyID0gbmV3IEgubWFwLnByb3ZpZGVyLkltYWdlVGlsZVByb3ZpZGVyKHtcclxuICAgICAgICBsYWJlbDogXCJCYXNlIFByb3ZpZGVyXCIsXHJcbiAgICAgICAgZGVzY3I6IFwiXCIsXHJcbiAgICAgICAgbWluOiAwLFxyXG4gICAgICAgIG1heDogMjAsXHJcbiAgICAgICAgY3Jvc3NPcmlnaW46IFwiYW5vbnltb3VzXCIsXHJcbiAgICAgICAgZ2V0VVJMOiBmdW5jdGlvbiAoY29sLCByb3csIGxldmVsKSB7XHJcbiAgICAgICAgICAgIG1wcysrOyBpZiAobXBzID4gNCkgbXBzID0gMTtcclxuICAgICAgICAgICAgbGV0IHVybCA9IFtjbS5nZXRQcm90b2NvbCgpLCBcIi8vXCIsIG1wcywgXCIuYmFzZS5tYXBzXCIgKyBjbS5nZXRDSVQoKSArIFwiLmFwaS5oZXJlLmNvbS9tYXB0aWxlL1wiLCBcIjIuMVwiLFxyXG4gICAgICAgICAgICAgICAgXCIvXCIsIFwibWFwdGlsZVwiLCBcIi9cIiwgXCJuZXdlc3RcIiwgXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBfc2NoZW1lLCBcIi9cIiwgbGV2ZWwsIFwiL1wiLCBjb2wsIFwiL1wiLCByb3csIFwiL1wiLCBcIjI1NlwiLFxyXG4gICAgICAgICAgICAgICAgXCIvXCIsIFwicG5nXCIsIFwiP2xnPVwiLCBcIkZSRVwiLFxyXG4gICAgICAgICAgICAgICAgXCImYXBwX2NvZGU9XCIsIGFwcF9jb2RlLCBcIiZhcHBfaWQ9XCIsXHJcbiAgICAgICAgICAgICAgICBhcHBfaWRdLmpvaW4oXCJcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3NjaGVtZSA9PSBcImphcGFuXCIpXHJcbiAgICAgICAgICAgICAgICB1cmwgPSBbY20uZ2V0UHJvdG9jb2woKSwgXCIvL1wiLCBcIm0ubGJzXCIgKyBjbS5nZXRDSVQoKSArIFwiLmFwaS5oZXJlbWFwcy5qcC92MS9tYXA/YXBwX2lkPVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIEFQUF9JRF9KQVBBTixcclxuICAgICAgICAgICAgICAgICAgICBcIiZhcHBfY29kZT1cIixcclxuICAgICAgICAgICAgICAgICAgICBBUFBfQ09ERV9KQVBBTixcclxuICAgICAgICAgICAgICAgICAgICBcIiZ0aWxlbWF0cml4PUVQU0c6OTAwOTEzOlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiJnRpbGVjb2w9XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiJnRpbGVyb3c9XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcm93XS5qb2luKFwiXCIpO1xyXG5cclxuICAgICAgICAgICAgZWxzZSBpZiAoX3NjaGVtZSA9PSBcImtvcmVhXCIpXHJcbiAgICAgICAgICAgICAgICB1cmwgPSBbY20uZ2V0UHJvdG9jb2woKSwgXCIvL1wiLCBcIjMuYmFzZS5tYXBzXCIgKyBjbS5nZXRDSVQoKSArIFwiLmFwaS5oZXJlbWFwcy5rci9tYXB0aWxlLzIuMS9tYXB0aWxlLzM0NDM5MzQ4YzMvbm9ybWFsLmRheS9cIixcclxuICAgICAgICAgICAgICAgICAgICBcIi9cIiwgbGV2ZWwsIFwiL1wiLCBjb2wsIFwiL1wiLCByb3csIFwiL1wiLCBcIjI1NlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiL1wiLCBcInBuZ1wiLCBcIj9sZz1cIiwgXCJGUkVcIixcclxuICAgICAgICAgICAgICAgICAgICBcIiZhcHBfY29kZT1cIiwgQVBQX0NPREVfS09SRUEsIFwiJmFwcF9pZD1cIixcclxuICAgICAgICAgICAgICAgICAgICBBUFBfSURfS09SRUFdLmpvaW4oXCJcIik7XHJcblxyXG4gICAgICAgICAgICBlbHNlIGlmIChfc2NoZW1lID09IFwiYmxhY2tcIilcclxuICAgICAgICAgICAgICAgIHVybCA9IGNtLmdldEhvbWUoKSArIFwicG5nL2JsYWNrLnBuZ1wiO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChfc2NoZW1lID09IFwid2hpdGVcIilcclxuICAgICAgICAgICAgICAgIHVybCA9IGNtLmdldEhvbWUoKSArIFwicG5nL3doaXRlLnBuZ1wiO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChfc2NoZW1lID09IFwidHJhbnNwYXJlbnRcIilcclxuICAgICAgICAgICAgICAgIHVybCA9IGNtLmdldEhvbWUoKSArIFwicG5nL3RyYW5zcGFyZW50LnBuZ1wiO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5sb2FkVGlsZSlcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmxvYWRUaWxlKGxldmVsLCBjb2wsIHJvdywgdXJsKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgX19sYXllciA9IG5ldyBILm1hcC5sYXllci5UaWxlTGF5ZXIoX3Byb3ZpZGVyKTtcclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKFwibm9ybWFsIG1hcFwiKTtcclxuICAgIC8vU3RlcCAyOiBpbml0aWFsaXplIGEgSEVSRU1hcCBcclxuICAgIF9tYXAgPSBuZXcgSC5NYXAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaHRtbEl0ZW0pLFxyXG4gICAgICAgIF9fbGF5ZXIsIHtcclxuICAgICAgICAgICAgY2VudGVyOiBjb29yZEEyTyhzZXR0aW5ncy5jZW50ZXIpLFxyXG4gICAgICAgICAgICB6b29tOiBzZXR0aW5ncy56b29tXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgX2JlaGF2aW9yID0gbmV3IEgubWFwZXZlbnRzLkJlaGF2aW9yKG5ldyBILm1hcGV2ZW50cy5NYXBFdmVudHMoX21hcCkpO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBVSSBjb21wb25lbnRzXHJcbiAgICBfdWkgPSBILnVpLlVJLmNyZWF0ZURlZmF1bHQoX21hcCwgX2RlZmF1bHRMYXllcnMpO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBkZWZhdWx0IGxheWVyXHJcbiAgICBsYXllckNyZWF0ZShcImRlZmF1bHRcIik7XHJcblxyXG4gICAgLy8gaWYgY2FsbGJhY2sgb24gem9vbSBDaGFuZ2VcclxuICAgIGlmIChzZXR0aW5ncy52aWV3Q2hhbmdlKSB7XHJcbiAgICAgICAgX21hcC5hZGRFdmVudExpc3RlbmVyKFwibWFwdmlld2NoYW5nZWVuZFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBib3VuZCA9IF9tYXAuZ2V0Vmlld0JvdW5kcygpO1xyXG4gICAgICAgICAgICBsZXQgbGF0ID0gKGJvdW5kLmthICsgYm91bmQuamEpIC8gMjtcclxuICAgICAgICAgICAgbGV0IGxuZyA9IChib3VuZC5nYSArIGJvdW5kLmhhKSAvIDI7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwidmlld0NoYW5nZSBjZW50ZXIgXCIgKyBsYXQgKyBcIiBcIiArIGxuZyk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnZpZXdDaGFuZ2UoX21hcC5nZXRab29tKCksIFtsYXQsIGxuZ10pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKiAgICAgICAgICAgdG8gaGFuZGxlIGtleWJvYXJkIHdoaWxlIG1vdXNlIGluIG1hcCAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBsZXQga3VwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9rZXkuY3RybCA9IGZhbHNlO1xyXG4gICAgICAgIF9rZXkuc2hpZnQgPSBmYWxzZTtcclxuICAgICAgICBfa2V5LmFsdCA9IGZhbHNlO1xyXG4gICAgICAgIF9rZXkua2V5ID0gXCJcIjtcclxuICAgIH07XHJcblxyXG4gICAgbGV0IGtkb3duID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBfa2V5LmN0cmwgPSAoKGUua2V5ID09IFwiQ29udHJvbFwiKSB8fCAoZS5rZXlJZGVudGlmaWVyID09IFwiQ29udHJvbFwiKSB8fCAoZS5jdHJsS2V5ID09IHRydWUpKTtcclxuICAgICAgICBfa2V5LnNoaWZ0ID0gKChlLmtleSA9PSBcIlNoaWZ0XCIpIHx8IChlLmtleUlkZW50aWZpZXIgPT0gXCJTaGlmdFwiKSB8fCAoZS5zaGlmdEtleSA9PSB0cnVlKSk7XHJcbiAgICAgICAgX2tleS5hbHQgPSAoKGUua2V5ID09IFwiQWx0XCIpIHx8IChlLmtleUlkZW50aWZpZXIgPT0gXCJBbHRcIikgfHwgKGUuc2hpZnRLZXkgPT0gdHJ1ZSkpO1xyXG4gICAgICAgIF9rZXkua2V5ID0gZS5rZXk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmtleURvd24pIHNldHRpbmdzLmtleURvd24oX2tleSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwibWFwIG1vdXNlIGVudGVyXCIpO1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtkb3duKTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga3VwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIm1hcCBwb2ludGVyIGVudGVyXCIpO1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtkb3duKTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga3VwKTtcclxuICAgIH0pO1xyXG4gICAgX21hcC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJtYXAgbW91c2UgbGVhdmVcIik7XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2Rvd24pO1xyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBrdXApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqICAgICAgICAgICB0byBoYW5kbGUgZG91YmxlIGNsaWNrICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmx0YXBcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSC5tYXAuTWFya2VyKSByZXR1cm47IC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIGNsaWNrIG9uIG1hcmtlclxyXG5cclxuICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICBsZXQgYnV0dG9uID0gZXYuY3VycmVudFBvaW50ZXIuYnV0dG9uO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kYkNsaWNrICE9IFwiXCIpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChidXR0b24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogc2V0dGluZ3MuZGJDbGljayhjb29yZE8yQShjb29yZCksIFwibGVmdFwiLCBfa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjogc2V0dGluZ3MuZGJDbGljayhjb29yZE8yQShjb29yZCksIFwicmlnaHRcIiwgX2tleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKiogICAgICAgICAgIHRvIGhhbmRsZSBzaW1wbGUgY2xpY2sgICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcInRhcFwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG5cclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSC5tYXAuTWFya2VyKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgIGxldCBidXR0b24gPSBldi5jdXJyZW50UG9pbnRlci5idXR0b247XHJcblxyXG4gICAgICAgIGlmICgoYnV0dG9uID09IDApICYmIChzZXR0aW5ncy5jbGlja0xlZnQpKVxyXG4gICAgICAgICAgICBzZXR0aW5ncy5jbGlja0xlZnQoY29vcmRPMkEoY29vcmQpLCBcImxlZnRcIiwgX2tleSk7XHJcbiAgICAgICAgaWYgKChidXR0b24gPT0gMikgJiYgKHNldHRpbmdzLmNsaWNrUmlnaHQpKVxyXG4gICAgICAgICAgICBzZXR0aW5ncy5jbGlja1JpZ2h0KGNvb3JkTzJBKGNvb3JkKSwgXCJyaWdodFwiLCBfa2V5KTtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuY2xpY2spIHtcclxuICAgICAgICAgICAgc3dpdGNoIChidXR0b24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogc2V0dGluZ3MuY2xpY2soY29vcmRPMkEoY29vcmQpLCBcImxlZnRcIiwgX2tleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHNldHRpbmdzLmNsaWNrKGNvb3JkTzJBKGNvb3JkKSwgXCJyaWdodFwiLCBfa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKioqKioqKiogIGRpc2FibGUgdGhlIGRlZmF1bHQgZHJhZ2dhYmlsaXR5IG9mIHRoZSB1bmRlcmx5aW5nIG1hcCB3aGVuIHN0YXJ0aW5nIHRvIGRyYWcgYSBtYXJrZXIgb2JqZWN0ICoqKioqKioqKioqKioqKioqL1xyXG4gICAgX21hcC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEgubWFwLk1hcmtlcikge1xyXG4gICAgICAgICAgICBfYmVoYXZpb3IuZGlzYWJsZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAvKioqKioqKioqKioqICAgcmUgLSBlbmFibGUgdGhlIGRlZmF1bHQgZHJhZ2dhYmlsaXR5IG9mIHRoZSB1bmRlcmx5aW5nIG1hcCB3aGVuIGRyYWdnaW5nIGhhcyBjb21wbGV0ZWQgKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIG1hcHNqcy5tYXAuTWFya2VyKSB7XHJcbiAgICAgICAgICAgIF9iZWhhdmlvci5lbmFibGUoKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQuZHJhZ2dlZCAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgICAgICAodGFyZ2V0LmRyYWdnZWQpKHRhcmdldCwgY29vcmRPMkEoY29vcmQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKiogIExpc3RlbiB0byB0aGUgZHJhZyBldmVudCBhbmQgbW92ZSB0aGUgcG9zaXRpb24gb2YgdGhlIG1hcmtlciBhcyBuZWNlc3NhcnkgKioqKioqKioqKioqKioqKioqKi9cclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldCxcclxuICAgICAgICAgICAgcG9pbnRlciA9IGV2LmN1cnJlbnRQb2ludGVyO1xyXG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBtYXBzanMubWFwLk1hcmtlcikge1xyXG4gICAgICAgICAgICB0YXJnZXQuc2V0UG9zaXRpb24oX21hcC5zY3JlZW5Ub0dlbyhwb2ludGVyLnZpZXdwb3J0WCwgcG9pbnRlci52aWV3cG9ydFkpKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqICBkZXRlY3QgbWFwIHJlc2l6ZSBhbmQgYWRqdXN0IGFjY29yaWRuZ2x5ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbWFwLmdldFZpZXdQb3J0KCkucmVzaXplKCk7XHJcblxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBsaXN0IG9mIGFsbCBhdmFpbGFibGUgbWFwIHN0eWxlcyBub3JtYWwuZGF5LCBuaWdodC4uLi4gXHJcbiAqIEBhbGlhcyBobTpnZXRBdmFpbGFibGVNYXBTdHlsZVxyXG4gKiBAcmV0dXJuIHtqc29ufSBsaXN0IG9mIG1hcCBzdHlsZXMgYXMganNvblxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QXZhaWxhYmxlTWFwU3R5bGUoKSB7XHJcbiAgICAvLyBodHRwczovLzEuYmFzZS5tYXBzLmFwaS5oZXJlLmNvbS9tYXB0aWxlLzIuMS9pbmZvP3hubHA9Q0xfSlNNdjMuMC4xNy4wJmFwcF9pZD1uT1NoMjEyMTRKRk1TRVBRa3FubyZhcHBfY29kZT1yWF9sN1l2QUx0TmtxVTJieDVGV0VBJm91dHB1dD1qc29uXHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBjbS5hZGRDcmVkZW50aWFscyh7XHJcbiAgICAgICAgb3V0cHV0OiBcImpzb25cIlxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXJsID0gY20uYnVpbGRVcmwoXCIxLmJhc2UubWFwc1wiLCBcImFwaS5oZXJlLmNvbS9tYXB0aWxlLzIuMS9pbmZvXCIpO1xyXG4gICAgcmV0dXJuIGNtLmhlcmVSZXN0KHVybCwgc2V0dGluZ3MpXHJcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcy5ib2R5LnJlc3BvbnNlO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogZGVmaW5lIHRoZSBzY2hlbWUuIExpc3Qgb2Ygc2NoZW1lIGNhbiBiZSBvYnRhaW5lZCBmcm9tIHtobS5nZXRBdmFpbGFibGVNYXBTdHlsZSgpfVxyXG4gKiBAYWxpYXMgaG06c2V0U2NoZW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlbWUgc2NoZW1lIG5hbWVcclxuICovXHJcbmZ1bmN0aW9uIHNldFNjaGVtZShzY2hlbWUpIHtcclxuICAgIF9zY2hlbWUgPSBzY2hlbWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgYSBsYXllclxyXG4gKiBAYWxpYXMgaG06bGF5ZXJDcmVhdGVcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgIC0gbmFtZSBvZiBsYXllclxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZpc2libGUgIC0gaW5pdGlhbCBzdGF0dXNcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogaG0ubGF5ZXJDcmVhdGUoXCJsYXllcjFcIik7XHJcbiAqICBgYGBcclxuICovXHJcbmZ1bmN0aW9uIGxheWVyQ3JlYXRlKG5hbWUsIHZpc2libGUpIHtcclxuICAgIGdyb3VwID0gbmV3IEgubWFwLkdyb3VwKCk7XHJcbiAgICBncm91cC5uYW1lID0gbmFtZTtcclxuICAgIF9tYXAuYWRkT2JqZWN0KGdyb3VwKTtcclxuXHJcbiAgICAvLyBwdXNoIGludG8gbGlzdCBvZiBsYXllcnNcclxuICAgIF9sYXllcnMucHVzaChncm91cCk7XHJcblxyXG4gICAgLy8gY2FuIGJlIHZpc2libGUgb3IgaGlkZGVuXHJcbiAgICBpZiAodHlwZW9mIHZpc2libGUgIT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICBncm91cC5zZXRWaXNpYmlsaXR5KHZpc2libGUpO1xyXG5cclxuICAgIHJldHVybiBncm91cDtcclxufVxyXG5cclxuLyoqXHJcbiAqIGRlbGV0ZSBhIGxheWVyXHJcbiAqIEBhbGlhcyBobTpsYXllckRlbGV0ZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIGxheWVyXHJcbiAqL1xyXG5mdW5jdGlvbiBsYXllckRlbGV0ZShuYW1lKSB7XHJcbiAgICBsZXQgbGF5ZXIgPSBsYXllckZpbmQobmFtZSk7XHJcbiAgICBpZiAoIWxheWVyKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAvLyByZW1vdmUgZ3JvdXAgZnJvbSBtYXBcclxuICAgIF9tYXAucmVtb3ZlT2JqZWN0KGxheWVyKTtcclxuICAgIC8vcmVtb3ZlIGZvcm0gbGlzdCBvZiBsYXllcnNcclxuICAgIF9sYXllcnMgPSBfbGF5ZXJzLmZpbHRlcihpdGVtID0+IHsgcmV0dXJuIGl0ZW0ubmFtZSAhPT0gbmFtZTsgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbXB0eSBhIGxheWVyLFxyXG4gKiBAYWxpYXMgaG06bGF5ZXJFbXB0eVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgXHJcbiAqL1xyXG5mdW5jdGlvbiBsYXllckVtcHR5KG5hbWUpIHtcclxuICAgIGxldCBsYXllciA9IGxheWVyRmluZChuYW1lKTtcclxuICAgIGlmICghbGF5ZXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgbGF5ZXIucmVtb3ZlQWxsKCk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogZmluZCBsYXllciBieSBpdHMgbmFtZSBvciByZXR1cm4gbnVsbCBcclxuICogQGFsaWFzIGhtOmxheWVyRmluZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcclxuICovXHJcbmZ1bmN0aW9uIGxheWVyRmluZChuYW1lKSB7XHJcbiAgICBsZXQgbCA9IF9sYXllcnMuZmluZChsYXllciA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxheWVyLm5hbWUgPT0gbmFtZTtcclxuICAgIH0pO1xyXG4gICAgaWYgKHR5cGVvZiBsID09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIGw7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogc2V0IGNlbnRlciBvZiB0aGUgbWFwXHJcbiogQGFsaWFzIGhtOnNldENlbnRlclxyXG4gKiBAcGFyYW0ge0FycmF5fSAtIGNvb3JkIGFzIFtsYXQsbG5nXVxyXG4gKiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGhtLnNldENlbnRlcihbNDguOCwyLjNdKTtcclxuICogIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q2VudGVyKGNvb3JkKSB7XHJcbiAgICBfbWFwLnNldENlbnRlcihjb29yZEEyTyhjb29yZCkpO1xyXG59XHJcblxyXG4vKipcclxuICogcmV0dXJuIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwXHJcbiAqIEBhbGlhcyBobTpnZXRDZW50ZXJcclxuICogQHJldHVybnMge2Nvb3JkfSBjb29yZCBvZiB0aGUgY2VudGVyIGFzIFxcW2xhdCxsbmdcXF1cclxuICovXHJcbmZ1bmN0aW9uIGdldENlbnRlcigpIHtcclxuICAgIGxldCBib3VuZCA9IF9tYXAuZ2V0Vmlld0JvdW5kcygpO1xyXG4gICAgLy9fSE0ubG9nKFwidmlld2JvdW5kXCIsYm91bmQpO1xyXG5cclxuICAgIGxldCBsbmcgPSAoYm91bmQuZ2EgKyBib3VuZC5oYSkgLyAyO1xyXG4gICAgbGV0IGxhdCA9IChib3VuZC5rYSArIGJvdW5kLmphKSAvIDI7XHJcbiAgICByZXR1cm4gW2xhdCwgbG5nXTtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gYm91bmRpbmcgYm94IG9mIHZpc2libGUgcGFydCBvZiBtYXBcclxuICogQGFsaWFzIGhtOmdldFZpZXdCQlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBib3VkaW5nIGJveCBvZiB2aXNpYmxlIHBhcnQgb2YgdGhlIG1hcCwgYXMgXFxbbGF0bSxsYXRNLGxvbmdtLGxuZ01cXF1cclxuICovXHJcbmZ1bmN0aW9uIGdldFZpZXdCQigpIHtcclxuICAgIGxldCBiYiA9IF9tYXAuZ2V0Vmlld0JvdW5kcygpO1xyXG5cclxuICAgIGxldCBiYjIgPSB7XHJcbiAgICAgICAgbGF0bTogYmIuamEsXHJcbiAgICAgICAgbGF0TTogYmIua2EsXHJcbiAgICAgICAgbG5nbTogYmIuZ2EsXHJcbiAgICAgICAgbG5nTTogYmIuaGFcclxuICAgIH07XHJcbiAgICByZXR1cm4gYmIyO1xyXG59XHJcblxyXG4vKipcclxuICogc2V0cyBib3VkaW5nIGJveCB0byBiZSBkaXNwbGF5ZWRcclxuICogQGFsaWFzIGhtOnNldFZpZXdCQlxyXG4gKiBAcGFyYW0gb3B0IHtPYmplY3R8IHN0cmluZ30gIGVpdGhlciBhbiBvYmplY3Qgc3BlY2lmeWluZyBob3cgdG8gc2V0IGJvdW5kaW5nIGJveCwgb3IgIGEgU3RyaW5nIGJlaW5nIHRoZSBuYW1lIG9mIGEgbGF5ZXJcclxuICogQHBhcmFtIFtvcHQubGF5ZXJdIHtzdHJpbmd9IGJvdWRpbmcgYm94IGFyb3VkIGFsbCBvYmplY3RzIG9mIHRoZSBsYXllclxyXG4gKiBAcGFyYW0gW29wdC5wb2lzXSB7YXJyYXl9IGJvdWRpbmcgYm94IGFyb3VkIGFsbCBjb29yZHMgZGVmaW5lZCBhcyBcXFtjb29yZCxjb29yZC4uLlxcXVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gICogaG0uc2V0Vmlld0JCKFwibGF5ZXIxXCIpO1xyXG4gKlxyXG4gKiBobS5zZXRWaWV3QkIoe1xyXG4gICAgKiAgICBwb2lzOiBjb29yZHNcclxuICAgICogfSk7XHJcbiAqICBgYGBcclxuICovXHJcbmZ1bmN0aW9uIHNldFZpZXdCQihvcHQpIHtcclxuXHJcbiAgICBpZiAodHlwZW9mIG9wdCA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgIG9wdCA9IHsgbGF5ZXI6IG9wdCB9O1xyXG5cclxuICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBsYXllcjogbnVsbCxcclxuICAgICAgICBwb2lzOiBudWxsIC8vIGFycmF5IG9mIFtsYXQsbG5nXVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgbGV0IGJib3g7XHJcblxyXG4gICAgLy9zZXQgQkIgYmFzZWQgb24gbGF5ZXJcclxuICAgIGlmIChzZXR0aW5ncy5sYXllcikge1xyXG4gICAgICAgIGxldCBsYXllciA9IGxheWVyRmluZChzZXR0aW5ncy5sYXllcik7XHJcbiAgICAgICAgaWYgKCFsYXllcikgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBnZXQgdmlldyBib3VuZCBhbmQgYWRkIGEgYml0IGFyb3VuZCwgbGlrZSAxLzVcclxuICAgICAgICBsZXQgYmIgPSBsYXllci5nZXRCb3VuZHMoKTtcclxuICAgICAgICBpZiAoIWJiKSAvLyBhcyBpZiBub3RoaW5nIGluIGxheWVyXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBiYi5sYXRtID0gYmIuamE7XHJcbiAgICAgICAgYmIubGF0TSA9IGJiLmthO1xyXG4gICAgICAgIGJiLmxuZ20gPSBiYi5nYTtcclxuICAgICAgICBiYi5sbmdNID0gYmIuaGE7XHJcbiAgICAgICAgbGV0IGR4ID0gYmIubG5nTSAtIGJiLmxuZ207XHJcbiAgICAgICAgbGV0IGR5ID0gYmIubGF0TSAtIGJiLmxhdG07XHJcbiAgICAgICAgZHggPSBkeCAvIDU7XHJcbiAgICAgICAgZHkgPSBkeSAvIDU7XHJcbiAgICAgICAgYmIubGF0TSArPSBkeTtcclxuICAgICAgICBiYi5sbmdtIC09IGR4O1xyXG4gICAgICAgIGJiLmxhdG0gLT0gZHk7XHJcbiAgICAgICAgYmIubG5nTSArPSBkeDtcclxuICAgICAgICBiYm94ID0gbmV3IEguZ2VvLlJlY3QoYmIubGF0TSwgYmIubG5nbSwgYmIubGF0bSwgYmIubG5nTSk7XHJcbiAgICAgICAgX21hcC5zZXRWaWV3Qm91bmRzKGJib3gsIHRydWUpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBlbHNlIGlmIChzZXR0aW5ncy5wb2lzKSB7XHJcbiAgICAgICAgbGV0IGJiID0ge1xyXG4gICAgICAgICAgICBsYXRNOiAwLFxyXG4gICAgICAgICAgICBsbmdtOiAxODAsXHJcbiAgICAgICAgICAgIGxhdG06IDkwLFxyXG4gICAgICAgICAgICBsbmdNOiAtMTgwLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IGFyciA9IHNldHRpbmdzLnBvaXM7XHJcbiAgICAgICAgYXJyLmZvckVhY2goKHBvaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocG9pWzBdID4gYmIubGF0TSkgYmIubGF0TSA9IHBvaVswXTtcclxuICAgICAgICAgICAgaWYgKHBvaVsxXSA+IGJiLmxuZ00pIGJiLmxuZ00gPSBwb2lbMV07XHJcbiAgICAgICAgICAgIGlmIChwb2lbMF0gPCBiYi5sYXRtKSBiYi5sYXRtID0gcG9pWzBdO1xyXG4gICAgICAgICAgICBpZiAocG9pWzFdIDwgYmIubG5nbSkgYmIubG5nbSA9IHBvaVsxXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBiYm94ID0gbmV3IEguZ2VvLlJlY3QoYmIubGF0TSwgYmIubG5nbSwgYmIubGF0bSwgYmIubG5nTSk7XHJcbiAgICAgICAgX21hcC5zZXRWaWV3Qm91bmRzKGJib3gsIHRydWUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIHJldHVybiB6b29tIHZhbHVlXHJcbiAqIEBhbGlhcyBobTpnZXRab29tXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHpvb20gbGV2ZWxcclxuICovXHJcbmZ1bmN0aW9uIGdldFpvb20oKSB7XHJcbiAgICByZXR1cm4gX21hcC5nZXRab29tKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzZXQgem9vbSBsZXZlbFxyXG4gKiBAYWxpYXMgaG06c2V0Wm9vbVxyXG4gKiBAcGFyYW0ge251bWJlcn0gem9vbSBcclxuICovXHJcbmZ1bmN0aW9uIHNldFpvb20oem9vbSkge1xyXG4gICAgX21hcC5zZXRab29tKHpvb20pO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgYW4gaWNvbiwgdG8gYmUgdXNlZCBmb3IgYSBtYXJrZXJcclxuICogQGFzeW5jXHJcbiAqIEBhbGlhcyBobTpidWlsZEljb25cclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSBvcHRpb25zIHRvIHNwZWNpZnkgdGhlIGljb25cclxuICogQHBhcmFtIFtvcHQuaW1nXSB7c3RyaW5nfSAgdXNlIGEgcG5nL2pwZyBpbWFnZS4gU3BlY2lmeSB0aGUgdXJsIFxyXG4gKiBAcGFyYW0gW29wdC5zdmddIHtzdHJpbmd9ICB1cmwgYSBzdmcuIFRoaXMgY2FuIGJlIGFuIGlubGluZSBzdmcsIGEgdXJsLCBvciBhIHN2ZyBmcm9tIGhlcmVtYXBcclxuICogQHBhcmFtIFtvcHQub3B0XSB7b2JqZWN0fSAgIHN0eWxlIG9iamVjdFxyXG4gKiBAcGFyYW0gW29wdC5vcHQuc2l6ZV0ge251bWJlcnxzdHJpbmd9ICAgc2l6ZSBvZiBpY29uLCBhcyAyNCBvciAyNHgzMlxyXG4gKiBAcGFyYW0gW29wdC5vcHQucmF0aW9dIHtudW1iZXJ9ICAgZm9yIHN2ZyBmaWxlcywgcmF0aW8gb2Ygc2l6ZS4gMC41ID0gaGFsZlxyXG4gKiBAcGFyYW0gW29wdC5vcHQuYW5jaG9yXSB7bnVtYmVyfHN0cmluZ30gICBhbmNob3Igb2YgaWNvbiwgYXMgMjQgb3IgXCIyNHgzMlwiIG9yIFwiY2VudGVyXCIuIEJ5IGRlZmF1bHQsIGJvdHRvbS1jZW50ZXJcclxuICogQHBhcmFtIFtvcHQub3B0LnRhZ10ge3N0cmluZ30gICBmb3Igc3ZnLCBhbnkgdGFnIGxpa2V7dGFnfS4gd2lsbCBiZSByZXBsYWNlZCBieSBhc3NvY2lhdGVkIHZhbHVlXHJcbiAqIEByZXR1cm4ge0gubWFwLkljb259IHRoZSBjcmVhdGVkIGljb25cclxuICogQGV4YW1wbGUgXHJcbiAqIGBgYGpzXHJcbiAqIGhtLmJ1aWxkSWNvbih7XHJcbiAqICAgIGltZzogXCJodHRwOi8vd2hhdGV2ZXIuY29tL2ltYWdlLnBuZ1wiLFxyXG4gKiAgICBvcHQ6IHtzaXplOjI0fVxyXG4gKiB9KTtcclxuICogXHJcbiAqIGhtLmJ1aWxkSWNvbih7XHJcbiAqICAgIHN2ZzogXCJodHRwOi8vd2hhdGV2ZXIuY29tL2ltYWdlLnN2Z1wiLFxyXG4gKiAgICBvcHQ6IHtcclxuICogICAgICAgcmF0aW86MC41LFxyXG4gKiAgICAgICBhbmNob3I6MjR4MzJcclxuICogICAgfVxyXG4gKiB9KTtcclxuICogIFxyXG4gKiBobS5idWlsZEljb24oe1xyXG4gKiAgICBzdmc6IFwic3ZnL2NsdXN0ZXIuc3ZnXCIsXHJcbiAqICAgIG9wdDoge1xyXG4gKiAgICAgICBzaXplOjI0LFxyXG4gKiAgICAgICBjb2xvcjpcInJlZFwiXHJcbiAqICAgIH1cclxuICogfSk7XHJcbiAqIFxyXG4gKiBjb25zdCBzdmcgPSBgPHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+IDxlbGxpcHNlIHN0cm9rZT1cIm51bGxcIiByeT1cIjhcIiByeD1cIjcuNjE4ODk2XCIgaWQ9XCJzdmdfMVwiIGN5PVwiOFwiIGN4PVwiNy44Mzc0MjdcIiBmaWxsPVwie2NvbG9yfVwiIGZpbGwtb3BhY2l0eT1cIjAuOVwiLz48L3N2Zz5gO1xyXG4gKiBobS5idWlsZEljb24oe1xyXG4gKiAgICBzdmc6IHN2ZyxcclxuICogICAgb3B0OiB7XHJcbiAqICAgICAgIHNpemU6MjQsXHJcbiAqICAgICAgIGNvbG9yOlwicmVkXCJcclxuICogICAgfSBcclxuICogfSk7XHJcbiAqICBgYGBcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkSWNvbihvcHQpIHtcclxuICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBpbWc6IG51bGwsICAgICAgICAgICAgIC8vICAgcG5nLCBqcGcuIGlmIG5vdCBodHRwIGluIHRoZSBiZWdpbm5pbmcsIGxvb2sgbG9jYWxseVxyXG4gICAgICAgIHN2ZzogbnVsbCwgICAgICAgICAgICAgLy8gc3ZnIGZpbGU6ICBpcyBhIHVybCBvciBhIHN0cmluZ1xyXG4gICAgICAgIG9wdDogbnVsbCwgICAgICAgICAgICAgIC8vIHNpemUsIGNvbG9yLCBhbmNob3IsIHRleHQuLi5zXHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgaWYgKCFzZXR0aW5ncy5pbWcgJiYgIXNldHRpbmdzLnN2Zykge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpY29uLCBpY29uU3JjO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5pbWcpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInNldHRpbmdzLmltZ1wiLCBzZXR0aW5ncy5pbWcpO1xyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MuaW1nLnN1YnN0cigwLCA0KSA9PSBcImh0dHBcIikgLy8gdXJsXHJcbiAgICAgICAgICAgIGljb25TcmMgPSBzZXR0aW5ncy5pbWc7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBpY29uU3JjID0gY20uZ2V0SG9tZSgpICsgc2V0dGluZ3MuaW1nOyAvLyBsb2NhbCBmaWxlXHJcblxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2V0dGluZ3Muc3ZnKSB7XHJcblxyXG4gICAgICAgIGxldCB1cmwgPSBudWxsO1xyXG4gICAgICAgIGljb25TcmMgPSBzZXR0aW5ncy5zdmc7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnN2Zy5zdWJzdHIoMCwgNCkgPT0gXCJodHRwXCIpIC8vIHVybFxyXG4gICAgICAgICAgICB1cmwgPSBzZXR0aW5ncy5zdmc7XHJcbiAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3Muc3ZnLnN1YnN0cigwLCA0KSA9PSBcIjxzdmdcIikgLy8gdXJsXHJcbiAgICAgICAgICAgIHVybCA9IG51bGw7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB1cmwgPSBjbS5nZXRIb21lKCkgKyBzZXR0aW5ncy5zdmc7IC8vbWlzc2luZyBwcm90b2NvbCwgbm90IGFuIGVtYmVkZGVkIHN0cmluZywgbG9vayBpbiBsb2NhbCBoZXJlbWFwIG1vZHVsZVxyXG5cclxuICAgICAgICBpZiAodXJsKSAvLyBhbiB1cmwgdG8gZG93bmxvYWRcclxuICAgICAgICAgICAgaWNvblNyYyA9IGF3YWl0IGZldGNoKHVybClcclxuICAgICAgICAgICAgICAgIC50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT0gMjAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpY29uT3B0ID0geyBjcm9zc09yaWdpbjogdHJ1ZSB9OyAvLyB0byBhdm9pZCBpc3N1ZWQgd2l0aCBjYXB0dXJlXHJcbiAgICBpZiAoc2V0dGluZ3Mub3B0ICYmIHNldHRpbmdzLm9wdC5zaXplKSB7XHJcbiAgICAgICAgbGV0IHcsIGg7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5vcHQuc2l6ZSA9PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICB3ID0gaCA9IHNldHRpbmdzLm9wdC5zaXplO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgW3csIGhdID0gc2V0dGluZ3Mub3B0LnNpemUuc3BsaXQoXCJ4XCIpO1xyXG5cclxuICAgICAgICBpY29uT3B0LnNpemUgPSB7IHc6IHcsIGg6IGggfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0c2l6ZVN2ZyhpY29uU3JjKSB7XHJcbiAgICAgICAgbGV0IHcgPSBudWxsLCBoID0gbnVsbCwgbWF0Y2g7XHJcbiAgICAgICAgbGV0IHIgPSAvd2lkdGg9XCIoXFxkKylcIi87XHJcbiAgICAgICAgbWF0Y2ggPSBpY29uU3JjLm1hdGNoKHIpO1xyXG4gICAgICAgIGlmIChtYXRjaCkgdyA9IG1hdGNoWzFdO1xyXG5cclxuICAgICAgICByID0gL2hlaWdodD1cIihcXGQrKVwiLztcclxuICAgICAgICBtYXRjaCA9IGljb25TcmMubWF0Y2gocik7XHJcbiAgICAgICAgaWYgKG1hdGNoKSBoID0gbWF0Y2hbMV07XHJcbiAgICAgICAgcmV0dXJuIFt3LCBoXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2V0dGluZ3Muc3ZnICYmIHNldHRpbmdzLm9wdCAmJiBzZXR0aW5ncy5vcHQucmF0aW8pIHtcclxuICAgICAgICBsZXQgdyA9IG51bGwsIGggPSBudWxsO1xyXG4gICAgICAgIFt3LCBoXSA9IF9nZXRzaXplU3ZnKGljb25TcmMpO1xyXG5cclxuICAgICAgICBpY29uT3B0LnNpemUgPSB7IHc6IE1hdGguZmxvb3IodyAqIHNldHRpbmdzLm9wdC5yYXRpbyksIGg6IE1hdGguZmxvb3IoaCAqIHNldHRpbmdzLm9wdC5yYXRpbykgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2V0dGluZ3Mub3B0ICYmIHNldHRpbmdzLm9wdC5hbmNob3IpIHtcclxuICAgICAgICBsZXQgdyA9IG51bGwsIGggPSBudWxsO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Mub3B0LmFuY2hvciA9PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICB3ID0gaCA9IHNldHRpbmdzLm9wdC5hbmNob3I7XHJcbiAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3Mub3B0LmFuY2hvciA9PSBcImNlbnRlclwiICYmIHNldHRpbmdzLnN2ZykgeyAgLy8gZm9yIHN2ZyBmaWxlIG9ubHkgY2VudGVyOiBnZXQgc2l6ZSBvZiBzcGxpdCBpbiAyXHJcbiAgICAgICAgICAgIFt3LCBoXSA9IF9nZXRzaXplU3ZnKGljb25TcmMpO1xyXG4gICAgICAgICAgICB3IC89IDI7IGggLz0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBbdywgaF0gPSBzZXR0aW5ncy5vcHQuYW5jaG9yLnNwbGl0KFwieFwiKTtcclxuXHJcbiAgICAgICAgaWYgKCF3IHx8ICFoKSB7XHJcbiAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiQnVpbGRJY29uOiBpbmNvcnJlY3QgYW5jaG9yXCIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpY29uT3B0LmFuY2hvciA9IG5ldyBILm1hdGguUG9pbnQodywgaCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWxsIG90aGVyIGZpZWxkcyBhcmUgdHJlYXRlZCBhcyBncmFwaGljIGVuaGFuY2VlbnRcclxuICAgIGlmIChzZXR0aW5ncy5vcHQpIHtcclxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNldHRpbmdzLm9wdCkge1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImZpbGVcIiB8fCBuYW1lID09IFwic2l6ZVwiIHx8IG5hbWUgPT0gXCJhbmNob3JcIikgY29udGludWU7XHJcbiAgICAgICAgICAgIGxldCByZSA9IG5ldyBSZWdFeHAoXCJ7XCIgKyBuYW1lICsgXCJ9XCIsIFwiZ1wiKTtcclxuICAgICAgICAgICAgaWNvblNyYyA9IGljb25TcmMucmVwbGFjZShyZSwgc2V0dGluZ3Mub3B0W25hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coXCJpY29uU3JjXCIsIGljb25TcmMpO1xyXG4gICAgLy8gY29uc29sZS5sb2coXCJpY29uT3B0XCIsIGljb25PcHQpO1xyXG4gICAgaWNvbiA9IG5ldyBILm1hcC5JY29uKGljb25TcmMsIGljb25PcHQpO1xyXG5cclxuICAgIHJldHVybiBpY29uO1xyXG5cclxufSAvL2VuZCBvZiBpY29uXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIGFkZCBhIG1hcmtlciBpbiBhIGxheWVyXHJcbiAqIHN2ZyBmaWxlcyBjYW4gYmUgY3JlYXRlZCB3aXRoIGh0dHBzOi8vZWRpdG9yLm1ldGhvZC5hYy8gXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06bWFya2VyXHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gb3B0aW9ucyB0byBjcmVhdGUgdGhlIG1hcmtlciwgY2FuIGJlIGEgY29vcmQgZGlyZWN0bHlcclxuICogQHBhcmFtIFtvcHQubGF5ZXJdIHtzdHJpbmd9ICAgbGF5ZXIgbmFtZVxyXG4gKiBAcGFyYW0gW29wdC5jb29yZF0ge2Nvb3JkfSAgIGNvb3JkIG9mIHRoZSBtYXJrZXIgYXMgXFxbbGF0LGxuZ1xcXVxyXG4gKiBAcGFyYW0gW29wdC5pY29uXSB7c3RyaW5nfSAgIGNyZWF0ZWQgZnJvbSBobS5idWlsZEljb25cclxuICogQHBhcmFtIFtvcHQuc3ZnXSB7c3RyaW5nfSAgIHNlZSBobS5idWlsZEljb25cclxuICogQHBhcmFtIFtvcHQub3B0XSB7T2JqZWN0fSAgIHNlZSBobS5idWlsZEljb25cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LnBvaW50ZXJlbnRlciAgaWYgZW50ZXIsIGNhbGxiYWNrKHRhcmdldCxjb29yZCxldilcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LnBvaW50ZXJDbGljayAgaWYgY2xpY2ssIGNhbGxiYWNrKHRhcmdldCxjb29yZCxldilcclxuICogQHBhcmFtIHtzdHJpbmd9IG9wdC5kYXRhICBvcHRpb25hbCBkYXRhXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmJ1YmJsZSAgaWYgdHJ1ZSwgc2hvdyBidWJsZSBvbiBjbGljayB3aXRoIGRhdGFcclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZHJhZ2dhYmxlICBkcmFnZ2FibGUgbWFya2VyXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdC5kcmFnZ2VkICBpZiBkcmFnZ2VkLCBjYWxsYmFjayh0YXJnZXQsY29vcmQpXHJcbiAqIEBleGFtcGxlIFxyXG4gKiBgYGBqc1xyXG4gKiBobS5tYXJrZXIoWzQ4LjgsMi4zXSk7XHJcbiAqXHJcbiAqIGhtLm1hcmtlcih7XHJcbiAqICAgIGNvb3JkOiBbNDguOCwyLjNdLFxyXG4gKiB9KTtcclxuICogXHJcbiAqIGhtLm1hcmtlcih7XHJcbiAgICAqICAgc3ZnOiBcInN2Zy9tYXJrZXIuc3ZnXCIsXHJcbiAgICAqICAgY29sb3I6XCJyZWRcIixcclxuICAgICogICByYXRpbzowLjVcclxuICAgICogfSk7XHJcbiAgICAqIFxyXG4gKiBobS5tYXJrZXIoe1xyXG4gKiAgICBpbWc6IFwiaHR0cDovL3doYXRldmVyLmNvbS9pbWFnZS5wbmdcIixcclxuICogICAgY29vcmQ6IFs0OC44LDIuM11cclxuICogfSk7XHJcbiAqIFxyXG4gKiBobS5tYXJrZXIoe1xyXG4gKiAgICBjb29yZDogWzQ4LjgsMi4zXSxcclxuICogICAgZGF0YTpcIkhlbGxvIHdvcmxkXCIsXHJcbiAqICAgIGJ1YmJsZTogdHJ1ZVxyXG4gKiB9KTtcclxuICogXHJcbiAqIGhtLm1hcmtlcih7XHJcbiAqICAgIGNvb3JkOiBbNDguOCwyLjNdLFxyXG4gKiAgICBkcmFnZ2FibGU6dHJ1ZSxcclxuICogICAgZHJhZ2dlZDogZnVuY3Rpb24odGFyZ2V0LGNvb3JkKSB7Y29uc29sZS5sb2coXCJkcmFnZ2VkIHRvXCIsY29vcmQpO31cclxuICogfSk7XHJcbiogIGBgYFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gbWFya2VyKG9wdCkge1xyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIGxheWVyOiBcImRlZmF1bHRcIiwgICAgICAgLy8gIGxheWVyIGluIHdoaWNoIHRvIGFkZCBtYXJrZXJcclxuICAgICAgICBjb29yZDogbnVsbCwgICAgICAgICAgICAvLyAgY29vcmQgb2YgdGhlIG1hcmtlclxyXG4gICAgICAgIGltZzogbnVsbCwgICAgICAgICAgICAgLy8gIGltYWdlIGNhbiBiZSB1cmwsIHBuZywganBnLi5cclxuICAgICAgICBzdmc6IG51bGwsICAgICAgICAgICAgIC8vIHN2ZyBmaWxlXHJcbiAgICAgICAgaWNvbjogbnVsbCwgICAgICAgICAgICAgIC8vIGljb24gcHJldmlvdXNseSBjcmVhdGVkXHJcbiAgICAgICAgb3B0OiB7fSwgICAgICAgICAgICAgICAvLyBvcHQgZm9yIGljb25cclxuICAgICAgICBwb2ludGVyRW50ZXI6IG51bGwsICAgICAvLyAgY2FsbGJhY2sodGFyZ2V0LGNvb3JkLGV2KVxyXG4gICAgICAgIHBvaW50ZXJDbGljazogbnVsbCwgICAgIC8vICBjYWxsYmFjayh0YXJnZXQsY29vcmQsZXYpXHJcbiAgICAgICAgZGF0YTogbnVsbCwgICAgICAgICAgICAgLy8gIHVzZXIgZGF0YVxyXG4gICAgICAgIGJ1YmJsZTogZmFsc2UsICAgICAgICAgIC8vICBzaG93IGEgYnViYmxlIHdpdGggdXNlciBkYXRhXHJcbiAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSwgICAgICAgLy8gIGljb24gaXMgZHJhZ2dhbGJlXHJcbiAgICAgICAgZHJhZ2dlZDogbnVsbCAgICAgICAgICAgLy8gIGNhbGxiYWNrKHRhcmdldCxjb29yZClcclxuICAgIH07XHJcblxyXG4gICAgLy8gY2FuIHBhc3MgZGlyZWN0bHkgb25seSB0aGUgY29vcmRcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdCkpXHJcbiAgICAgICAgb3B0LmNvb3JkID0gb3B0O1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgbGV0IGxheWVyID0gbGF5ZXJGaW5kKHNldHRpbmdzLmxheWVyKTtcclxuICAgIGlmICghbGF5ZXIpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcImxheWVyIG5vdCBmb3VuZDpcIiArIHNldHRpbmdzLmxheWVyKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldHRpbmdzLmNvb3JkID0geyBsYXQ6IHNldHRpbmdzLmNvb3JkWzBdLCBsbmc6IHNldHRpbmdzLmNvb3JkWzFdIH07XHJcblxyXG4gICAgLy8gdGhlc2UgcGFyYW1ldGVycyBjYW4gYmUgaW4gb3B0Lm9wdCBvciBkaXJlY3RseSBpbiBvcHRcclxuICAgIGlmIChzZXR0aW5ncy5jb2xvcikgc2V0dGluZ3Mub3B0LmNvbG9yID0gc2V0dGluZ3MuY29sb3I7XHJcbiAgICBpZiAoc2V0dGluZ3Muc2l6ZSkgc2V0dGluZ3Mub3B0LnNpemUgPSBzZXR0aW5ncy5zaXplO1xyXG4gICAgaWYgKHNldHRpbmdzLnJhdGlvKSBzZXR0aW5ncy5vcHQucmF0aW8gPSBzZXR0aW5ncy5yYXRpbztcclxuICAgIGlmIChzZXR0aW5ncy5hbmNob3IpIHNldHRpbmdzLm9wdC5hbmNob3IgPSBzZXR0aW5ncy5hbmNob3I7XHJcblxyXG4gICAgbGV0IG1hcmtlck9wdCA9IG51bGw7XHJcbiAgICBpZiAoc2V0dGluZ3MuaW1nIHx8IHNldHRpbmdzLnN2Zykge1xyXG4gICAgICAgIGxldCBpY29uID0gYXdhaXQgYnVpbGRJY29uKHNldHRpbmdzKTtcclxuICAgICAgICBtYXJrZXJPcHQgPSB7IGljb246IGljb24gfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNldHRpbmdzLmljb24pIHtcclxuICAgICAgICBtYXJrZXJPcHQgPSB7IGljb246IHNldHRpbmdzLmljb24gfTtcclxuICAgIH1cclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKFwibWFya2VyIHNldHRpbmdzLmNvb3JkXCIsIHNldHRpbmdzLmNvb3JkKTtcclxuICAgIGxldCBtYXJrZXIgPSBuZXcgSC5tYXAuTWFya2VyKHNldHRpbmdzLmNvb3JkLCBtYXJrZXJPcHQpO1xyXG5cclxuICAgIG1hcmtlci5kcmFnZ2FibGUgPSBzZXR0aW5ncy5kcmFnZ2FibGU7XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLmRyYWdnZWQpIG1hcmtlci5kcmFnZ2VkID0gc2V0dGluZ3MuZHJhZ2dlZDtcclxuXHJcbiAgICBpZiAoc2V0dGluZ3MuZGF0YSkge1xyXG4gICAgICAgIGxldCBkYXRhID0gc2V0dGluZ3MuZGF0YTtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuZGF0YSA9PSBcIl9fT1BUX19cIikge1xyXG4gICAgICAgICAgICBkYXRhID0gc2V0dGluZ3M7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLmNvb3JkO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwIGluIGRhdGEpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGFbcF0pIGRlbGV0ZSBkYXRhW3BdO1xyXG4gICAgICAgICAgICBkYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikucmVwbGFjZSgvXFxuL2csIFwiPGJyLz5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmtlci5zZXREYXRhKGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGdldCBjbGljayBmcm9tIG1vdXNlXHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckVudGVyKSB7XHJcbiAgICAgICAgbWFya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgZnVuY3Rpb24gKGV2KSB7XHJcblxyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckVudGVyKHRhcmdldCwgY29vcmRPMkEoY29vcmQpLCBldik7XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKioqKioqKioqKiogIGNhbGxiYWNrIHdoZW4gY2xpY2sgb24gbWFya2VyICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgaWYgKHNldHRpbmdzLnBvaW50ZXJDbGljaykge1xyXG4gICAgICAgIG1hcmtlci5hZGRFdmVudExpc3RlbmVyKFwidGFwXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckNsaWNrKHRhcmdldCwgY29vcmRPMkEoY29vcmQpLCBldik7XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKioqKioqKioqKiogIHNob3cgYSBidWJibGUgd2hlbiBjbGlja2luZyBvbiBtYXJrZXIgKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBpZiAoc2V0dGluZ3MuYnViYmxlKSB7XHJcbiAgICAgICAgbWFya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0YXBcIiwgZnVuY3Rpb24gKGV2KSB7XHJcblxyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHRhcmdldC5nZXREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG5cclxuICAgICAgICAgICAgYnViYmxlVW5pcXVlKGNvb3JkTzJBKGNvb3JkKSwgZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGF5ZXIuYWRkT2JqZWN0KG1hcmtlcik7XHJcbiAgICByZXR1cm4gbWFya2VyO1xyXG5cclxufSAvL2VuZCBvZiBtYXJrZXJcclxuXHJcbi8qKlxyXG4gKiBkaXNwbGF5IGEgdW5pcXVlIGJ1YmJsZS4gQXNzb2NpYXRlZCBDU1Mgc3R5bGUgaXMgLkhfaWJfYm9keVxyXG4gKiBAYWxpYXMgaG06YnViYmxlVW5pcXVlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkIG9mIHRoZSBidWJibGVcclxuICogQHBhcmFtIHtTdHJpbmd9IHR4dCBodG1sIHRleHQgdG8gZGlzcGxheVxyXG4gKi9cclxuZnVuY3Rpb24gYnViYmxlVW5pcXVlKGNvb3JkLCB0eHQpIHtcclxuXHJcbiAgICBpZiAoIV9idWJibGVNYXJrZXIpIHtcclxuICAgICAgICBfYnViYmxlTWFya2VyID0gbmV3IEgudWkuSW5mb0J1YmJsZShcclxuICAgICAgICAgICAgY29vcmRBMk8oY29vcmQpLCB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0eHRcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF91aS5hZGRCdWJibGUoX2J1YmJsZU1hcmtlcik7XHJcbiAgICAgICAgX2J1YmJsZU1hcmtlci5hZGRDbGFzcyhcImJ1YmJsZVVuaXF1ZVwiKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9idWJibGVNYXJrZXIuc2V0UG9zaXRpb24oY29vcmRBMk8oY29vcmQpKTtcclxuICAgICAgICBfYnViYmxlTWFya2VyLnNldENvbnRlbnQodHh0KTtcclxuICAgICAgICBfYnViYmxlTWFya2VyLm9wZW4oKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogaGlkZSBhIHVuaXF1ZSBidWJibGVcclxuICogQGFsaWFzIGhtOmJ1YmJsZVVuaXF1ZUhpZGVcclxuICovXHJcbmZ1bmN0aW9uIGJ1YmJsZVVuaXF1ZUhpZGUoKSB7XHJcbiAgICBpZiAoIV9idWJibGVNYXJrZXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgX2J1YmJsZU1hcmtlci5jbG9zZSgpO1xyXG59XHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogRHJhdyBhIHBvbHlsaW5lLiBcclxuICogQGFsaWFzIGhtOnBvbHlsaW5lXHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gICBvcHRpb25zIHRvIGRyYXcgcG9seWxpbmVcclxuICogQHBhcmFtIFtvcHQubGF5ZXJdIHtTdHJpbmd9IG9wdGlvbmFsIGxheWVyIHRvIHVzZSBcclxuICogQHBhcmFtIFtvcHQuY29vcmRzXSB7YXJyYXl9IGFycmF5IG9mIGNvb3JkcywgYXMgXFxbXFxbNDguOCwyLjNcXF0sXFxbNDguODUsMi40XFxdLC4uLiBcXF1cclxuICogQHBhcmFtIFtvcHQuc3R5bGVdIHtvYmplY3R9IG9wdGlvbmFsIGdyYXBoaWMgc3R5bGVcclxuICogQHBhcmFtIFtvcHQubGluZVdpZHRoPTRdIHtudW1iZXJ9IGxpbmUgd2lkdGhcclxuICogQHBhcmFtIFtvcHQuc3R5bGUuc3Ryb2tlQ29sb3I9cmdiYSgwLCAxMjgsIDI1NSwgMC43KV0ge3N0cmluZ30gbGluZSBjb2xvclxyXG4gKiBAcGFyYW0gW29wdC5hcnJvd3NdIHtvYmplY3R9IG9wdGlvbmFsIGFycm93XHJcbiAqIEBwYXJhbSBbb3B0LmRhdGFdIHtTdHJpbmd9IG9wdGlvbmFsIHVzZXIgZGF0YVxyXG4gKiBAcGFyYW0gW29wdC5wb2ludGVyQ2xpY2tdIHtmdW5jdGlvbn0gb3B0aW9uYWwgY2FsbGJhY2sgaWYgY2xpY2sgb24gbGluZS4gZm9ybWF0IGNhbGxiYWNrKHRhcmdldCxjb29yZCxldmVudClcclxuICogQHBhcmFtIFtvcHQucG9pbnRlcmVudGVyXSB7ZnVuY3Rpb259IG9wdGlvbmFsIGNhbGxiYWNrIGlmIG1vdXNlIGVudGVycyBvbiBsaW5lLiBmb3JtYXQgY2FsbGJhY2sodGFyZ2V0LGNvb3JkLGV2ZW50KVxyXG4gKiBAcGFyYW0gW29wdC5wb2ludGVyTGVhdmVdIHtmdW5jdGlvbn0gb3B0aW9uYWwgY2FsbGJhY2sgaWYgbW91c2UgbGVhdmVzIHRoZSBsaW5lLiBmb3JtYXQgY2FsbGJhY2sodGFyZ2V0LGNvb3JkLGV2ZW50KVxyXG4gKiBAcGFyYW0gW29wdC56XSB7bnVtYmVyfSBvcHRpb25hbCB6IGxldmVsXHJcbiogYGBganNcclxuKiBobS5wb2x5bGluZSh7XHJcbiAgICAqICAgIGNvb3JkczogW1s0OC44LDIuM10sWzQ4Ljg1LDIuNF0sWzQ4LjksMi42XV0sXHJcbiAgICAqICAgIGxheWVyOlwibGF5ZXIxXCJcclxuICAgICogfSk7XHJcbiAgICAqIFxyXG4gICAgKiBobS5wb2x5bGluZSh7XHJcbiAgICAqICAgIGNvb3JkczogY29vcmRzLFxyXG4gICAgKiAgICBzdHlsZToge1xyXG4gICAgKiAgICAgICAgbGluZVdpZHRoOiA0LFxyXG4gICAgKiAgICAgICAgc3Ryb2tlQ29sb3I6IFwicmVkXCJcclxuICAgICogICAgfSxcclxuICAgICogfSk7XHJcbiAgICAqIFxyXG4gICAgKiBobS5wb2x5bGluZSh7XHJcbiAgICAgICAgKiAgICBjb29yZHM6IGNvb3JkcyxcclxuICAgICAgICAqICAgIGRhdGE6XCJIZWxsbyBXb3JsZFwiLFxyXG4gICAgICAgICogfSk7XHJcbiAgICAqICBgYGBcclxuICovXHJcbmZ1bmN0aW9uIHBvbHlsaW5lKG9wdCkge1xyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIGxheWVyOiBcImRlZmF1bHRcIixcclxuICAgICAgICBjb29yZHM6IG51bGwsIC8vIGNvb3JkcyBpcyBsaXN0IG9mIGFycmF5IG9mIFtsYXQsbG5nXSBvciBhcnJheSBvZiBvYmplY3Qgd2l0aCB7bGF0Oixsbmc6fVxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogNCxcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwicmdiYSgwLCAxMjgsIDI1NSwgMC43KVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhcnJvd3M6IG51bGwsXHJcbiAgICAgICAgZGF0YTogbnVsbCwgICAgICAgICAvLyBvcHRpb25hbCB1c2VyIGRhdGEgXHJcbiAgICAgICAgejogbnVsbCxcclxuICAgICAgICBwb2ludGVyQ2xpY2s6IG51bGwsIC8vIGNsaWNrXHJcbiAgICAgICAgcG9pbnRlckVudGVyOiBudWxsLCAvLyBjYWxsIGJhY2tcclxuICAgICAgICBwb2ludGVyTGVhdmU6IG51bGwgLy8gY2FsbCBiYWNrXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdCkpIC8vIGRpcmVjdGVtZW50IGxlcyBjb29yZFxyXG4gICAgICAgIG9wdCA9IHsgY29vcmRzOiBvcHQgfTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIGxldCBsYXllciA9IGxheWVyRmluZChzZXR0aW5ncy5sYXllcik7XHJcbiAgICBpZiAoIWxheWVyKSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJsYXllciBub3QgZm91bmQ6XCIgKyBzZXR0aW5ncy5sYXllcik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXNldHRpbmdzLmNvb3Jkcykge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiUG9seWxpbmU6IGNvb3JkcyBub3QgZm91bmQ6XCIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHN0cmlwID0gbmV3IEguZ2VvLlN0cmlwKCk7XHJcblxyXG4gICAgc2V0dGluZ3MuY29vcmRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgc3RyaXAucHVzaExhdExuZ0FsdChwb2ludFswXSwgcG9pbnRbMV0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IHBvbHlsaW5lID0gbmV3IEgubWFwLlBvbHlsaW5lKHN0cmlwLCB7XHJcbiAgICAgICAgc3R5bGU6IHNldHRpbmdzLnN0eWxlLFxyXG4gICAgICAgIGRhdGE6IHNldHRpbmdzLmRhdGEsXHJcbiAgICAgICAgYXJyb3dzOiBzZXR0aW5ncy5hcnJvd3NcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFogaW5kZXhcclxuICAgIGlmIChzZXR0aW5ncy56KSBwb2x5bGluZS5zZXRaSW5kZXgoc2V0dGluZ3Mueik7XHJcbiAgICAvLyB1c2VyIGRhdGFcclxuICAgIGlmIChzZXR0aW5ncy5kYXRhKSBwb2x5bGluZS5zZXREYXRhKHNldHRpbmdzLmRhdGEpO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyRW50ZXIpXHJcbiAgICAgICAgcG9seWxpbmUuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnBvaW50ZXJFbnRlcih0YXJnZXQsIGNvb3JkTzJBKGNvb3JkKSwgZXYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgaWYgKHNldHRpbmdzLnBvaW50ZXJMZWF2ZSlcclxuICAgICAgICBwb2x5bGluZS5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckxlYXZlKHRhcmdldCwgY29vcmRPMkEoY29vcmQpLCBldik7XHJcbiAgICAgICAgfSk7XHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckNsaWNrKVxyXG4gICAgICAgIHBvbHlsaW5lLmFkZEV2ZW50TGlzdGVuZXIoXCJ0YXBcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyQ2xpY2sodGFyZ2V0LCBjb29yZE8yQShjb29yZCksIGV2KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBsYXllci5hZGRPYmplY3QocG9seWxpbmUpO1xyXG5cclxuICAgIHJldHVybiBwb2x5bGluZTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBEcmF3IGEgcG9seWdvblxyXG4gKiBAYWxpYXMgaG06cG9seWdvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0ICBvcHRpb25zIHRvIGRyYXcgYSBwb2x5Z29uLiBTYW1lIG9wdGlvbnMgYXMgaG0ucG9seWxpbmVcclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb24ob3B0KSB7XHJcbiAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbGF5ZXI6IFwiZGVmYXVsdFwiLFxyXG4gICAgICAgIGNvb3JkczogXCJcIiwgLy8gY29vcmRzIGlzIGFycmF5IG9mIFtsYXQsbG5nXSBvciBhcnJheSBvZiB7bGF0Oixsbmc6fVxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogNCxcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwicmdiYSgwLCAxMjgsIDI1NSwgMC43KVwiLFxyXG4gICAgICAgICAgICBmaWxsQ29sb3I6IFwicmdiYSgwLCAxMjgsIDI1NSwgMC43KVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdHlsZUhvdmVyOiBudWxsLCAvLyBzdHlsZSBzaSBtb3VzZSBvdmVyXHJcbiAgICAgICAgYXJyb3dzOiBudWxsLFxyXG4gICAgICAgIGRhdGE6IG51bGwsIC8vIGFkZGl0aW9uYWwgZGF0YSB0byBjYXJyeVxyXG4gICAgICAgIHo6IG51bGwsXHJcbiAgICAgICAgcG9pbnRlckNsaWNrOiBudWxsLCAvLyBjbGlja1xyXG4gICAgICAgIHBvaW50ZXJFbnRlcjogbnVsbCwgLy8gY2FsbCBiYWNrXHJcbiAgICAgICAgcG9pbnRlckxlYXZlOiBudWxsIC8vIGNhbGwgYmFja1xyXG4gICAgfTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdCkpIC8vIGRpcmVjdGVtZW50IGxlcyBjb29yZFxyXG4gICAgICAgIG9wdCA9IHsgY29vcmRzOiBvcHQgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgbGV0IGxheWVyID0gbGF5ZXJGaW5kKHNldHRpbmdzLmxheWVyKTtcclxuICAgIGlmICghbGF5ZXIpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcImxheWVyIG5vdCBmb3VuZDpcIiArIHNldHRpbmdzLmxheWVyKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghc2V0dGluZ3MuY29vcmRzKSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJQb2x5bGluZTogY29vcmRzIG5vdCBmb3VuZDpcIik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgc3RyaXAgPSBuZXcgSC5nZW8uU3RyaXAoKTtcclxuICAgIHNldHRpbmdzLmNvb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgIHN0cmlwLnB1c2hMYXRMbmdBbHQocG9pbnRbMF0sIHBvaW50WzFdKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBwb2x5Z29uID0gbmV3IEgubWFwLlBvbHlnb24oc3RyaXAsIHtcclxuICAgICAgICBzdHlsZTogc2V0dGluZ3Muc3R5bGUsXHJcbiAgICAgICAgZGF0YTogc2V0dGluZ3MuZGF0YSxcclxuICAgICAgICBhcnJvd3M6IHNldHRpbmdzLmFycm93c1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLmRhdGEpIHBvbHlnb24uc2V0RGF0YShzZXR0aW5ncy5kYXRhKTtcclxuICAgIC8vIFogaW5kZXhcclxuICAgIGlmIChzZXR0aW5ncy56KSBwb2x5bGluZS5zZXRaSW5kZXgoc2V0dGluZ3Mueik7XHJcblxyXG4gICAgLy8gc2kgdW4gc3R5bGUgZGUgaG92ZXJcclxuICAgIGlmIChzZXR0aW5ncy5zdHlsZUhvdmVyKSB7XHJcbiAgICAgICAgcG9seWdvbi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmVudGVyXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICB0YXJnZXQuc2V0U3R5bGUoc2V0dGluZ3Muc3R5bGVIb3Zlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcG9seWdvbi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICB0YXJnZXQuc2V0U3R5bGUoc2V0dGluZ3Muc3R5bGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyRW50ZXIpXHJcbiAgICAgICAgcG9seWdvbi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmVudGVyXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHRhcmdldC5nZXREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyRW50ZXIodGFyZ2V0LCBjb29yZE8yQShjb29yZCksIGV2LCBkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyTGVhdmUpXHJcbiAgICAgICAgcG9seWdvbi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHRhcmdldC5nZXREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyTGVhdmUodGFyZ2V0LCBjb29yZE8yQShjb29yZCksIGV2LCBkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyQ2xpY2spXHJcbiAgICAgICAgcG9seWdvbi5hZGRFdmVudExpc3RlbmVyKFwidGFwXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHRhcmdldC5nZXREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyQ2xpY2sodGFyZ2V0LCBjb29yZE8yQShjb29yZCksIGV2LCBkYXRhKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBsYXllci5hZGRPYmplY3QocG9seWdvbik7XHJcblxyXG4gICAgcmV0dXJuIHBvbHlnb247XHJcbn0gLy8gZW5kIG9mIHBvbHlnb25cclxuXHJcbi8qKlxyXG4gKiBkcmF3IGEgY2lyY2xlXHJcbiAqIEBhbGlhcyBobTpjaXJjbGVcclxuICogQHBhcmFtIG9wdCB7Kn0gICBvcHRpb24gZm9yIGNpcmNsZVxyXG4gKiBAcGFyYW0gW29wdC5sYXllcl0ge1N0cmluZ30gb3B0aW9uYWwgbGF5ZXIgdG8gdXNlIFxyXG4gKiBAcGFyYW0gW29wdC5jb29yZF0ge2FycmF5fSBjZW50ZXIgb2YgdGhlIGNpcmNsZSwgYXMgXFxbNDguOCwyLjNcXF1cclxuICogQHBhcmFtIFtvcHQucmFkaXVzXSB7bnVtYmVyfSByYWRpdXMgaW4gbWV0ZXJcclxuICogQHBhcmFtIFtvcHQuc3R5bGVdIHtvYmplY3R9IG9wdGlvbmFsIGdyYXBoaWMgc3R5bGVcclxuICogQHBhcmFtIFtvcHQuc3R5bGUuc3Ryb2tlQ29sb3JdIHtzdHJpbmd9IGNvbG9yIG9mIHBlcmltZXRlclxyXG4gKiBAcGFyYW0gW29wdC5zdHlsZS5saW5lV2lkdGhdIHtudW1iZXJ9IGxpbmUgd2lkdGhcclxuICogQHBhcmFtIFtvcHQuc3R5bGUuZmlsbENvbG9yXSB7c3RyaW5nfSBmaWxsIGNvbG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBjaXJjbGUob3B0KSB7XHJcbiAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbGF5ZXI6IFwiZGVmYXVsdFwiLFxyXG4gICAgICAgIGNvb3JkOiBudWxsLFxyXG4gICAgICAgIHJhZGl1czogMTAwLCAvLyBtZXRlcnNcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogXCJyZ2JhKDU1LCA4NSwgMTcwLCAwLjIpXCIsIC8vIENvbG9yIG9mIHRoZSBwZXJpbWV0ZXJcclxuICAgICAgICAgICAgbGluZVdpZHRoOiAyLFxyXG4gICAgICAgICAgICBmaWxsQ29sb3I6IFwicmdiYSgwLCAxMjgsIDAsIDAuMSlcIiAgLy8gQ29sb3Igb2YgdGhlIGNpcmNsZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBsZXQgbGF5ZXIgPSBsYXllckZpbmQoc2V0dGluZ3MubGF5ZXIpO1xyXG4gICAgaWYgKCFsYXllcikge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwibGF5ZXIgbm90IGZvdW5kOlwiICsgc2V0dGluZ3MubGF5ZXIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcbiAgICBsZXQgY2lyY2xlID0gbmV3IEgubWFwLkNpcmNsZShcclxuICAgICAgICAvLyBUaGUgY2VudHJhbCBwb2ludCBvZiB0aGUgY2lyY2xlXHJcbiAgICAgICAgY29vcmRBMk8oc2V0dGluZ3MuY29vcmQpLFxyXG4gICAgICAgIC8vIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZSBpbiBtZXRlcnNcclxuICAgICAgICBzZXR0aW5ncy5yYWRpdXMsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzdHlsZTogc2V0dGluZ3Muc3R5bGVcclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIGxheWVyLmFkZE9iamVjdChjaXJjbGUpO1xyXG4gICAgcmV0dXJuIGNpcmNsZTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIHdhdGNoIHBvc2l0aW9uIG9uIEhUTUw1IHBvc2l0aW9uLiByZXF1aXJlcyBIVFRQU1xyXG4gKiBAYXN5bmNcclxuICogQGFsaWFzIGhtOmxvY2F0ZU1lXHJcbiAqIEBwYXJhbSBjYWxsYmFjayB7ZnVuY3Rpb259ICBjYWxsYmFjayB3aGVuIGNvb3JkIGNoYW5nZXMuIEZvcm1hdDogY2FsbGJhY2soY29vcmQsYWNjdXJhY3kpIFxyXG4gKiBAcGFyYW0gb3B0IHtPYmplY3R9IG9wdGlvbmFsIGdyYXBoaWMgb3B0aW9uc1xyXG4gKiBAcGFyYW0gW29wdC5wb3NpdGlvbl0ge29iamVjdH0gIGdyYXBoaWMgb3B0aW9ucyBmb3IgY2VudGVyLiBTZWUgYnVpbGRJY29uXHJcbiAqIEBwYXJhbSBbb3B0LnBvc2l0aW9uLnN2Z10ge3N0cmluZ30gIHN2ZyBmaWxlXHJcbiAqIEBwYXJhbSBbb3B0LnBvc2l0aW9uLmNvbG9yXSB7c3RyaW5nfSAgY29sb3IgZm9yICB7Y29sb3J9IHRhZ1xyXG4gKiBAcGFyYW0gW29wdC5wb3NpdGlvbi5zaXplXSB7bnVtYmVyfSAgc2l6ZSBvZiBpY29uXHJcbiAqIEBwYXJhbSBbb3B0LnBvc2l0aW9uLmFuY2hvcl0ge251bWJlcn0gIGFuY2hvciBvZiBpY29uXHJcbiAqIEBwYXJhbSBbb3B0LmFjY3VyYWN5XSB7b2JqZWN0fSAgZ3JhcGhpYyBvcHRpb25zIGZvciBhY2N1cmFjeSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0gW29wdC5hY2N1cmFjeS5zdHJva2VDb2xvcl0ge1N0cmluZ30gIGNvbG9yIG9mIGNpcmNsZSBsaW5lIHJlcHJlc2VudGluZyBhY2N1cmFjeSBhcmVhXHJcbiAqIEBwYXJhbSBbb3B0LmFjY3VyYWN5LmxpbmVXaWR0aF0ge251bWJlcn0gIHdpZHRoIG9mIGxpbmUgb2YgY2lyY2xlXHJcbiAqIEBwYXJhbSBbb3B0LmFjY3VyYWN5LmZpbGxDb2xvcl0ge1N0cmluZ30gIGZpbGwgY29sb3Igb2YgY2lyY2xlIHJlcHJlc2VudGluZyBhY2N1cmFjeSBhcmVhXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBsb2NhdGVNZShjYWxsYmFjaywgb3B0KSB7XHJcblxyXG4gICAgLy8gaWYgbm8gY2FsbGJhY2ssIHJlbW92ZSB0aGUgd2F0Y2hcclxuICAgIGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrICYmIF9sb2NhdGVNZSkge1xyXG4gICAgICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaChfbG9jYXRlTWUpO1xyXG4gICAgICAgICAgICBfbG9jYXRlTWUgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICBzdmc6IFwic3ZnL3RhcmdldC5zdmdcIixcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBcImJsYWNrXCIsXHJcbiAgICAgICAgICAgICAgICBhbmNob3I6IFwiY2VudGVyXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWNjdXJhY3k6IHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBcInJnYmEoMCwgMTI4LCAwLCAwLjgpXCIsIC8vIENvbG9yIG9mIHRoZSBwZXJpbWV0ZXJcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMixcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogXCJyZ2JhKDAsIDEyOCwgMCwgMC40KVwiICAvLyBDb2xvciBvZiB0aGUgY2lyY2xlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgICAgIGxldCBpY29uQ3Jvc3NIYWlyID0gYXdhaXQgYnVpbGRJY29uKHtcclxuICAgICAgICAgICAgc3ZnOiBzZXR0aW5ncy5wb3NpdGlvbi5zdmcsXHJcbiAgICAgICAgICAgIGltZzogc2V0dGluZ3MucG9zaXRpb24uaW1nLFxyXG4gICAgICAgICAgICBvcHQ6IHNldHRpbmdzLnBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAvL25hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oZnVuY3Rpb24gcG9zKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgX2xvY2F0ZU1lID0gbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24oKHBvc2l0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBncHMgPSBbcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlLCBwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlXTtcclxuXHJcbiAgICAgICAgICAgIGxheWVyRW1wdHkoXCJfZ3BzXCIpO1xyXG5cclxuICAgICAgICAgICAgLyogY2lyY2xlIHNob3dpbmcgdGhlIGFjY3VyYWN5IHJhZGl1cyovXHJcbiAgICAgICAgICAgIGNpcmNsZSh7XHJcbiAgICAgICAgICAgICAgICBsYXllcjogXCJfZ3BzXCIsXHJcbiAgICAgICAgICAgICAgICBjb29yZDogZ3BzLFxyXG4gICAgICAgICAgICAgICAgcmFkaXVzOiBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3ksXHJcbiAgICAgICAgICAgICAgICBzdHlsZTogc2V0dGluZ3MuYWNjdXJhY3lcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBtYXJrZXIoe1xyXG4gICAgICAgICAgICAgICAgbGF5ZXI6IFwiX2dwc1wiLFxyXG4gICAgICAgICAgICAgICAgY29vcmQ6IGdwcyxcclxuICAgICAgICAgICAgICAgIGljb246IGljb25Dcm9zc0hhaXJcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjayhncHMsIHBvc2l0aW9uLmNvb3Jkcy5hY2N1cmFjeSk7XHJcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBtc2cgPSBcIlwiO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgZXJyb3IuUEVSTUlTU0lPTl9ERU5JRUQ6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiVXNlciBkZW5pZWQgdGhlIHJlcXVlc3QgZm9yIEdlb2xvY2F0aW9uLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBlcnJvci5QT1NJVElPTl9VTkFWQUlMQUJMRTpcclxuICAgICAgICAgICAgICAgICAgICBtc2cgKz0gXCJMb2NhdGlvbiBpbmZvcm1hdGlvbiBpcyB1bmF2YWlsYWJsZS5cIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgZXJyb3IuVElNRU9VVDpcclxuICAgICAgICAgICAgICAgICAgICBtc2cgKz0gXCJ0aW1lZCBvdXQuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGVycm9yLlVOS05PV05fRVJST1I6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZC5cIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIkhUTUw1IGxvY2F0aW9uIGVycm9yOlwiICsgbXNnKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgICAgIHRocm93IChlKTtcclxuICAgICAgICB9LCB7IGVuYWJsZUhpZ2hBY2N1cmFjeTogdHJ1ZSB9XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwibm8gSFRNTDUgZ2VvbG9jYXRpb24gY2FwYWJpbGl0aWVzXCIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogcGVyZm9ybSBhIHNjcmVlbnNob3Qgb2YgdGhlIG1hcCBhbmQgcmV0dXJucyBhIHByb21pc2Ugd2l0aCB0aGUgZGF0YVxyXG4gKiBAYXN5bmNcclxuICogQGFsaWFzIGhtOnNjcmVlbnNob3RcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSBvcHRpb25zIGZvciBzY3JlZW5zaG90XHJcbiAqIEBwYXJhbSBbb3B0Lm5hbWVdIHtzdHJpbmd9IGZpbGVuYW1lIGZvciBkb3dubG9hZFxyXG4gKiBAcGFyYW0gW29wdC51aV0ge2Jvb2xlYW59IHRydWUgdG8gdWkgKHNjYWxlLCBldGMuLikgaW4gc2NyZWVuc2hvdFxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9IG9wdGlvbnMgZm9yIHNjcmVlbnNob3RcclxuICogXHJcbiAqIEByZXR1cm5zIHtkYXRhfSBiaW5hcnkgZGF0YSBvZiBpbWFnZVxyXG4gKiBcclxuICovXHJcbmZ1bmN0aW9uIHNjcmVlbnNob3Qob3B0KSB7XHJcbiAgICBsZXQgcGFyYSA9IG51bGw7XHJcbiAgICBpZiAob3B0ICYmIG9wdC51aSlcclxuICAgICAgICBwYXJhID0gW191aV07XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoXHJcbiAgICAgICAgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBfbWFwLmNhcHR1cmUoZnVuY3Rpb24gKGNhbnZhcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjYW52YXMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcIk1hcCBzY3JlZW5zaG90IG5vdCBzdXBwb3J0ZWRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0ICYmIG9wdC5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBhLmhyZWYgPSBkYXRhVVJMO1xyXG4gICAgICAgICAgICAgICAgICAgIGEudGFyZ2V0ID0gXCJfYmxhbmtcIjtcclxuICAgICAgICAgICAgICAgICAgICBhLmRvd25sb2FkID0gb3B0Lm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcclxuICAgICAgICAgICAgICAgICAgICBhLmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGFVUkwpO1xyXG4gICAgICAgICAgICB9LCBwYXJhKTtcclxuICAgICAgICB9KTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldE1hcEh0bWxJdGVtKCkge1xyXG4gICAgcmV0dXJuIF9odG1sSXRlbTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TWFwKCkge1xyXG4gICAgcmV0dXJuIF9tYXA7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QmVoYXZpb3IoKSB7XHJcbiAgICByZXR1cm4gX2JlaGF2aW9yO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0VUkoKSB7XHJcbiAgICByZXR1cm4gX3VpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGNvb3JkTzJBOiBjb29yZE8yQSxcclxuICAgIGNvb3JkQTJPOiBjb29yZEEyTyxcclxuICAgIGdldE1hcDogZ2V0TWFwLFxyXG4gICAgZ2V0VUk6IGdldFVJLFxyXG4gICAgZ2V0QmVoYXZpb3I6IGdldEJlaGF2aW9yLFxyXG4gICAgZ2V0TWFwSHRtbEl0ZW06IGdldE1hcEh0bWxJdGVtLFxyXG4gICAgbWFwOiBtYXAsXHJcbiAgICBnZXRBdmFpbGFibGVNYXBTdHlsZTogZ2V0QXZhaWxhYmxlTWFwU3R5bGUsXHJcbiAgICBzZXRTY2hlbWU6IHNldFNjaGVtZSxcclxuICAgIGxheWVyQ3JlYXRlOiBsYXllckNyZWF0ZSxcclxuICAgIGxheWVyRmluZDogbGF5ZXJGaW5kLFxyXG4gICAgbGF5ZXJEZWxldGU6IGxheWVyRGVsZXRlLFxyXG4gICAgbGF5ZXJFbXB0eTogbGF5ZXJFbXB0eSxcclxuICAgIGJ1aWxkSWNvbjogYnVpbGRJY29uLFxyXG4gICAgYnViYmxlVW5pcXVlOiBidWJibGVVbmlxdWUsXHJcbiAgICBidWJibGVVbmlxdWVIaWRlOiBidWJibGVVbmlxdWVIaWRlLFxyXG4gICAgbWFya2VyOiBtYXJrZXIsXHJcbiAgICBjaXJjbGU6IGNpcmNsZSxcclxuICAgIHBvbHlsaW5lOiBwb2x5bGluZSxcclxuICAgIHBvbHlnb246IHBvbHlnb24sXHJcbiAgICBnZXRDZW50ZXI6IGdldENlbnRlcixcclxuICAgIHNldENlbnRlcjogc2V0Q2VudGVyLFxyXG4gICAgZ2V0Wm9vbTogZ2V0Wm9vbSxcclxuICAgIHNldFpvb206IHNldFpvb20sXHJcbiAgICBnZXR2aWV3QkI6IGdldFZpZXdCQixcclxuICAgIHNldFZpZXdCQjogc2V0Vmlld0JCLFxyXG4gICAgbG9jYXRlTWU6IGxvY2F0ZU1lLFxyXG4gICAgc2NyZWVuc2hvdDogc2NyZWVuc2hvdFxyXG5cclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuY29uc3QgY20gPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XHJcblxyXG4vKipcclxuICogY29tcHV0ZSBhIHJvdXRlIHdpdGggb3B0aW9uYWwgd2F5cG9vaW50cy4gW1NlZSBtb3JlIGluZm8gb24gb3B0aW9uYWwgcGFyYW1ldGVyc10oaHR0cDovL2RvY3VtZW50YXRpb24uZGV2ZWxvcGVyLmhlcmUuY29tL3BkZi9yb3V0aW5nX2hscC83LjIuMTAwL1JvdXRpbmclMjBBUEklMjB2Ny4yLjEwMCUyMERldmVsb3BlcidzJTIwR3VpZGUucGRmKVxyXG4gKiAgQGFzeW5jXHJcbiAqIEBhbGlhcyBobTpyb3V0ZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlIC0gc291cmNlIGFzIFxcW2xhdCxsbmdcXF0uIENhbiBiZSBhcnJheSBvZiBcXFtsYXQsbG5nXFxdIHRvIGRlZmluZSB3YXlwb2ludHNcclxuICogQHBhcmFtIHtvYmplY3R9IGRlc3QgLSBkZXN0IGFzIFxcW2xhdCxsbmdcXF0uIENhbiBiZSBhcnJheSBvZiBcXFtsYXQsbG5nXFxdIHRvIGRlZmluZSB3YXlwb2ludHNcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSByb3V0ZSBvcHRpb25zIFxyXG4gKiBAcGFyYW0gW29wdC5tb2RlPWZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZGlzYWJsZWRdIHtzdHJpbmd9ICByb3V0aW5nIG1vZGVcclxuICogQHBhcmFtIFtvcHQucm91dGVhdHRyaWJ1dGVzPXdheXBvaW50cyxzdW1tYXJ5LHNoYXBlXSB7c3RyaW5nfSAgcm91dGUgYXR0cmlidXRlc1xyXG4gKiBAcGFyYW0gW29wdC5tYW5ldXZlcmF0dHJpYnV0ZXM9ZGlyZWN0aW9uLGFjdGlvbl0ge3N0cmluZ30gIG1hbm9ldXZlciBhdHRyaWJ1dGVzXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IHJldHVybnMgeyBzdW1tYXJ5OiBvYmplY3QsIGNvb3JkczphcnJheSxyb3V0ZTogb2JqZWN0LCBib2R5Om9iamVjdH0uIGNvb3JkcyBpcyBhcnJheSBvZiBjb29yZCwgdG8gYmUgdXNlZCB3aXRoIGhtLnBvbHlsaW5lLiBcclxuICpcclxuICogQGV4YW1wbGVcclxuICAqIGBgYGpzXHJcbiAgKiBjb25zdCByZXMgPSBhd2FpdCBobS5yb3V0ZShbNDguOCwyLjNdLFs0OC43LDIuNV0pO1xyXG4gICogY29uc29sZS5sb2cgKHJlcy5zdW1tYXJ5KTtcclxuICAqIFxyXG4gICogY29uc3QgcmVzID0gYXdhaXQgaG0ucm91dGUoW1s0OC44LDIuM10sWzQ4LjksMi43XV0sIFs0OS4zLDIuNV0pO1xyXG4gICogY29uc29sZS5sb2cgKHJlcy5yb3V0ZSk7IFxyXG4gICogXHJcbiAgKiBjb25zdCByZXMgPSBhd2FpdCBobS5yb3V0ZShbNDguOCwyLjNdLCBbWzQ4LjksMi43XSwgWzQ5LjMsMi41XV0pO1xyXG4gICogY29uc29sZS5sb2cgKHJlcy5zdW1tYXJ5KTsgXHJcbiAgKiBgYGBcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJvdXRlKHNvdXJjZSwgZGVzdCwgb3B0KSB7XHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbW9kZTogXCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkXCIsXHJcbiAgICAgICAgcmVwcmVzZW50YXRpb246IFwibGlua1BhZ2luZ1wiLFxyXG4gICAgICAgIHJvdXRlYXR0cmlidXRlczogXCJ3YXlwb2ludHMsc3VtbWFyeSxzaGFwZVwiLFxyXG4gICAgICAgIG1hbmV1dmVyYXR0cmlidXRlczogXCJkaXJlY3Rpb24sYWN0aW9uXCJcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcGFyYW1zID0gY20uYWRkQ3JlZGVudGlhbHMoc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgLy8gMSBzZXVsIHNvdXJjZSBvdSBhcnJheSBkZSBzb3VyY2UgP1xyXG4gICAgbGV0IGlkID0gMDtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVswXSkpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gc291cmNlW2ldO1xyXG4gICAgICAgICAgICBwYXJhbXNbXCJ3YXlwb2ludFwiICsgaWQrK10gPSBjb29yZFswXSArIFwiLFwiICsgY29vcmRbMV07XHJcbiAgICAgICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICAgIHBhcmFtc1tcIndheXBvaW50XCIgKyBpZCsrXSA9IHNvdXJjZVswXSArIFwiLFwiICsgc291cmNlWzFdO1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGRlc3RbMF0pKVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gZGVzdFtpXTtcclxuICAgICAgICAgICAgcGFyYW1zW1wid2F5cG9pbnRcIiArIGlkKytdID0gY29vcmRbMF0gKyBcIixcIiArIGNvb3JkWzFdO1xyXG4gICAgICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICBwYXJhbXNbXCJ3YXlwb2ludFwiICsgaWQrK10gPSBkZXN0WzBdICsgXCIsXCIgKyBkZXN0WzFdO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwicm91dGVcIiwgXCJhcGkuaGVyZS5jb20vcm91dGluZy83LjIvY2FsY3VsYXRlcm91dGUuanNvblwiKTtcclxuICAgIHJldHVybiBjbS5oZXJlUmVzdCh1cmwsIHBhcmFtcywgXCJwb3N0XCIpXHJcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcmVzLmJvZHkucmVzcG9uc2Uucm91dGVbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IHN1bW1hcnkgPSByb3V0ZS5zdW1tYXJ5O1xyXG4gICAgICAgICAgICBjb25zdCBjb29yZHMgPSByb3V0ZS5zaGFwZS5tYXAoKGxhdGxuZyA9PiBsYXRsbmcuc3BsaXQoXCIsXCIpKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyBzdW1tYXJ5OiBzdW1tYXJ5LCBjb29yZHM6IGNvb3Jkcywgcm91dGU6IHJvdXRlLCBib2R5OiByZXMuYm9keSB9O1xyXG5cclxuICAgICAgICB9KTtcclxuXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogY29tcHV0ZSBhbiBpc29saW5lLiBbU2VlIG1vcmUgaW5mbyBvbiBvcHRpb25hbCBwYXJhbWV0ZXJzXShodHRwOi8vZG9jdW1lbnRhdGlvbi5kZXZlbG9wZXIuaGVyZS5jb20vcGRmL3JvdXRpbmdfaGxwLzcuMi4xMDAvUm91dGluZyUyMEFQSSUyMHY3LjIuMTAwJTIwRGV2ZWxvcGVyJ3MlMjBHdWlkZS5wZGYpXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06aXNvbGluZVxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9IG9wdGlvbiBmb3IgaXNvbGluZVxyXG4gKiBAcGFyYW0gW29wdC5zdGFydF0ge2Nvb3JkfSBjb29yZCBmb3Igc3RhcnRpbmcgcG9pbnQgb2YgaXNvbGluZVxyXG4gKiBAcGFyYW0gW29wdC5kZXN0aW5hdGlvbl0ge2Nvb3JkfSBjb29yZCBmb3IgZGVzdGluYXRpb24gcG9pbnQgb2YgaXNvbGluZVxyXG4gKiBAcGFyYW0gW29wdC5yYW5nZVR5cGU9XCJ0aW1lXCJdIHtzdHJpbmd9IHRpbWUgb3IgZGlzdGFuY2VcclxuICogQHBhcmFtIFtvcHQucmFuZ2VdIHtudW1iZXJ9IHJhbmdlIGluIHNlY29uZHMgb3IgaW4gbWV0ZXJzXHJcbiAqIEBwYXJhbSBbb3B0Lm1vZGU9XCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkXCJdIHtTdHJpbmd9IHJvdXRpbmcgbW9kZVxyXG4gKiBAcGFyYW0gW29wdC5saW5rYXR0cmlidXRlcz1zaF0ge1N0cmluZ30gYXR0cmlidXRlcyB0byBiZSByZXR1cm5lZFxyXG4gKiBcclxuICogQHJldHVybnMge29iamVjdH0gIHJldHVybnMgeyBwb2x5OmFycmF5LCBib2R5Om9iamVjdCB9LiBQb2x5IGlzIGFycmF5IG9mIGNvb3JkcywgYm9keSBpcyBmdWxsIGFuc3dlclxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gaXNvbGluZShvcHQpIHtcclxuXHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBzdGFydDogbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGRpcmVjdCBpc29saW5lXHJcbiAgICAgICAgZGVzdGluYXRpb246IG51bGwsICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciByZXZlcnNlIGlzb2xpbmVcclxuICAgICAgICByYW5nZVR5cGU6IFwidGltZVwiLCAgICAgICAgICAgICAgICAgICAgICAvLyB0aW1lIG9yIGRpc3RhbmNlXHJcbiAgICAgICAgcmFuZ2U6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHNlY29uZHMgb3IgbWV0ZXJzXHJcbiAgICAgICAgbGlua2F0dHJpYnV0ZXM6IFwic2hcIiwgICAgICAgICAgICAgICAgICAgLy8gdG8gZ2V0IHRoZSBzaGFwZVxyXG4gICAgICAgIG1vZGU6IFwiZmFzdGVzdDtjYXI7dHJhZmZpYzpkaXNhYmxlZFwiLCAgIC8vc2hvcnRlc3Q7Y2FyO3RyYWZmaWM6ZGlzYWJsZWQgXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGFyYW1zID0gY20uYWRkQ3JlZGVudGlhbHMoc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgaWYgKHBhcmFtcy5zdGFydClcclxuICAgICAgICBwYXJhbXMuc3RhcnQgPSBcImdlbyFcIiArIHBhcmFtcy5zdGFydFswXSArIFwiLFwiICsgcGFyYW1zLnN0YXJ0WzFdO1xyXG4gICAgaWYgKHBhcmFtcy5kZXN0aW5hdGlvbilcclxuICAgICAgICBwYXJhbXMuZGVzdGluYXRpb24gPSBcImdlbyFcIiArIHBhcmFtcy5kZXN0aW5hdGlvblswXSArIFwiLFwiICsgcGFyYW1zLmRlc3RpbmF0aW9uWzFdO1xyXG5cclxuICAgIGlmICghcGFyYW1zLnN0YXJ0ICYmICFwYXJhbXMuZGVzdGluYXRpb24pIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIklzb2xpbmUgcm91dGluZyA6IG1pc3Npbmcgc3RhcnQgb3IgZGVzdGluYXRpb25cIik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxuICAgIGlmICghcGFyYW1zLnJhbmdlKSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJJc29saW5lIHJvdXRpbmcgOiBtaXNzaW5nIHJhbmdlXCIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdXJsID0gY20uYnVpbGRVcmwoXCJpc29saW5lLnJvdXRlXCIsIFwiYXBpLmhlcmUuY29tL3JvdXRpbmcvNy4yL2NhbGN1bGF0ZWlzb2xpbmUuanNvblwiKTtcclxuICAgIHJldHVybiBjbS5oZXJlUmVzdCh1cmwsIHBhcmFtcywgXCJwb3N0XCIpXHJcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIGFycmF5IG9mIGxhdCxsbmcsIHRvIGJlIHRyYW5zZm9ybWVkIGludG8gYXJyYXkgb2YgW2xhdCxsbmddXHJcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gcmVzLmJvZHkucmVzcG9uc2UuaXNvbGluZVswXS5jb21wb25lbnRbMF0uc2hhcGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvbHkgPSBzaGFwZS5tYXAocG9pbnQgPT4gcG9pbnQuc3BsaXQoXCIsXCIpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7IHBvbHk6IHBvbHksIGJvZHk6IHJlcy5ib2R5IH07XHJcbiAgICAgICAgfSk7XHJcblxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIGNvbXB1dGUgYSBtYXRyaXguIFtTZWUgbW9yZSBpbmZvIG9uIG9wdGlvbmFsIHBhcmFtZXRlcnNdKGh0dHA6Ly9kb2N1bWVudGF0aW9uLmRldmVsb3Blci5oZXJlLmNvbS9wZGYvcm91dGluZ19obHAvNy4yLjEwMC9Sb3V0aW5nJTIwQVBJJTIwdjcuMi4xMDAlMjBEZXZlbG9wZXIncyUyMEd1aWRlLnBkZilcclxuICogXHJcbiAqIE1hdHJpeCBzaXplIGlzIGxpbWl0ZWQgdG8gMXgxMDAsIDEwMHgxIG9yIDE1eE5cclxuICogIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06bWF0cml4XHJcbiAqIEBwYXJhbSBzb3VyY2Uge29iamVjdH0gc291cmNlIGFzIFxcW2xhdCxsbmdcXF0uIENhbiBiZSBhcnJheSBvZiBcXFtsYXQsbG5nXFxdXHJcbiAqIEBwYXJhbSBkZXN0IHtvYmplY3R9IGRlc3QgYXMgXFxbbGF0LGxuZ1xcXS4gQ2FuIGJlIGFycmF5IG9mIFxcW2xhdCxsbmdcXF1cclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSBhZGRpdGlvbmFsIG9wdGlvbmFsIHBhcmFtZXRlcnMgbGlrZSAgbW9kZSwgc3VtbWFyeUF0dHJpYnV0ZXNcclxuICogQHBhcmFtIFtvcHQubW9kZT1cImZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZW5hYmxlZFwiXSB7c3RyaW5nfSByb3V0aW5nIG1vZGUgdG8gY29tcHV0ZSBtYXRyaXhcclxuICogQHBhcmFtIFtvcHQuc3VtbWFyeUF0dHJpYnV0ZXM9XCJ0dCxkaVwiXSB7c3RyaW5nfSBhdHRyaWJ1dGVzIGluIHRoZSBhbnN3ZXJcclxuICogXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IHsgZW50cmllczogb2JqZWN0LCBib2R5Om9iamVjdCB9LiBlbnRyaWVzIGlzIHRoZSBhcnJheSBvZiB7c3RhcnQsc3RvcH0gaW5mb3JtYXRpb24uIGJvZHkgaXMgZnVsbCBqc29uIGFuc3dlclxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCByZXMgPSBhd2FpdCBobS5tYXRyaXgoe1xyXG4gKiAgICAgIHNvdXJjZTpbNDguOCwyLjNdXHJcbiAqICAgICAgZGVzdDpbWzQ4LjcsMi41XSxbNDguMSwyLjBdLFs0NC4yLDIuM11dXHJcbiAqIH0pO1xyXG4gKiBjb25zb2xlLmxvZyAocmVzLmVudHJpZXMpOyBcclxuICogYGBgXHJcbiAqL1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gbWF0cml4KHNvdXJjZSwgZGVzdCwgb3B0KSB7XHJcblxyXG4gICAgdmFyIHNldHRpbmdzID0ge1xyXG4gICAgICAgIG1vZGU6IFwiZmFzdGVzdDtjYXI7dHJhZmZpYzplbmFibGVkXCIsXHJcbiAgICAgICAgc3VtbWFyeUF0dHJpYnV0ZXM6IFwidHQsZGlcIlxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhcmFtcyA9IGNtLmFkZENyZWRlbnRpYWxzKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShzb3VyY2VbMF0pKSAvLyBpZiBvbmx5IG9uZSBjb29yZFxyXG4gICAgICAgIHNvdXJjZSA9IFtzb3VyY2VdO1xyXG4gICAgc291cmNlLmZvckVhY2goKGNvb3JkLCBpKSA9PiB7XHJcbiAgICAgICAgcGFyYW1zW1wic3RhcnRcIiArIGldID0gY29vcmRbMF0gKyBcIixcIiArIGNvb3JkWzFdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRlc3RbMF0pKSAvLyBpZiBvbmx5IG9uZSBjb29yZFxyXG4gICAgICAgIGRlc3QgPSBbZGVzdF07XHJcbiAgICBkZXN0LmZvckVhY2goKGNvb3JkLCBpKSA9PiB7XHJcbiAgICAgICAgcGFyYW1zW1wiZGVzdGluYXRpb25cIiArIGldID0gY29vcmRbMF0gKyBcIixcIiArIGNvb3JkWzFdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXJsID0gY20uYnVpbGRVcmwoXCJtYXRyaXgucm91dGVcIiwgXCJhcGkuaGVyZS5jb20vcm91dGluZy83LjIvY2FsY3VsYXRlbWF0cml4Lmpzb25cIik7XHJcbiAgICByZXR1cm4gY20uaGVyZVJlc3QodXJsLCBwYXJhbXMsIFwicG9zdFwiKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGVudHJpZXM6IHJlcy5ib2R5LnJlc3BvbnNlLm1hdHJpeEVudHJ5LCBib2R5OiByZXMuYm9keSB9O1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIGRldG91ciBmb3IgZWFjaCB3YXlwb2ludCBwcm92aWRlZCwgY29tcGFyZWQgdG8gbm9ybWFsIHJvdXRlIGZyb20gQSB0byBCXHJcbiAqIFxyXG4gKiBAYXN5bmNcclxuICogQGFsaWFzIGhtOmRldG91clxyXG4gKiBAcGFyYW0gc3RhcnQge2Nvb3JkfSAgc3RhcnRpbmcgcG9pbnQgZm9yIHJvdXRlXHJcbiAqIEBwYXJhbSBzdG9wIHtjb29yZH0gICBkZXN0aW5hdGlvbiBwb2ludCBvZiByb3V0ZVxyXG4gKiBAcGFyYW0gd2F5cG9pbnRzIHthcnJheX0gIGxpc3Qgb2Ygd2F0eXBvaW50cyB0byB0ZXN0IFxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSByZXR1cm5zIHtyZWZlcmVuY2Usd2F5cG9pbnRzOlsge2Nvb3JkLGRpc3RBLHRpbWVBLGRpc3RCLHRpbWVCfV19XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZXRvdXIoc3RhcnQsIHN0b3AsIHdheXBvaW50cykge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICAgbm8tdW5kZWZcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShcclxuICAgICAgICBhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIC8vbGV0IHRTdGFydCA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0KSByZXR1cm4gcmVqZWN0KFwibWlzc2luZyBzdGFydCBwb2ludFwiKTtcclxuICAgICAgICAgICAgaWYgKCFzdG9wKSByZXR1cm4gcmVqZWN0KFwibWlzc2luZyBzdG9wIHBvaW50XCIpO1xyXG4gICAgICAgICAgICBpZiAoIXdheXBvaW50cykgcmV0dXJuIHJlamVjdChcIm1pc3Npbmcgd2F5cG9pbnRzXCIpO1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkpIHJldHVybiByZWplY3QoXCJ3YXlwb2ludHMgc2hvdWxkIGJlIGFuIGFycmF5XCIpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGluaXRpYWxpc2UgbGUgcmVzdWx0YXQgXHJcbiAgICAgICAgICAgIGxldCByZXMgPSB7XHJcbiAgICAgICAgICAgICAgICByZWZlcmVuY2U6IHt9LFxyXG4gICAgICAgICAgICAgICAgd2F5cG9pbnRzOiBbXVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gY2FsY3VsIGxlcyBjb29yZHMgbm9uUG9zdEdyZXMsIGNyZWVyIGwnYXJyYXkgZGUgY29vcmQgZGVzIHdheXBvaW50cy5cclxuICAgICAgICAgICAgbGV0IGRlc3QgPSBbc3RvcF07IC8vIHNvIHdlIGhhdmUgYSBkaXN0YW5jZS90aW1lIHJlZmVyZW5jZSwgbm90IHNhbWUgYXMgZnJvbSByb3V0aW5nIDE6MVxyXG4gICAgICAgICAgICB3YXlwb2ludHMuZm9yRWFjaCh3YXlwb2ludCA9PiB7XHJcbiAgICAgICAgICAgICAgICBkZXN0LnB1c2god2F5cG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgcmVzLndheXBvaW50cy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIHsgY29vcmQ6IHdheXBvaW50IH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBpbnNwZWN0KGRlc3QsIFwiZGVzdCBmcm9tIGRldG91clwiKVxyXG5cclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBzdGFydCB0byBhbGwgd2F5cG9pbnQsIDFzdCB3YXlwb2ludCBpcyBzdG9wIHRvIGdldCBhIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICBsZXQgcDEgPSBtYXRyaXgoc3RhcnQsIGRlc3QsIHsgbW9kZTogXCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkXCIgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBjb21wdXRlIGZyb20gYWxsIHdheXBvaW50IHRvIHN0b3AsIDFzdCB3YXlwb2ludCBpcyBzdGFydCB0byBnZXQgYW5vdGhlciByZWZlcmVuY2VcclxuICAgICAgICAgICAgZGVzdFswXSA9IHN0YXJ0O1xyXG4gICAgICAgICAgICBsZXQgcDIgPSBtYXRyaXgoZGVzdCwgc3RvcCwgeyBtb2RlOiBcImZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZGlzYWJsZWRcIiB9KTtcclxuICAgICAgICAgICAgLy8gd2FpdCBmb3IgYm90aCBtYXRyaXggdG8gY29tcGxldGVcclxuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgIG5vLXVuZGVmXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKFtwMSwgcDJdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgZmlyc3QgcGFydDogc3RhcnQgPT4gTiB3YXlwb2ludHNcclxuICAgICAgICAgICAgbGV0IGVudHJpZXMgPSByZXN1bHRbMF0uZW50cmllcztcclxuICAgICAgICAgICAgLy8gZmlyc3QgZW50cnkgaXMgc3RhcnQgc3RvcFxyXG4gICAgICAgICAgICBsZXQgZGlzdCA9IGVudHJpZXNbMF0uc3VtbWFyeS5kaXN0YW5jZTtcclxuICAgICAgICAgICAgbGV0IHRpbWUgPSBlbnRyaWVzWzBdLnN1bW1hcnkudHJhdmVsVGltZTtcclxuICAgICAgICAgICAgcmVzLnJlZmVyZW5jZS5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICByZXMucmVmZXJlbmNlLnN0b3AgPSBzdG9wO1xyXG4gICAgICAgICAgICByZXMucmVmZXJlbmNlLmRpc3RhbmNlID0gZGlzdDtcclxuICAgICAgICAgICAgcmVzLnJlZmVyZW5jZS50aW1lID0gdGltZTsgLy8gdGhlIHJlZmVyZW5jZSBzYW5zIHdheXBvaW50XHJcblxyXG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSByZXR1cm47IC8vIHNraXAgdGhlIGZpcnN0IHdoaWNoIGlzIHN0YXJ0IHN0b3BcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuc3RhdHVzID09IFwiZmFpbGVkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVudHJ5LCBcImVycm9yIG9uIG1hdHJpeEFcIiArIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coc3RhcnQsIFwiYXNzb2NpYXRlZCBzdGFydFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGRlc3RbaV0sIFwiYXNzb2NpYXRlZCBkZXN0XCIgKyBpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGlkID0gZW50cnkuZGVzdGluYXRpb25JbmRleDtcclxuICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gZW50cnkuc3VtbWFyeS5kaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCB0aW1lID0gZW50cnkuc3VtbWFyeS50cmF2ZWxUaW1lO1xyXG4gICAgICAgICAgICAgICAgcmVzLndheXBvaW50c1tpZCAtIDFdLmRpc3RBID0gZGlzdDtcclxuICAgICAgICAgICAgICAgIHJlcy53YXlwb2ludHNbaWQgLSAxXS50aW1lQSA9IHRpbWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIHByb2Nlc3Mgc2Vjb25kIHBhcnQ6IE4gd2F5cG9pbnRzID0+IHN0b3BcclxuICAgICAgICAgICAgZW50cmllcyA9IHJlc3VsdFsxXS5lbnRyaWVzO1xyXG4gICAgICAgICAgICAvL2luc3BlY3QoZW50cmllc1swXSwgXCJtYXRyaXhCMFwiKTtcclxuXHJcbiAgICAgICAgICAgIHJlcy5yZWZlcmVuY2UuZGlzdGFuY2UyID0gZW50cmllc1swXS5zdW1tYXJ5LmRpc3RhbmNlO1xyXG4gICAgICAgICAgICByZXMucmVmZXJlbmNlLnRpbWUyID0gZW50cmllc1swXS5zdW1tYXJ5LnRyYXZlbFRpbWU7XHJcblxyXG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSByZXR1cm47IC8vIHNraXAgdGhlIGZpcnN0IHdoaWNoIGlzIHN0YXJ0IHN0b3BcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuc3RhdHVzID09IFwiZmFpbGVkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVudHJ5LCBcImVycm9yIG9uIG1hdHJpeEJcIiArIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZW50cnksIFwiYXNzb2NpYXRlZCBzdGFydFwiICsgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzdG9wLCBcImFzc29jaWF0ZWQgc3RvcFwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBlbnRyeS5zdGFydEluZGV4O1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpc3QgPSBlbnRyeS5zdW1tYXJ5LmRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRpbWUgPSBlbnRyeS5zdW1tYXJ5LnRyYXZlbFRpbWU7XHJcbiAgICAgICAgICAgICAgICByZXMud2F5cG9pbnRzW2lkIC0gMV0uZGlzdEIgPSBkaXN0O1xyXG4gICAgICAgICAgICAgICAgcmVzLndheXBvaW50c1tpZCAtIDFdLnRpbWVCID0gdGltZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlcyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBtYXRyaXg6IG1hdHJpeCxcclxuICAgIHJvdXRlOiByb3V0ZSxcclxuICAgIGlzb2xpbmU6IGlzb2xpbmUsXHJcbiAgICBkZXRvdXI6IGRldG91clxyXG59O1xyXG5cclxuIiwiLyogZ2xvYmFsIGRvY3VtZW50LEggKi9cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmNvbnN0IGhtID0gcmVxdWlyZShcIi4vbWFwLmpzXCIpO1xyXG5jb25zdCBzaW1wbGlmeSA9IHJlcXVpcmUoXCJzaW1wbGlmeS1qc1wiKTtcclxuXHJcblxyXG5sZXQgX3RvdWNoT2Zmc2V0ID0gbnVsbDtcclxubGV0IF90b3VjaENvb3JkcyA9IG51bGw7XHJcbmxldCBfdG91Y2hQb2x5bGluZSA9IG51bGw7XHJcbmxldCBfdG91Y2hMYXllciA9IG51bGw7XHJcbmxldCBfdG91Y2hDYWxsYmFjayA9IG51bGw7XHJcbmxldCBfbWFwID0gbnVsbDtcclxubGV0IF9iZWhhdmlvciA9IG51bGw7XHJcblxyXG5sZXQgX2JlaGF2aW9yRW5hYmxlID0gdHJ1ZTtcclxuZnVuY3Rpb24gYmVoYXZpb3JFbmFibGUob25vZmYpIHtcclxuICAgIGlmIChfYmVoYXZpb3JFbmFibGUgJiYgIW9ub2ZmKSB7XHJcbiAgICAgICAgX2JlaGF2aW9yLmRpc2FibGUoKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiYmVoYXZpb3IgZGlzYWJsZWRcIik7XHJcbiAgICAgICAgX2JlaGF2aW9yRW5hYmxlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIV9iZWhhdmlvckVuYWJsZSAmJiBvbm9mZikge1xyXG4gICAgICAgIF9iZWhhdmlvci5lbmFibGUoKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiYmVoYXZpb3IgZW5hYmxlZFwiKTtcclxuICAgICAgICBfYmVoYXZpb3JFbmFibGUgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBhY3RpdmF0ZSB0b3VjaCwgYWxsb3dpbmcgaGFuZCBkcmF3aW5nLCB3aXRoIGVtYmVkZGVkIHNpbXBsaWZpY2F0aW9uIG9mIHRoZSBsaW5lXHJcbiAqIEBhbGlhcyBobTp0b3VjaFxyXG4gKiBAcGFyYW0gb25vZmYge2Jvb2xlYW59ICBhY3RpdmF0ZSBvciBkZWFjdGl2YXRlXHJcbiAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9IG9wdGlvbnMgIHRvIGNvbnRyb2wgdGhlIHRvdWNoIGJlaGF2aW91clxyXG4gKiBAcGFyYW0gW29wdGlvbnMuY2FsbGJhY2tdIHtmdW5jdGlvbn0gY2FsbGluZyBjYWxsYmFjayhjb29yZHMpIHdoZW4gdG91Y2ggZW5kc1xyXG4gKiBAcGFyYW0gW29wdGlvbnMubGF5ZXJdIHtzdHJpbmd9IGxheWVyIHdoZXJlIHRvIHB1dCB0aGUgZHJhd2luZ1xyXG4gKiBAcGFyYW0gW29wdGlvbnMuc3R5bGVdIHtvYmplY3R9IGRyYXdpbmcgc3R5bGUgZm9yIHRoZSBsaW5lXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5hcnJvd10ge29iamVjdH0gYXJyb3cgc3R5bGUgZm9yIHRoZSBsaW5lXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy50b2xlcmFuY2U9NF0ge251bWJlcn0gdG9sZXJhbmNlIGZvciBzaW1wbGlmaWNhdGlvblxyXG4gKiBAcGFyYW0gW29wdGlvbnMua2VlcD1mYWxzZV0ge2Jvb2xlYW59IGtlZXAgZ3JhcGhpYyBvciBub3Qgd2hlbiBjYWxsaW5nIGNhbGxiYWNrXHJcbiAqL1xyXG5mdW5jdGlvbiB0b3VjaChvbm9mZiwgb3B0aW9ucykge1xyXG5cclxuICAgIF9tYXAgPSBobS5nZXRNYXAoKTtcclxuICAgIF9iZWhhdmlvciA9IGhtLmdldEJlaGF2aW9yKCk7XHJcbiAgICBsZXQgZWxtdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhtLmdldE1hcEh0bWxJdGVtKCkpO1xyXG5cclxuICAgIF90b3VjaE9mZnNldCA9IHsgbGVmdDogZWxtdC5vZmZzZXRMZWZ0LCB0b3A6IGVsbXQub2Zmc2V0VG9wIH07IC8vIG9mZnNldCBvZiB3aW5kb3cgdG8gYnJvd3NlclxyXG5cclxuXHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBjYWxsYmFjazogbnVsbCxcclxuICAgICAgICBsYXllcjogXCJfdG91Y2hcIixcclxuICAgICAgICBrZWVwOiBmYWxzZSxcclxuICAgICAgICBzdHlsZTogeyBsaW5lV2lkdGg6IDUsIHN0cm9rZUNvbG9yOiBcInJnYmEoMjU1LCAwLCAwLCAwLjcpXCIgfSxcclxuICAgICAgICBhcnJvd3M6IHsgZmlsbENvbG9yOiBcIndoaXRlXCIsIGZyZXF1ZW5jeTogNSwgd2lkdGg6IDEsIGxlbmd0aDogMiB9LFxyXG4gICAgICAgIHRvbGVyYW5jZTogNCwgLy8gbGV2ZWwgb2Ygc2ltcGxpZmljYXRpb25cclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgb3B0aW9ucyk7XHJcblxyXG4gICAgX3RvdWNoTGF5ZXIgPSBobS5sYXllckZpbmQoc2V0dGluZ3MubGF5ZXIpO1xyXG4gICAgaWYgKCFfdG91Y2hMYXllcikge1xyXG4gICAgICAgIGhtLmxheWVyRW1wdHkoc2V0dGluZ3MubGF5ZXIpO1xyXG4gICAgICAgIF90b3VjaExheWVyID0gaG0ubGF5ZXJGaW5kKHNldHRpbmdzLmxheWVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjYWxsYmFjayBkZXMgZXZlbnQgTGlzdGVuZXJcclxuICAgIC8vIGRlZmluaSBzZXVsZW1lbnQgc3VyIG9ub2ZmLCBwb3VyIG5lIHBhcyBjcmVlciB1bmUgYXV0cmUgZm9pcyBsYSBmb25jdGlvblxyXG4gICAgaWYgKG9ub2ZmKVxyXG4gICAgICAgIF90b3VjaENhbGxiYWNrID0gZnVuY3Rpb24gKGUpIHtcclxuXHJcbiAgICAgICAgICAgIGxldCB0b3VjaG9iaiA9IGUuY2hhbmdlZFRvdWNoZXNbMF07IC8vIHJlZmVyZW5jZSBmaXJzdCB0b3VjaCBwb2ludCAoaWU6IGZpcnN0IGZpbmdlcilcclxuXHJcbiAgICAgICAgICAgIC8vIGlmICgoZS50b3VjaGVzLmxlbmd0aCA+PSAyICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPj0gMikpIHtcclxuICAgICAgICAgICAgaWYgKChlLnRvdWNoZXMubGVuZ3RoID49IDIpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICBjb25zb2xlLmxvZyhcInRvdWNoLmxlbmd0aFwiLCBlLnRvdWNoZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGJlaGF2aW9yRW5hYmxlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZS50eXBlID09IFwidG91Y2htb3ZlXCIpXHJcbiAgICAgICAgICAgICAgICBiZWhhdmlvckVuYWJsZShmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJlLnR5cGVcIiwgZS50eXBlKTtcclxuICAgICAgICAgICAgbGV0IHNpbXBsaWZpZWQ7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKGUudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInRvdWNoc3RhcnRcIjpcclxuICAgICAgICAgICAgICAgICAgICBfdG91Y2hDb29yZHMgPSBbXTsgLy8gY29vcmRzXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInRvdWNobW92ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF90b3VjaENvb3Jkcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogdG91Y2hvYmouY2xpZW50WCAtIF90b3VjaE9mZnNldC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0b3VjaG9iai5jbGllbnRZIC0gX3RvdWNoT2Zmc2V0LnRvcFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RvdWNoQ29vcmRzLmxlbmd0aCA8IDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVTdHJpbmcgPSBuZXcgSC5nZW8uTGluZVN0cmluZztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdG91Y2hDb29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhfdG91Y2hDb29yZHNbaV0ueCwgX3RvdWNoQ29vcmRzW2ldLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RyaW5nLnB1c2hMYXRMbmdBbHQoY29vcmQubGF0LCBjb29yZC5sbmcsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGxwb2x5bGluZSBpZiBub3QgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdG91Y2hQb2x5bGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdG91Y2hQb2x5bGluZSA9IG5ldyBILm1hcC5Qb2x5bGluZShsaW5lU3RyaW5nLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogc2V0dGluZ3Muc3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvd3M6IHNldHRpbmdzLmFycm93c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RvdWNoTGF5ZXIuYWRkT2JqZWN0KF90b3VjaFBvbHlsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgIC8vIG1vZGlmIGdlb21ldHJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90b3VjaFBvbHlsaW5lLnNldEdlb21ldHJ5KGxpbmVTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b3VjaGVuZFwiOiAvLyBjJ2VzdCBsYSBmaW4sIG9uIHNpbXBsaWZpZSBldCBhcHBlbGxlIGxlIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90b3VjaENvb3Jkcy5sZW5ndGggPCAyKSAvLyBub3QgZW5vdWdoIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNpbXBsaWZpZWQgPSBfdG91Y2hDb29yZHM7IC8vYXMge3gseX1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbXBsaWZ5IHRoZSByZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnRvbGVyYW5jZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb29yZHN4eSA9IF90b3VjaENvb3Jkcy5tYXAoY29vcmQgPT4geyByZXR1cm4geyB4OiBjb29yZFsxXSwgeTogY29vcmRbMF0gfTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGlmaWVkID0gc2ltcGxpZnkoY29vcmRzeHksIHNldHRpbmdzLnRvbGVyYW5jZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2ltcGxpZmllZC5sZW5ndGggPCAxKSAvLyBub3QgZW5vdWdoIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBiYWNrIHRvIFtsYXQsbG5nXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29vcmRzID0gc2ltcGxpZmllZC5tYXAoY29vcmQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhdGxuZyA9IF9tYXAuc2NyZWVuVG9HZW8oY29vcmQueCwgY29vcmQueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2xhdGxuZy5sYXQsIGxhdGxuZy5sbmddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXAgdG8gY2FsbGJhY2sgdG8gcmVkcmF3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdG91Y2hQb2x5bGluZSAmJiAhc2V0dGluZ3Mua2VlcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90b3VjaExheWVyLnJlbW92ZU9iamVjdChfdG91Y2hQb2x5bGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90b3VjaFBvbHlsaW5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlaGF2aW9yRW5hYmxlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBydW4gY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuY2FsbGJhY2soY29vcmRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTsgLy8gb2YgX3RvdWNoXHJcblxyXG5cclxuXHJcbiAgICBpZiAob25vZmYpIHtcclxuICAgICAgICBlbG10LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF90b3VjaENhbGxiYWNrKTtcclxuICAgICAgICBlbG10LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgX3RvdWNoQ2FsbGJhY2spO1xyXG4gICAgICAgIGVsbXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90b3VjaENhbGxiYWNrKTtcclxuICAgICAgICAvLyAgICAgICAgYmVoYXZpb3JFbmFibGUoZmFsc2UpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxtdC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBfdG91Y2hDYWxsYmFjayk7XHJcbiAgICAgICAgZWxtdC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90b3VjaENhbGxiYWNrKTtcclxuICAgICAgICBlbG10LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBfdG91Y2hDYWxsYmFjayk7XHJcblxyXG4gICAgICAgIGlmIChfdG91Y2hQb2x5bGluZSlcclxuICAgICAgICAgICAgX3RvdWNoTGF5ZXIucmVtb3ZlT2JqZWN0KF90b3VjaFBvbHlsaW5lKTtcclxuXHJcbiAgICAgICAgX3RvdWNoTGF5ZXIgPSBudWxsO1xyXG4gICAgICAgIF90b3VjaFBvbHlsaW5lID0gbnVsbDtcclxuICAgICAgICBfdG91Y2hDb29yZHMgPSBudWxsO1xyXG4gICAgICAgIGJlaGF2aW9yRW5hYmxlKHRydWUpO1xyXG4gICAgfVxyXG5cclxuXHJcbn0gLy8gb2YgdG91Y2hcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHRvdWNoOiB0b3VjaFxyXG5cclxufTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qXHJcbiAqIEBtb2R1bGUgSEVSRU1BUFxyXG4gKiBAdHlwaWNhbG5hbWUgaG1cclxuICovXHJcblxyXG5sZXQgbW9kdWxlcyA9IHt9O1xyXG5PYmplY3QuYXNzaWduKG1vZHVsZXMsIHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XHJcbk9iamVjdC5hc3NpZ24obW9kdWxlcywgcmVxdWlyZShcIi4vcm91dGluZy5qc1wiKSk7XHJcbk9iamVjdC5hc3NpZ24obW9kdWxlcywgcmVxdWlyZShcIi4vZ2VvY29kaW5nLmpzXCIpKTtcclxuT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi9hdXRvY29tcGxldGUuanNcIikpO1xyXG5cclxuaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xyXG4gICAgT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi9tYXAuanNcIikpO1xyXG4gICAgT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi9jbHVzdGVyLmpzXCIpKTtcclxuICAgIE9iamVjdC5hc3NpZ24obW9kdWxlcywgcmVxdWlyZShcIi4vdG91Y2guanNcIikpO1xyXG59XHJcbi8vIGV4cG9ydCBhbGwgdGhlIGFib3ZlXHJcbm1vZHVsZS5leHBvcnRzID0gbW9kdWxlcztcclxuIl19
